# DayOf Multi-Tenant Architecture with BetterAuth

**Purpose**: Complete implementation guide for BetterAuth multi-tenant authorization in DayOf's event management and ticketing platform

**Stack Context**:

- Auth: BetterAuth (Hono) at `auth.dayof.ai`
- Apps: TanStack Start (SSR + SPA), Expo (iOS)
- Database: Neon Postgres + Drizzle ORM
- Orchestration: Inngest
- Hosting: Vercel (Node 22, Fluid Compute)

---

## Table of Contents

1. [Architecture Overview](#architecture-overview)
2. [BetterAuth Organization Model](#betterauth-organization-model)
3. [DayOf Organization Types](#dayof-organization-types)
4. [Schema Design](#schema-design)
5. [RBAC Patterns](#rbac-patterns)
6. [Session & Context Switching](#session--context-switching)
7. [Scenario Mappings](#scenario-mappings)
8. [Implementation Checklist](#implementation-checklist)
9. [Mobile Considerations (Expo)](#mobile-considerations-expo)
10. [Security & Best Practices](#security--best-practices)

---

## Architecture Overview

### Core Principle: Unified Portal, Multiple Contexts

**Design Philosophy**: One login for all roles/organizations

- Users never log out to switch contexts
- Same authentication system serves B2B (venue operators) and B2C (ticket purchasers)
- Organization membership is **optional** - attendees don't need to be members to buy tickets

### BetterAuth Foundation

BetterAuth provides:

- **Many-to-many** user ↔ organization relationships
- **Teams** (workspaces) within organizations
- **Active context** tracking in sessions (activeOrganizationId, activeTeamId)
- **Multi-role** support per membership (as of v1.2+)
- **Invitation system** with team scoping
- **RBAC** via Access Control (AC) system

### DayOf's Twist

**Ticket/Event Decoupling**: Unlike traditional platforms, tickets are tokens independent of events

- Tickets can be associated with individual events OR event groups
- Same user can be:
  - Venue owner in Org A
  - Affiliate promoter for Org B
  - Attendee at events from Org C (no membership)
  - Organizer of a group trip Org D

**This requires**: Flexible RBAC + clear separation between "membership roles" and "customer actions"

---

## BetterAuth Organization Model

### Core Tables (Generated by BetterAuth CLI)

BetterAuth creates these tables via `npx @better-auth/cli generate`:

```typescript
// ✅ Generated by BetterAuth - DO NOT manually define

// Core user table
user {
  id: string (UUID)
  name: string
  email: string (unique)
  emailVerified: boolean
  image?: string
  createdAt: timestamp
  updatedAt: timestamp
}

// Organization (tenant) table
organization {
  id: string (UUID)
  name: string
  slug: string (unique, URL-safe)
  logo?: string
  metadata?: json
  createdAt: timestamp
}

// Membership linking users to organizations
member {
  id: string (UUID)
  userId: string → user.id (cascade delete)
  organizationId: string → organization.id (cascade delete)
  role: string | string[] // Multi-role support (v1.2+)
  createdAt: timestamp
}

// Teams/workspaces within organizations (optional)
team {
  id: string (UUID)
  organizationId: string → organization.id (cascade delete)
  name: string
  createdAt: timestamp
  updatedAt: timestamp
}

// Team membership
teamMember {
  id: string (UUID)
  teamId: string → team.id (cascade delete)
  userId: string → user.id (cascade delete)
  createdAt: timestamp
}

// Invitations (with optional team scoping)
invitation {
  id: string (UUID)
  organizationId: string → organization.id
  email: string
  role: string
  teamId?: string → team.id (optional)
  status: "pending" | "accepted" | "rejected"
  expiresAt: timestamp
  invitedBy: string → user.id
  createdAt: timestamp
}

// Session (extended with active context)
session {
  id: string (UUID)
  userId: string → user.id (cascade delete)
  token: string (unique)
  expiresAt: timestamp
  ipAddress?: string
  userAgent?: string
  activeOrganizationId?: string → organization.id
  activeTeamId?: string → team.id
}
```

### Key Behaviors

**Multi-Organization Membership**:

- User can have multiple `member` records (one per org)
- Example: User A is `owner` in Org X, `affiliate` in Org Y, `volunteer` in Org Z

**Multi-Role Per Membership**:

- As of v1.2, `member.role` supports arrays: `["admin", "sales"]`
- Permission checks evaluate union of all roles
- API: `updateMemberRole({ role: string | string[] })`

**Active Context**:

- Session tracks current org (`activeOrganizationId`) and team (`activeTeamId`)
- Switch via: `authClient.organization.setActive({ organizationId })`
- Retrieve via: `authClient.organization.getActiveMember()`

**Team Scoping**:

- Teams are optional workspaces within an org
- Invitations can target a specific team: `invite({ teamId, role })`
- Team membership tracked in `teamMember` table

---

## DayOf Organization Types

### 1. Venue/Tenant Organizations

**Purpose**: Event hosting businesses (nightclubs, concert halls, festivals)

**Characteristics**:

- Creates and manages events
- Has staff with various roles (owner, manager, door staff, etc.)
- May have multiple physical locations (teams/workspaces)
- Receives payouts from ticket sales

**BetterAuth Mapping**:

- Organization represents the business entity
- Teams represent physical venues/locations (optional)
- Members are staff with operational roles

**Example**:

```text
Organization: "Miami Beach Nightclub Group"
├── Team: "Club Oasis" (South Beach location)
├── Team: "Venue Apex" (Downtown location)
└── Members:
    ├── User A: ["owner"] (org-wide)
    ├── User B: ["manager"] (Team: Club Oasis only)
    └── User C: ["door_staff"] (Team: Venue Apex only)
```

### 2. Growth Partner / Affiliate Organizations

**Purpose**: Promoters and marketing partners who drive ticket sales

**Characteristics**:

- Earn commission on referred sales (5-30% of application fee)
- May work with multiple venue organizations
- May have teams under them (sub-affiliates)
- Track referrals and earnings

**BetterAuth Mapping**:

- Growth partner is a `member` in the venue's organization with role `growth_partner`
- Or: Growth partner has their own organization and is cross-linked to venues
- Use teams to scope which events they can promote

**Example**:

```text
Organization: "Spring Break Promotions LLC"
├── Owner: User X (growth partner)
└── Cross-Org Memberships:
    ├── Member in "Miami Beach Nightclub Group" with role ["growth_partner"]
    └── Member in "Fort Lauderdale Events Co" with role ["affiliate"]
```

### 3. Sponsor Organizations

**Purpose**: Brands sponsoring events

**Characteristics**:

- May have access to event analytics
- May have branded experiences at events
- Don't manage events directly

**BetterAuth Mapping**:

- Organization represents sponsor
- Member in venue org with role `sponsor` (limited permissions)

### 4. Group Trip Organizations (Attendee Groups)

**Purpose**: Temporary organizations for coordinated group attendance

**Characteristics**:

- Fraternity trips, tour groups, corporate outings
- 10-100+ members
- Internal roles (organizer, member)
- Shared billing/coordination
- Members still act as individual ticket holders

**BetterAuth Mapping**:

- Organization flagged as "group" type (in metadata)
- Organizer gets custom role with management permissions
- Regular members have minimal permissions
- Purchases can link to group via `orders.purchaserOrganizationId`

**Example**:

```text
Organization: "Alpha Beta Spring Break 2026" (metadata: { type: "group" })
├── Members:
│   ├── User A: ["organizer"] (can invite, manage itinerary)
│   ├── User B: ["organizer"] (co-leader)
│   └── Users C-Z: ["member"] (basic access)
└── Shared Resources:
    ├── Group chat/coordination
    ├── Room assignments
    └── Bulk ticket purchases
```

---

## Schema Design

### BetterAuth Base + DayOf Extensions

**Strategy**: Let BetterAuth own auth tables, extend with application-specific tables

### Step 1: Generate BetterAuth Schema

```bash
# Run in packages/database
npx @better-auth/cli generate

# This creates auth tables: user, organization, member, team, teamMember, etc.
# Merge into your Drizzle schema
```

### Step 2: DayOf Application Tables

```typescript
// packages/database/src/schema/organizations.ts
import {
  pgTable,
  text,
  varchar,
  timestamp,
  jsonb,
  boolean,
  index,
} from "drizzle-orm/pg-core";

/**
 * Organization metadata extension
 * Stores DayOf-specific org type and config
 */
export const organizationMetadata = pgTable(
  "organization_metadata",
  {
    organizationId: text("organization_id")
      .primaryKey()
      .references(() => organizations.id, { onDelete: "cascade" }),

    type: varchar("type", { length: 32 }).notNull(), // "venue", "growth_partner", "sponsor", "group"

    // Venue-specific
    venueConfig: jsonb("venue_config"), // { payoutCadence, stripeAccountId, etc. }

    // Growth partner-specific
    affiliateConfig: jsonb("affiliate_config"), // { commissionRate, payoutThreshold, etc. }

    // Group-specific
    groupConfig: jsonb("group_config"), // { tripDates, maxMembers, etc. }

    createdAt: timestamp("created_at", { withTimezone: true })
      .defaultNow()
      .notNull(),
    updatedAt: timestamp("updated_at", { withTimezone: true })
      .defaultNow()
      .notNull(),
  },
  (t) => ({
    typeIdx: index("org_metadata_type_idx").on(t.type),
  })
);

/**
 * Venues (physical locations)
 * Links to organization, optionally scoped to team
 */
export const venues = pgTable(
  "venue",
  {
    id: text("id").primaryKey(),
    organizationId: text("organization_id")
      .notNull()
      .references(() => organizations.id, { onDelete: "cascade" }),
    teamId: text("team_id") // Optional: venue belongs to specific workspace
      .references(() => teams.id, { onDelete: "set null" }),

    name: text("name").notNull(),
    slug: varchar("slug", { length: 128 }).notNull(),
    address: text("address"),
    city: varchar("city", { length: 100 }),
    state: varchar("state", { length: 2 }),
    zip: varchar("zip", { length: 10 }),

    capacity: integer("capacity"),
    metadata: jsonb("metadata"),

    createdAt: timestamp("created_at", { withTimezone: true })
      .defaultNow()
      .notNull(),
  },
  (t) => ({
    orgIdx: index("venue_org_idx").on(t.organizationId),
    teamIdx: index("venue_team_idx").on(t.teamId),
    slugIdx: index("venue_slug_idx").on(t.slug),
  })
);

/**
 * Events (hosted by organizations)
 * Optionally scoped to team/workspace
 */
export const events = pgTable(
  "event",
  {
    id: text("id").primaryKey(),

    // Host organization and optional workspace
    organizationId: text("organization_id")
      .notNull()
      .references(() => organizations.id, { onDelete: "cascade" }),
    teamId: text("team_id") // Optional: event belongs to specific workspace
      .references(() => teams.id, { onDelete: "set null" }),

    venueId: text("venue_id").references(() => venues.id, {
      onDelete: "set null",
    }),

    slug: varchar("slug", { length: 128 }).notNull(),
    name: text("name").notNull(),
    description: text("description"),

    startsAt: timestamp("starts_at", { withTimezone: true }).notNull(),
    endsAt: timestamp("ends_at", { withTimezone: true }).notNull(),

    published: boolean("published").notNull().default(false),
    featured: boolean("featured").notNull().default(false),

    metadata: jsonb("metadata"),

    createdAt: timestamp("created_at", { withTimezone: true })
      .defaultNow()
      .notNull(),
    updatedAt: timestamp("updated_at", { withTimezone: true })
      .defaultNow()
      .notNull(),
  },
  (t) => ({
    orgSlugUniq: uniqueIndex("event_org_slug_uq").on(t.organizationId, t.slug),
    orgIdx: index("event_org_idx").on(t.organizationId),
    teamIdx: index("event_team_idx").on(t.teamId),
    publishedIdx: index("event_published_idx").on(t.published),
  })
);

/**
 * Orders (ticket purchases)
 * Buyer does NOT need to be member of event's organization
 */
export const orders = pgTable(
  "order",
  {
    id: text("id").primaryKey(),

    // Buyer (always required, but not necessarily an org member)
    userId: text("user_id")
      .notNull()
      .references(() => users.id, { onDelete: "restrict" }),

    // Optional: purchased under group context (e.g., fraternity trip)
    purchaserOrganizationId: text("purchaser_org_id").references(
      () => organizations.id,
      { onDelete: "set null" }
    ),

    status: varchar("status", { length: 32 }).notNull(), // "pending", "paid", "refunded"

    totalCents: integer("total_cents").notNull(),
    currency: varchar("currency", { length: 3 }).notNull().default("USD"),

    // Affiliate/growth partner attribution
    affiliateCode: varchar("affiliate_code", { length: 64 }),

    metadata: jsonb("metadata"),

    createdAt: timestamp("created_at", { withTimezone: true })
      .defaultNow()
      .notNull(),
    updatedAt: timestamp("updated_at", { withTimezone: true })
      .defaultNow()
      .notNull(),
  },
  (t) => ({
    userIdx: index("order_user_idx").on(t.userId),
    purchOrgIdx: index("order_purch_org_idx").on(t.purchaserOrganizationId),
    affiliateIdx: index("order_affiliate_idx").on(t.affiliateCode),
  })
);

/**
 * Tickets (individual entitlements)
 * Holder is always a user, not necessarily an org member
 */
export const tickets = pgTable(
  "ticket",
  {
    id: text("id").primaryKey(),
    nanoId: varchar("nano_id", { length: 16 }).notNull().unique(), // For scanning

    orderId: text("order_id")
      .notNull()
      .references(() => orders.id, { onDelete: "restrict" }),
    ticketTypeId: text("ticket_type_id")
      .notNull()
      .references(() => ticketTypes.id, { onDelete: "restrict" }),

    // Current holder (can transfer)
    holderUserId: text("holder_user_id")
      .notNull()
      .references(() => users.id, { onDelete: "restrict" }),

    // Immutable: host org and team at time of issuance
    hostOrganizationId: text("host_org_id")
      .notNull()
      .references(() => organizations.id, { onDelete: "restrict" }),
    hostTeamId: text("host_team_id").references(() => teams.id, {
      onDelete: "set null",
    }),

    status: varchar("status", { length: 24 }).notNull(), // "issued", "checked_in", "refunded", "transferred"

    // Physical card linking (optional)
    physicalCardId: varchar("physical_card_id", { length: 16 }),

    metadata: jsonb("metadata"),

    createdAt: timestamp("created_at", { withTimezone: true })
      .defaultNow()
      .notNull(),
    updatedAt: timestamp("updated_at", { withTimezone: true })
      .defaultNow()
      .notNull(),
  },
  (t) => ({
    orderIdx: index("ticket_order_idx").on(t.orderId),
    holderIdx: index("ticket_holder_idx").on(t.holderUserId),
    hostOrgIdx: index("ticket_host_org_idx").on(t.hostOrganizationId),
    nanoIdIdx: index("ticket_nano_id_idx").on(t.nanoId),
  })
);

/**
 * Affiliate/Growth Partner Links
 * Tracks referral codes and their relationships
 */
export const affiliateLinks = pgTable(
  "affiliate_link",
  {
    id: text("id").primaryKey(),
    code: varchar("code", { length: 64 }).notNull(),

    // Host organization (who this code refers to)
    organizationId: text("organization_id")
      .notNull()
      .references(() => organizations.id, { onDelete: "cascade" }),

    // Optional: scoped to specific team/workspace
    teamId: text("team_id").references(() => teams.id, { onDelete: "cascade" }),

    // Affiliate/growth partner user
    affiliateUserId: text("affiliate_user_id")
      .notNull()
      .references(() => users.id, { onDelete: "cascade" }),

    // Commission config (overrides default)
    commissionRate: decimal("commission_rate", { precision: 5, scale: 4 }), // e.g., 0.0500 = 5%

    active: boolean("active").notNull().default(true),

    metadata: jsonb("metadata"),

    createdAt: timestamp("created_at", { withTimezone: true })
      .defaultNow()
      .notNull(),
  },
  (t) => ({
    codeOrgUniq: uniqueIndex("aff_code_org_uq").on(t.organizationId, t.code),
    affiliateIdx: index("aff_user_idx").on(t.affiliateUserId),
    teamIdx: index("aff_team_idx").on(t.teamId),
  })
);
```

### Step 3: Team-Scoped Role Management (Optional)

**Use Case**: Limit specific roles to specific teams

Example: User has role "venue_manager" but only for Team A, not Team B

```typescript
// packages/database/src/schema/rbac-extensions.ts

/**
 * Optional: Constrain member roles to specific teams
 *
 * BetterAuth provides org-level roles; this extends with team-level scoping
 */
export const memberRoleScopes = pgTable(
  "member_role_scope",
  {
    id: text("id").primaryKey(),

    memberId: text("member_id")
      .notNull()
      .references(() => members.id, { onDelete: "cascade" }),

    roleName: text("role_name").notNull(), // One of the roles assigned to member

    scope: varchar("scope", { length: 16 }).notNull(), // "org" or "teams"

    createdAt: timestamp("created_at", { withTimezone: true })
      .defaultNow()
      .notNull(),
  },
  (t) => ({
    memberRoleUniq: uniqueIndex("member_role_scope_uq").on(
      t.memberId,
      t.roleName
    ),
  })
);

/**
 * If scope = "teams", enumerate which teams the role applies to
 */
export const memberRoleScopeTeams = pgTable(
  "member_role_scope_team",
  {
    id: text("id").primaryKey(),

    memberId: text("member_id").notNull(),
    roleName: text("role_name").notNull(),
    teamId: text("team_id")
      .notNull()
      .references(() => teams.id, { onDelete: "cascade" }),

    createdAt: timestamp("created_at", { withTimezone: true })
      .defaultNow()
      .notNull(),
  },
  (t) => ({
    memberRoleTeamUniq: uniqueIndex("member_role_team_uq").on(
      t.memberId,
      t.roleName,
      t.teamId
    ),
    teamIdx: index("member_role_team_idx").on(t.teamId),
  })
);
```

**Usage Pattern**:

1. User has `member` record with role `["venue_manager", "sales"]`
2. `memberRoleScopes` says `venue_manager` has scope `"teams"` (not org-wide)
3. `memberRoleScopeTeams` lists which teams that role applies to
4. Your code checks both org permission AND team scope before allowing action

---

## RBAC Patterns

### Access Control Configuration

Define permissions in `auth.ts` using BetterAuth's AC system:

```typescript
// packages/auth/src/config.ts
import { betterAuth } from "better-auth";
import { organization } from "better-auth/plugins";
import { createAccessControl } from "better-auth/plugins/access-control";

// Define resources and actions
const ac = createAccessControl({
  event: ["create", "read", "update", "delete", "publish"],
  ticket: ["create", "read", "transfer", "refund", "check_in"],
  venue: ["create", "read", "update", "delete"],
  analytics: ["read"],
  payout: ["read", "request"],
  team: ["create", "read", "update", "delete", "manage_members"],
});

// Define roles with permissions
ac.newRole("owner", {
  "*": ["*"], // Owner has all permissions
});

ac.newRole("admin", {
  event: ["create", "read", "update", "delete", "publish"],
  ticket: ["create", "read", "transfer", "refund", "check_in"],
  venue: ["create", "read", "update", "delete"],
  analytics: ["read"],
  payout: ["read", "request"],
  team: ["create", "read", "update", "delete", "manage_members"],
});

ac.newRole("manager", {
  event: ["create", "read", "update", "publish"],
  ticket: ["read", "check_in"],
  venue: ["read", "update"],
  analytics: ["read"],
});

ac.newRole("door_staff", {
  ticket: ["read", "check_in"],
  event: ["read"],
});

ac.newRole("growth_partner", {
  event: ["read"],
  analytics: ["read"], // Can see their referral stats
  payout: ["read"], // Can see their earnings
});

ac.newRole("affiliate", {
  event: ["read"],
  analytics: ["read"],
});

ac.newRole("organizer", {
  // For group trip orgs
  event: ["read"],
  team: ["read", "manage_members"], // Can invite to group
});

ac.newRole("member", {
  // Basic member (in any org type)
  event: ["read"],
});

export const auth = betterAuth({
  database: {
    // Drizzle adapter config
  },
  plugins: [
    organization({
      ac,
      dynamicAccessControl: {
        enabled: false, // Start false; enable later if you need runtime role creation
      },
      teams: {
        enabled: true, // Enable workspaces/teams
      },
      sendInvitationEmail: async (data) => {
        // Send invite email via your system (Inngest?)
        await inngest.send({
          name: "organization.invitation.sent",
          data,
        });
      },
    }),
  ],
  advanced: {
    crossSubDomainCookies: {
      enabled: true,
      domain: ".dayof.ai", // Share cookies across subdomains
    },
  },
  trustedOrigins: [
    "https://dayof.ai",
    "https://backstage.dayof.ai",
    "https://auth.dayof.ai",
  ],
  databaseHooks: {
    session: {
      create: {
        before: async (session) => {
          // Default to user's first org (or preferred org)
          const userOrgs = await db.query.members.findMany({
            where: eq(members.userId, session.userId),
            with: { organization: true },
          });

          if (userOrgs.length > 0) {
            // Prefer venue orgs over group orgs
            const venueOrg =
              userOrgs.find((m) => m.organization.metadata?.type === "venue") ||
              userOrgs[0];

            return {
              data: {
                ...session,
                activeOrganizationId: venueOrg.organizationId,
              },
            };
          }

          return {};
        },
      },
    },
  },
});
```

### Server-Side Permission Checks

**Org-Wide Permission** (Hono middleware):

```typescript
// packages/backstage/src/middleware/auth.ts
import { auth } from "@repo/auth";

export async function requireOrgPermission(permissions: {
  [resource: string]: string[];
}) {
  return async (c, next) => {
    const hasPermission = await auth.api.hasPermission({
      headers: c.req.raw.headers,
      body: { permissions },
    });

    if (!hasPermission) {
      return c.json({ error: "Forbidden" }, 403);
    }

    return next();
  };
}

// Usage in routes:
app.post("/events", requireOrgPermission({ event: ["create"] }), async (c) => {
  // User has permission to create events in active org
});
```

**Team-Scoped Permission** (with memberRoleScopes):

```typescript
// packages/backstage/src/middleware/auth.ts

export async function requireTeamScopedPermission(
  permissions: { [resource: string]: string[] },
  targetTeamId: string
) {
  return async (c, next) => {
    // 1. Check org-level permission first
    const hasOrgPermission = await auth.api.hasPermission({
      headers: c.req.raw.headers,
      body: { permissions },
    });

    if (!hasOrgPermission) {
      return c.json({ error: "Forbidden" }, 403);
    }

    // 2. Get active member
    const activeMember = await auth.api.getActiveMember({
      headers: c.req.raw.headers,
    });

    if (!activeMember) {
      return c.json({ error: "No active organization" }, 400);
    }

    // 3. Check if any roles are team-scoped
    const resourceName = Object.keys(permissions)[0]; // e.g., "event"
    const memberRoles = Array.isArray(activeMember.role)
      ? activeMember.role
      : [activeMember.role];

    for (const roleName of memberRoles) {
      const scope = await db.query.memberRoleScopes.findFirst({
        where: and(
          eq(memberRoleScopes.memberId, activeMember.id),
          eq(memberRoleScopes.roleName, roleName)
        ),
      });

      // If scope is "org", role applies everywhere - allow
      if (!scope || scope.scope === "org") {
        return next();
      }

      // If scope is "teams", check if this team is allowed
      if (scope.scope === "teams") {
        const allowedTeam = await db.query.memberRoleScopeTeams.findFirst({
          where: and(
            eq(memberRoleScopeTeams.memberId, activeMember.id),
            eq(memberRoleScopeTeams.roleName, roleName),
            eq(memberRoleScopeTeams.teamId, targetTeamId)
          ),
        });

        if (allowedTeam) {
          return next();
        }
      }
    }

    // No role with access to this team
    return c.json({ error: "Team access denied" }, 403);
  };
}

// Usage:
app.post(
  "/events/:teamId/publish",
  async (c, next) => {
    const teamId = c.req.param("teamId");
    return requireTeamScopedPermission({ event: ["publish"] }, teamId)(c, next);
  },
  async (c) => {
    // User has permission to publish events for this specific team
  }
);
```

### Client-Side Permission Checks (TanStack Start)

```typescript
// apps/backstage/src/hooks/usePermissions.ts
import { authClient } from "@repo/auth/client";

export function usePermissions() {
  const { data: activeMember } = authClient.organization.useActiveMember();

  const can = (resource: string, action: string) => {
    if (!activeMember) return false;

    // Quick client-side check (not authoritative)
    return authClient.organization.checkRolePermission({
      permissions: { [resource]: [action] },
      role: activeMember.role,
    });
  };

  return { can };
}

// Usage in component:
export function EventActions({ event }) {
  const { can } = usePermissions();

  return (
    <div>
      {can("event", "publish") && (
        <Button onClick={() => publishEvent(event.id)}>Publish Event</Button>
      )}
      {can("event", "delete") && (
        <Button onClick={() => deleteEvent(event.id)}>Delete Event</Button>
      )}
    </div>
  );
}
```

---

## Session & Context Switching

### Default Active Organization

Set a default active org when user logs in (from `auth.ts` config above):

```typescript
databaseHooks: {
  session: {
    create: {
      before: async (session) => {
        // Get user's organizations
        const userOrgs = await db.query.members.findMany({
          where: eq(members.userId, session.userId),
          with: { organization: true },
        });

        if (userOrgs.length > 0) {
          // Prefer venue orgs, then growth partner orgs, then group orgs
          const preferredOrg =
            userOrgs.find(m => m.organization.metadata?.type === "venue") ||
            userOrgs.find(m => m.organization.metadata?.type === "growth_partner") ||
            userOrgs[0];

          return {
            data: {
              ...session,
              activeOrganizationId: preferredOrg.organizationId,
            },
          };
        }

        return {};
      },
    },
  },
}
```

### Switching Organizations (Web)

```typescript
// apps/backstage/src/components/OrgSwitcher.tsx
import { authClient } from "@repo/auth/client";

export function OrgSwitcher() {
  const { data: orgs } = authClient.organization.useUserOrganizations();
  const { data: activeOrg } = authClient.organization.useActiveOrganization();

  const switchOrg = async (orgId: string) => {
    await authClient.organization.setActive({
      organizationId: orgId,
    });

    // Refresh page or trigger data reload
    window.location.reload();
  };

  return (
    <Select value={activeOrg?.id} onValueChange={switchOrg}>
      {orgs?.map((org) => (
        <SelectItem key={org.id} value={org.id}>
          {org.name}
        </SelectItem>
      ))}
    </Select>
  );
}
```

### Switching Teams (Web)

```typescript
// apps/backstage/src/components/TeamSwitcher.tsx
import { authClient } from "@repo/auth/client";

export function TeamSwitcher() {
  const { data: teams } = authClient.organization.useTeams();
  const { data: session } = authClient.useSession();

  const switchTeam = async (teamId: string | null) => {
    await authClient.organization.setActiveTeam({
      teamId, // null to clear team context
    });

    window.location.reload();
  };

  return (
    <Select
      value={session?.activeTeamId || "all"}
      onValueChange={(val) => switchTeam(val === "all" ? null : val)}
    >
      <SelectItem value="all">All Teams</SelectItem>
      {teams?.map((team) => (
        <SelectItem key={team.id} value={team.id}>
          {team.name}
        </SelectItem>
      ))}
    </Select>
  );
}
```

### Hono Middleware (Server-Side Session Access)

```typescript
// apps/backstage/src/middleware/session.ts
import { auth } from "@repo/auth";

export async function requireAuth() {
  return async (c, next) => {
    const session = await auth.api.getSession({
      headers: c.req.raw.headers,
    });

    if (!session) {
      return c.json({ error: "Unauthorized" }, 401);
    }

    c.set("user", session.user);
    c.set("session", session.session);

    return next();
  };
}

// Usage:
app.use("*", requireAuth());

app.get("/me", async (c) => {
  const user = c.get("user");
  const session = c.get("session");

  return c.json({
    user,
    activeOrganizationId: session.activeOrganizationId,
    activeTeamId: session.activeTeamId,
  });
});
```

---

## Scenario Mappings

### Scenario 1: Venue Owner + External Attendee

**User Profile**: Jon owns "Miami Beach Nightclub Group" and wants to attend a concert at "Madison Square Garden"

**Implementation**:

```typescript
// Jon's memberships:
// - member(userId: jon, orgId: miami_nightclub, role: ["owner"])
// - NO member record for Madison Square Garden

// When Jon buys ticket to MSG concert:
const order = await createOrder({
  userId: "jon",
  eventId: "msg_concert_123",
  purchaserOrganizationId: null, // Not buying as org
});

// Ticket created:
const ticket = await createTicket({
  orderId: order.id,
  holderUserId: "jon",
  hostOrganizationId: "msg_venue_org", // MSG's org
  hostTeamId: null,
});

// Jon can access ticket without being member of MSG's org
```

**Key Point**: `holderUserId` on ticket is all that's needed; no membership check

### Scenario 2: Multi-Venue Organization with Shared Affiliates

**User Profile**: "Las Vegas Entertainment Group" has 3 venues; affiliate Sarah promotes all of them

**Implementation**:

```typescript
// Organization:
const org = await createOrganization({
  name: "Las Vegas Entertainment Group",
  metadata: { type: "venue" },
});

// Teams (one per venue):
const venue1Team = await createTeam({
  organizationId: org.id,
  name: "Club Luxe",
});
const venue2Team = await createTeam({
  organizationId: org.id,
  name: "Rooftop Bar",
});
const venue3Team = await createTeam({
  organizationId: org.id,
  name: "Concert Hall",
});

// Sarah is member with org-wide affiliate role:
await addMember({
  organizationId: org.id,
  userId: "sarah",
  role: ["affiliate"],
});

// Sarah is NOT added to specific teams - her role is org-wide
// She can promote events from any team

// Affiliate link:
await createAffiliateLink({
  code: "SARAH_VIP",
  organizationId: org.id,
  teamId: null, // Org-wide (works for all venues)
  affiliateUserId: "sarah",
  commissionRate: 0.15, // 15% of app fee
});
```

**RBAC Check**: When Sarah accesses analytics, check `member.role` includes `"affiliate"` and `memberRoleScopes` is either absent or has scope `"org"`

### Scenario 3: Affiliate in Multiple Organizations, Limited Teams

**User Profile**: Mike is affiliate for "Miami Beach Nightclub Group" (only Club Oasis) and "Fort Lauderdale Events" (all venues)

**Implementation**:

```typescript
// Organization 1: Miami Beach Nightclub Group
const miamiOrg = { id: "miami_org" };
const clubOasisTeam = { id: "club_oasis_team" };

// Add Mike as member with team-scoped affiliate role:
await addMember({
  organizationId: miamiOrg.id,
  userId: "mike",
  role: ["affiliate"],
});

// Constrain affiliate role to specific team:
await createMemberRoleScope({
  memberId: "mike_miami_member_id",
  roleName: "affiliate",
  scope: "teams",
});

await createMemberRoleScopeTeam({
  memberId: "mike_miami_member_id",
  roleName: "affiliate",
  teamId: clubOasisTeam.id,
});

// Organization 2: Fort Lauderdale Events
const ftlOrg = { id: "ftl_org" };

await addMember({
  organizationId: ftlOrg.id,
  userId: "mike",
  role: ["affiliate"],
});

// No role scope entry = org-wide access
```

**RBAC Check**: When Mike tries to view analytics for a team, check:

1. Does Mike have `affiliate` role in org? (Yes)
2. Does `memberRoleScopes` exist for this role? (Yes for Miami, No for FTL)
3. If scope is `"teams"`, is this team in `memberRoleScopeTeams`? (Check)

### Scenario 4: Group Trip Organization

**User Profile**: Fraternity "Alpha Beta" creates org for Spring Break 2026; 32 members, 2 organizers

**Implementation**:

```typescript
// Create group organization:
const groupOrg = await createOrganization({
  name: "Alpha Beta Spring Break 2026",
  slug: "alpha-beta-sb26",
  metadata: {
    type: "group",
    tripDates: ["2026-03-10", "2026-03-17"],
    maxMembers: 50,
  },
});

// Invite organizers:
await inviteToOrganization({
  organizationId: groupOrg.id,
  email: "john@example.com",
  role: "organizer",
});

await inviteToOrganization({
  organizationId: groupOrg.id,
  email: "mike@example.com",
  role: "organizer",
});

// Invite regular members (30 more):
for (const email of memberEmails) {
  await inviteToOrganization({
    organizationId: groupOrg.id,
    email,
    role: "member",
  });
}

// When buying tickets for the group:
const order = await createOrder({
  userId: "john", // Organizer buying
  purchaserOrganizationId: groupOrg.id, // Links purchase to group
});

// Each ticket still has individual holder:
for (const attendee of attendees) {
  await createTicket({
    orderId: order.id,
    holderUserId: attendee.userId,
    hostOrganizationId: "venue_org_id", // Host venue
    purchaserOrganizationId: groupOrg.id, // Group context
  });
}
```

**UI Differentiation**:

- Organizers see: Group management, invite members, itinerary, room assignments
- Regular members see: Their tickets, group chat, schedule

### Scenario 5: Multi-Role Member

**User Profile**: Lisa is both "manager" and "door_staff" at a venue

**Implementation**:

```typescript
// Add Lisa with multiple roles:
await addMember({
  organizationId: venueOrg.id,
  userId: "lisa",
  role: ["manager", "door_staff"],
});

// Permission check evaluates union of both roles:
const canCheckIn = await auth.api.hasPermission({
  headers,
  body: {
    permissions: { ticket: ["check_in"] },
  },
});
// Returns true (door_staff has this permission)

const canCreateEvent = await auth.api.hasPermission({
  headers,
  body: {
    permissions: { event: ["create"] },
  },
});
// Returns true (manager has this permission)
```

---

## Implementation Checklist

### Phase 1: BetterAuth Setup

- [ ] Install BetterAuth: `npm install better-auth`
- [ ] Run CLI to generate schema: `npx @better-auth/cli generate`
- [ ] Merge BetterAuth schema with Drizzle schema
- [ ] Run migrations: `drizzle-kit push` or `drizzle-kit migrate`
- [ ] Configure `auth.ts` with organization plugin + teams + AC
- [ ] Enable cross-subdomain cookies for `*.dayof.ai`
- [ ] Set trusted origins for CORS
- [ ] Add database hook for default active org

### Phase 2: RBAC Configuration

- [ ] Define resources and actions in AC config
- [ ] Define roles with permissions (owner, admin, manager, door_staff, growth_partner, affiliate, organizer, member)
- [ ] Test permission checks with sample users
- [ ] Document role hierarchy

### Phase 3: DayOf Schema Extensions

- [ ] Create `organizationMetadata` table
- [ ] Create `venues` table
- [ ] Create `events` table
- [ ] Create `orders` table
- [ ] Create `tickets` table
- [ ] Create `affiliateLinks` table
- [ ] (Optional) Create `memberRoleScopes` and `memberRoleScopeTeams` tables
- [ ] Add indexes for performance

### Phase 4: Middleware & Guards

- [ ] Create `requireAuth` middleware (Hono)
- [ ] Create `requireOrgPermission` middleware
- [ ] Create `requireTeamScopedPermission` middleware (if using team-scoped roles)
- [ ] Add session hydration to Hono app
- [ ] Test middleware with various user types

### Phase 5: Client Integration (Web)

- [ ] Install BetterAuth client: `npm install @better-auth/client`
- [ ] Create auth client instance
- [ ] Build OrgSwitcher component
- [ ] Build TeamSwitcher component
- [ ] Create `usePermissions` hook
- [ ] Test context switching
- [ ] Implement invite acceptance flow

### Phase 6: Mobile (Expo)

- [ ] Install BetterAuth Expo client
- [ ] Configure secure storage for session
- [ ] Implement deep link handling for invites
- [ ] Test session persistence across app restarts
- [ ] Implement org/team context in mobile UI

### Phase 7: Testing

- [ ] Unit tests for permission checks
- [ ] Integration tests for org switching
- [ ] E2E tests for invite flows
- [ ] Load test org/team queries
- [ ] Security audit of RBAC implementation

---

## Mobile Considerations (Expo)

### Setup

```typescript
// apps/crew/src/lib/auth.ts
import { createAuthClient } from "@better-auth/expo";
import * as SecureStore from "expo-secure-store";

export const authClient = createAuthClient({
  baseURL: "https://auth.dayof.ai",

  // Persist session in secure storage
  storage: {
    getItem: async (key) => {
      return await SecureStore.getItemAsync(key);
    },
    setItem: async (key, value) => {
      await SecureStore.setItemAsync(key, value);
    },
    removeItem: async (key) => {
      await SecureStore.deleteItemAsync(key);
    },
  },
});
```

### Session Rehydration

```typescript
// apps/crew/App.tsx
import { useEffect } from "react";
import { authClient } from "./lib/auth";

export function App() {
  const [isReady, setIsReady] = useState(false);

  useEffect(() => {
    // Rehydrate session on app start
    authClient.session
      .get()
      .then(() => setIsReady(true))
      .catch(() => setIsReady(true));
  }, []);

  if (!isReady) {
    return <LoadingScreen />;
  }

  return <MainApp />;
}
```

### Active Org Context in Mobile

```typescript
// apps/crew/src/contexts/OrgContext.tsx
import { createContext, useContext, useState, useEffect } from "react";
import { authClient } from "../lib/auth";

const OrgContext = createContext(null);

export function OrgProvider({ children }) {
  const [activeOrg, setActiveOrg] = useState(null);

  useEffect(() => {
    authClient.organization
      .getActiveOrganization()
      .then((org) => setActiveOrg(org));
  }, []);

  const switchOrg = async (orgId: string) => {
    await authClient.organization.setActive({ organizationId: orgId });
    const org = await authClient.organization.getActiveOrganization();
    setActiveOrg(org);
  };

  return (
    <OrgContext.Provider value={{ activeOrg, switchOrg }}>
      {children}
    </OrgContext.Provider>
  );
}

export const useActiveOrg = () => useContext(OrgContext);
```

### Deep Link Handling (Invites)

```typescript
// apps/crew/src/navigation/LinkingConfiguration.ts
import * as Linking from "expo-linking";

const config = {
  screens: {
    AcceptInvite: "invite/:inviteId",
  },
};

// apps/crew/src/screens/AcceptInvite.tsx
export function AcceptInviteScreen({ route }) {
  const { inviteId } = route.params;

  const acceptInvite = async () => {
    try {
      await authClient.organization.acceptInvitation({
        invitationId: inviteId,
      });

      // Navigate to new org
      navigation.navigate("Home");
    } catch (error) {
      Alert.alert("Error", "Failed to accept invitation");
    }
  };

  return (
    <View>
      <Text>You've been invited to join an organization</Text>
      <Button onPress={acceptInvite}>Accept</Button>
    </View>
  );
}
```

### Offline Considerations

**Critical**: Crew app uses PowerSync for offline-first scanning

```typescript
// apps/crew/src/lib/powersync.ts

// Sync only data for active organization
export function configurePowerSync() {
  const { activeOrg } = useActiveOrg();

  return new PowerSyncDatabase({
    schema: appSchema,
    database: {
      dbFilename: "crew.db",
    },
    sync: {
      params: {
        organizationId: activeOrg?.id, // Scope sync to active org
      },
    },
  });
}
```

---

## Security & Best Practices

### 1. Never Trust Client-Side Permission Checks

**❌ Bad**:

```typescript
// Client decides if user can delete event
if (user.role === "admin") {
  await deleteEvent(eventId);
}
```

**✅ Good**:

```typescript
// Server enforces permission
app.delete(
  "/events/:id",
  requireOrgPermission({ event: ["delete"] }),
  async (c) => {
    // Server-side check passed, safe to proceed
  }
);
```

### 2. Always Validate Organization Context

**❌ Bad**:

```typescript
// Trust activeOrganizationId from client
const events = await db.query.events.findMany({
  where: eq(events.organizationId, req.body.organizationId),
});
```

**✅ Good**:

```typescript
// Get active org from server-side session
const session = await auth.api.getSession({ headers });
const events = await db.query.events.findMany({
  where: eq(events.organizationId, session.session.activeOrganizationId),
});
```

### 3. Scope API Endpoints by Organization

**Pattern**: Include org context in all queries

```typescript
// apps/backstage/src/routes/events.ts

app.get("/events", requireAuth(), async (c) => {
  const session = c.get("session");

  // Always filter by active organization
  const events = await db.query.events.findMany({
    where: eq(events.organizationId, session.activeOrganizationId),
  });

  return c.json({ events });
});
```

### 4. Use Transactions for Multi-Table Operations

```typescript
// When creating event with team scope:
await db.transaction(async (tx) => {
  const event = await tx
    .insert(events)
    .values({
      organizationId: activeOrg.id,
      teamId: activeTeam?.id,
      name: "New Event",
    })
    .returning();

  // Create initial ticket types
  await tx.insert(ticketTypes).values({
    eventId: event.id,
    name: "General Admission",
    priceCents: 5000,
  });
});
```

### 5. Rate Limit Sensitive Operations

```typescript
// Prevent invitation spam
app.post(
  "/invitations",
  requireAuth(),
  requireOrgPermission({ team: ["manage_members"] }),
  rateLimit({ windowMs: 60000, max: 10 }), // 10 invites per minute
  async (c) => {
    // Send invitation
  }
);
```

### 6. Audit Critical Actions

```typescript
// Use Inngest to log all org changes
import { inngest } from "@repo/inngest";

export async function auditOrgAction(action: string, data: any) {
  await inngest.send({
    name: "organization.action.logged",
    data: {
      action,
      ...data,
      timestamp: new Date(),
    },
  });
}

// Usage:
app.post("/members", requireOrgPermission({ team: ["manage_members"] }), async (c) => {
  const newMember = await addMember(...);

  await auditOrgAction("member.added", {
    organizationId: activeOrg.id,
    addedBy: session.userId,
    newMemberId: newMember.id,
    role: newMember.role,
  });

  return c.json({ member: newMember });
});
```

### 7. Handle Deleted Organizations Gracefully

```typescript
// Check if org still exists before operations
app.use("/org/:orgId/*", async (c, next) => {
  const orgId = c.req.param("orgId");

  const org = await db.query.organizations.findFirst({
    where: eq(organizations.id, orgId),
  });

  if (!org) {
    return c.json({ error: "Organization not found" }, 404);
  }

  return next();
});
```

### 8. Separate Platform Admin from Org Admin

**Platform admins** (DayOf employees) should NOT use org RBAC:

```typescript
// packages/database/src/schema/platform.ts

export const platformAdmins = pgTable("platform_admin", {
  userId: text("user_id")
    .primaryKey()
    .references(() => users.id, { onDelete: "cascade" }),
  role: varchar("role", { length: 32 }).notNull(), // "support", "engineer", "superadmin"
  createdAt: timestamp("created_at", { withTimezone: true }).defaultNow(),
});

// Middleware:
export async function requirePlatformAdmin() {
  return async (c, next) => {
    const session = await auth.api.getSession({ headers: c.req.raw.headers });

    const isAdmin = await db.query.platformAdmins.findFirst({
      where: eq(platformAdmins.userId, session.user.id),
    });

    if (!isAdmin) {
      return c.json({ error: "Platform admin access required" }, 403);
    }

    return next();
  };
}
```

---

## Summary

### What BetterAuth Provides

✅ Many-to-many user ↔ organization relationships  
✅ Teams/workspaces within organizations  
✅ Active context tracking (org + team)  
✅ Multi-role support per membership  
✅ Invitation system with team scoping  
✅ RBAC via Access Control system  
✅ Cross-subdomain cookie support

### What You Need to Build

🔧 Organization type metadata (venue, growth_partner, group, sponsor)  
🔧 Application tables (venues, events, orders, tickets)  
🔧 Team-scoped role constraints (optional `memberRoleScopes` tables)  
🔧 Permission middleware for Hono routes  
🔧 Client-side org/team switchers  
🔧 Mobile session persistence  
🔧 Affiliate tracking and payout logic  
🔧 Group purchase coordination

### Key Patterns

**Attendees don't need membership**: Tickets link to `holderUserId`, not org membership  
**Multi-context users**: Same user can be owner, affiliate, and attendee across different orgs  
**Team scoping**: Optional granular control via custom `memberRoleScopes` tables  
**Context switching**: Use `setActive` and `setActiveTeam` APIs, never manually manipulate cookies  
**Permission checks**: Always enforce server-side via `hasPermission` API

### Next Steps

1. ✅ Generate BetterAuth schema and merge with Drizzle
2. ✅ Configure auth.ts with org plugin, teams, AC, and cookie settings
3. ✅ Create DayOf application tables (organizationMetadata, venues, events, etc.)
4. ✅ Build middleware for permission checks
5. ✅ Implement org/team switchers in web apps
6. ✅ Set up mobile auth with Expo
7. ✅ Test all scenarios (venue owner, affiliate, group trip, etc.)

---

**This architecture enables DayOf's unique multi-tenant model**: venue operators manage events, growth partners earn commissions, attendees buy tickets freely, and group organizers coordinate trips - all with one unified authentication system and flexible RBAC.

> Last updated: Based on BetterAuth v1.2+ documentation and DayOf tech stack
