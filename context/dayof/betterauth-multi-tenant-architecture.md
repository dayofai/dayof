# DayOf Multi-Tenant Architecture with BetterAuth

**Purpose**: Complete implementation guide for BetterAuth multi-tenant authorization in DayOf's event management and ticketing platform

**Stack Context**:

- Auth: BetterAuth (Hono) at `auth.dayof.ai`
- Apps: TanStack Start (SSR + SPA), Expo (iOS)
- Database: Neon Postgres + Drizzle ORM
- Orchestration: Inngest
- Hosting: Vercel (Node 22, Fluid Compute)

---

## Table of Contents

1. [Architecture Overview](#architecture-overview)
2. [BetterAuth Organization Model](#betterauth-organization-model)
3. [DayOf Organization Types](#dayof-organization-types)
4. [Schema Design](#schema-design)
5. [RBAC Patterns](#rbac-patterns)
6. [Session & Context Switching](#session--context-switching)
7. [Scenario Mappings](#scenario-mappings)
8. [Implementation Checklist](#implementation-checklist)
9. [Mobile Considerations (Expo)](#mobile-considerations-expo)
10. [Security & Best Practices](#security--best-practices)

---

## Architecture Overview

### Core Principle: Unified Portal, Multiple Contexts

**Design Philosophy**: One login for all roles/organizations

- Users never log out to switch contexts
- Same authentication system serves B2B (venue operators) and B2C (ticket purchasers)
- Organization membership is **optional** - attendees don't need to be members to buy tickets

### BetterAuth Foundation

BetterAuth provides:

- **Many-to-many** user â†” organization relationships
- **Teams** (workspaces) within organizations
- **Active context** tracking in sessions (activeOrganizationId, activeTeamId)
- **Multi-role** support per membership (as of v1.2+)
- **Invitation system** with team scoping
- **RBAC** via Access Control (AC) system

### DayOf's Twist

**Ticket/Event Decoupling**: Unlike traditional platforms, tickets are tokens independent of events

- Tickets can be associated with individual events OR event groups
- Same user can be:
  - Venue owner in Org A
  - Affiliate promoter for Org B
  - Attendee at events from Org C (no membership)
  - Organizer of a group trip Org D

**This requires**: Flexible RBAC + clear separation between "membership roles" and "customer actions"

---

## BetterAuth Organization Model

### Core Tables (Generated by BetterAuth CLI)

BetterAuth creates these tables via `npx @better-auth/cli generate`:

```typescript
// âœ… Generated by BetterAuth - DO NOT manually define

// Core user table
user {
  id: string (UUID)
  name: string
  email: string (unique)
  emailVerified: boolean
  image?: string
  createdAt: timestamp
  updatedAt: timestamp
}

// Organization (tenant) table
organization {
  id: string (UUID)
  name: string
  slug: string (unique, URL-safe)
  logo?: string
  metadata?: json
  createdAt: timestamp
}

// Membership linking users to organizations
member {
  id: string (UUID)
  userId: string â†’ user.id (cascade delete)
  organizationId: string â†’ organization.id (cascade delete)
  role: string | string[] // Multi-role support (v1.2+)
  createdAt: timestamp
}

// Teams/workspaces within organizations (optional)
team {
  id: string (UUID)
  organizationId: string â†’ organization.id (cascade delete)
  name: string
  createdAt: timestamp
  updatedAt: timestamp
}

// Team membership
teamMember {
  id: string (UUID)
  teamId: string â†’ team.id (cascade delete)
  userId: string â†’ user.id (cascade delete)
  createdAt: timestamp
}

// Invitations (with optional team scoping)
invitation {
  id: string (UUID)
  organizationId: string â†’ organization.id
  email: string
  role: string
  teamId?: string â†’ team.id (optional)
  status: "pending" | "accepted" | "rejected"
  expiresAt: timestamp
  invitedBy: string â†’ user.id
  createdAt: timestamp
}

// Session (extended with active context)
session {
  id: string (UUID)
  userId: string â†’ user.id (cascade delete)
  token: string (unique)
  expiresAt: timestamp
  ipAddress?: string
  userAgent?: string
  activeOrganizationId?: string â†’ organization.id
  activeTeamId?: string â†’ team.id
}
```

### Key Behaviors

**Multi-Organization Membership**:

- User can have multiple `member` records (one per org)
- Example: User A is `owner` in Org X, `affiliate` in Org Y, `volunteer` in Org Z

**Multi-Role Per Membership**:

- As of v1.2, `member.role` supports arrays: `["admin", "sales"]`
- Permission checks evaluate union of all roles
- API: `updateMemberRole({ role: string | string[] })`

**Active Context**:

- Session tracks current org (`activeOrganizationId`) and team (`activeTeamId`)
- Switch via: `authClient.organization.setActive({ organizationId })`
- Retrieve via: `authClient.organization.getActiveMember()`

**Team Scoping**:

- Teams are optional workspaces within an org
- Invitations can target a specific team: `invite({ teamId, role })`
- Team membership tracked in `teamMember` table

---

## DayOf Organization Types

### 1. Venue/Tenant Organizations

**Purpose**: Event hosting businesses (nightclubs, concert halls, festivals)

**Characteristics**:

- Creates and manages events
- Has staff with various roles (owner, manager, door staff, etc.)
- May have multiple physical locations (teams/workspaces)
- Receives payouts from ticket sales

**BetterAuth Mapping**:

- Organization represents the business entity
- Teams represent physical venues/locations (optional)
- Members are staff with operational roles

**Example**:

```text
Organization: "Miami Beach Nightclub Group"
â”œâ”€â”€ Team: "Club Oasis" (South Beach location)
â”œâ”€â”€ Team: "Venue Apex" (Downtown location)
â””â”€â”€ Members:
    â”œâ”€â”€ User A: ["owner"] (org-wide)
    â”œâ”€â”€ User B: ["manager"] (Team: Club Oasis only)
    â””â”€â”€ User C: ["door_staff"] (Team: Venue Apex only)
```

### 2. Growth Partner / Affiliate Organizations

**Purpose**: Promoters and marketing partners who drive ticket sales

**Characteristics**:

- Earn commission on referred sales (5-30% of application fee)
- May work with multiple venue organizations
- May have teams under them (sub-affiliates)
- Track referrals and earnings

**BetterAuth Mapping**:

- Growth partner is a `member` in the venue's organization with role `growth_partner`
- Or: Growth partner has their own organization and is cross-linked to venues
- Use teams to scope which events they can promote

**Example**:

```text
Organization: "Spring Break Promotions LLC"
â”œâ”€â”€ Owner: User X (growth partner)
â””â”€â”€ Cross-Org Memberships:
    â”œâ”€â”€ Member in "Miami Beach Nightclub Group" with role ["growth_partner"]
    â””â”€â”€ Member in "Fort Lauderdale Events Co" with role ["affiliate"]
```

### 3. Sponsor Organizations

**Purpose**: Brands sponsoring events

**Characteristics**:

- May have access to event analytics
- May have branded experiences at events
- Don't manage events directly

**BetterAuth Mapping**:

- Organization represents sponsor
- Member in venue org with role `sponsor` (limited permissions)

### 4. Group Trip Organizations (Attendee Groups)

**Purpose**: Temporary organizations for coordinated group attendance

**Characteristics**:

- Fraternity trips, tour groups, corporate outings
- 10-100+ members
- Internal roles (organizer, member)
- Shared billing/coordination
- Members still act as individual ticket holders

**BetterAuth Mapping**:

- Organization flagged as "group" type (in metadata)
- Organizer gets custom role with management permissions
- Regular members have minimal permissions
- Purchases can link to group via `orders.purchaserOrganizationId`

**Example**:

```text
Organization: "Alpha Beta Spring Break 2026" (metadata: { type: "group" })
â”œâ”€â”€ Members:
â”‚   â”œâ”€â”€ User A: ["organizer"] (can invite, manage itinerary)
â”‚   â”œâ”€â”€ User B: ["organizer"] (co-leader)
â”‚   â””â”€â”€ Users C-Z: ["member"] (basic access)
â””â”€â”€ Shared Resources:
    â”œâ”€â”€ Group chat/coordination
    â”œâ”€â”€ Room assignments
    â””â”€â”€ Bulk ticket purchases
```

---

## Schema Design

### BetterAuth Base + DayOf Extensions

**Strategy**: Let BetterAuth own auth tables, extend with application-specific tables

### Step 1: Generate BetterAuth Schema

```bash
# Run in packages/database
npx @better-auth/cli generate

# This creates auth tables: user, organization, member, team, teamMember, etc.
# Merge into your Drizzle schema
```

### Step 2: DayOf Application Tables

```typescript
// packages/database/src/schema/organizations.ts
import {
  pgTable,
  text,
  varchar,
  timestamp,
  jsonb,
  boolean,
  index,
} from "drizzle-orm/pg-core";

/**
 * Organization metadata extension
 * Stores DayOf-specific org type and config
 */
export const organizationMetadata = pgTable(
  "organization_metadata",
  {
    organizationId: text("organization_id")
      .primaryKey()
      .references(() => organizations.id, { onDelete: "cascade" }),

    type: varchar("type", { length: 32 }).notNull(), // "venue", "growth_partner", "sponsor", "group"

    // Venue-specific
    venueConfig: jsonb("venue_config"), // { payoutCadence, stripeAccountId, etc. }

    // Growth partner-specific
    affiliateConfig: jsonb("affiliate_config"), // { commissionRate, payoutThreshold, etc. }

    // Group-specific
    groupConfig: jsonb("group_config"), // { tripDates, maxMembers, etc. }

    createdAt: timestamp("created_at", { withTimezone: true })
      .defaultNow()
      .notNull(),
    updatedAt: timestamp("updated_at", { withTimezone: true })
      .defaultNow()
      .notNull(),
  },
  (t) => ({
    typeIdx: index("org_metadata_type_idx").on(t.type),
  })
);

/**
 * Venues (physical locations)
 * Links to organization, optionally scoped to team
 */
export const venues = pgTable(
  "venue",
  {
    id: text("id").primaryKey(),
    organizationId: text("organization_id")
      .notNull()
      .references(() => organizations.id, { onDelete: "cascade" }),
    teamId: text("team_id") // Optional: venue belongs to specific workspace
      .references(() => teams.id, { onDelete: "set null" }),

    name: text("name").notNull(),
    slug: varchar("slug", { length: 128 }).notNull(),
    address: text("address"),
    city: varchar("city", { length: 100 }),
    state: varchar("state", { length: 2 }),
    zip: varchar("zip", { length: 10 }),

    capacity: integer("capacity"),
    metadata: jsonb("metadata"),

    createdAt: timestamp("created_at", { withTimezone: true })
      .defaultNow()
      .notNull(),
  },
  (t) => ({
    orgIdx: index("venue_org_idx").on(t.organizationId),
    teamIdx: index("venue_team_idx").on(t.teamId),
    slugIdx: index("venue_slug_idx").on(t.slug),
  })
);

/**
 * Events (hosted by organizations)
 * Optionally scoped to team/workspace
 */
export const events = pgTable(
  "event",
  {
    id: text("id").primaryKey(),

    // Host organization and optional workspace
    organizationId: text("organization_id")
      .notNull()
      .references(() => organizations.id, { onDelete: "cascade" }),
    teamId: text("team_id") // Optional: event belongs to specific workspace
      .references(() => teams.id, { onDelete: "set null" }),

    venueId: text("venue_id").references(() => venues.id, {
      onDelete: "set null",
    }),

    slug: varchar("slug", { length: 128 }).notNull(),
    name: text("name").notNull(),
    description: text("description"),

    startsAt: timestamp("starts_at", { withTimezone: true }).notNull(),
    endsAt: timestamp("ends_at", { withTimezone: true }).notNull(),

    published: boolean("published").notNull().default(false),
    featured: boolean("featured").notNull().default(false),

    metadata: jsonb("metadata"),

    createdAt: timestamp("created_at", { withTimezone: true })
      .defaultNow()
      .notNull(),
    updatedAt: timestamp("updated_at", { withTimezone: true })
      .defaultNow()
      .notNull(),
  },
  (t) => ({
    orgSlugUniq: uniqueIndex("event_org_slug_uq").on(t.organizationId, t.slug),
    orgIdx: index("event_org_idx").on(t.organizationId),
    teamIdx: index("event_team_idx").on(t.teamId),
    publishedIdx: index("event_published_idx").on(t.published),
  })
);

/**
 * Orders (ticket purchases)
 * Buyer does NOT need to be member of event's organization
 */
export const orders = pgTable(
  "order",
  {
    id: text("id").primaryKey(),

    // Buyer (always required, but not necessarily an org member)
    userId: text("user_id")
      .notNull()
      .references(() => users.id, { onDelete: "restrict" }),

    // Optional: purchased under group context (e.g., fraternity trip)
    purchaserOrganizationId: text("purchaser_org_id").references(
      () => organizations.id,
      { onDelete: "set null" }
    ),

    status: varchar("status", { length: 32 }).notNull(), // "pending", "paid", "refunded"

    totalCents: integer("total_cents").notNull(),
    currency: varchar("currency", { length: 3 }).notNull().default("USD"),

    // Affiliate/growth partner attribution
    affiliateCode: varchar("affiliate_code", { length: 64 }),

    metadata: jsonb("metadata"),

    createdAt: timestamp("created_at", { withTimezone: true })
      .defaultNow()
      .notNull(),
    updatedAt: timestamp("updated_at", { withTimezone: true })
      .defaultNow()
      .notNull(),
  },
  (t) => ({
    userIdx: index("order_user_idx").on(t.userId),
    purchOrgIdx: index("order_purch_org_idx").on(t.purchaserOrganizationId),
    affiliateIdx: index("order_affiliate_idx").on(t.affiliateCode),
  })
);

/**
 * Tickets (individual entitlements)
 * Holder is always a user, not necessarily an org member
 */
export const tickets = pgTable(
  "ticket",
  {
    id: text("id").primaryKey(),
    nanoId: varchar("nano_id", { length: 16 }).notNull().unique(), // For scanning

    orderId: text("order_id")
      .notNull()
      .references(() => orders.id, { onDelete: "restrict" }),
    ticketTypeId: text("ticket_type_id")
      .notNull()
      .references(() => ticketTypes.id, { onDelete: "restrict" }),

    // Current holder (can transfer)
    holderUserId: text("holder_user_id")
      .notNull()
      .references(() => users.id, { onDelete: "restrict" }),

    // Immutable: host org and team at time of issuance
    hostOrganizationId: text("host_org_id")
      .notNull()
      .references(() => organizations.id, { onDelete: "restrict" }),
    hostTeamId: text("host_team_id").references(() => teams.id, {
      onDelete: "set null",
    }),

    status: varchar("status", { length: 24 }).notNull(), // "issued", "checked_in", "refunded", "transferred"

    // Physical card linking (optional)
    physicalCardId: varchar("physical_card_id", { length: 16 }),

    metadata: jsonb("metadata"),

    createdAt: timestamp("created_at", { withTimezone: true })
      .defaultNow()
      .notNull(),
    updatedAt: timestamp("updated_at", { withTimezone: true })
      .defaultNow()
      .notNull(),
  },
  (t) => ({
    orderIdx: index("ticket_order_idx").on(t.orderId),
    holderIdx: index("ticket_holder_idx").on(t.holderUserId),
    hostOrgIdx: index("ticket_host_org_idx").on(t.hostOrganizationId),
    nanoIdIdx: index("ticket_nano_id_idx").on(t.nanoId),
  })
);

/**
 * Affiliate/Growth Partner Links
 * Tracks referral codes and their relationships
 */
export const affiliateLinks = pgTable(
  "affiliate_link",
  {
    id: text("id").primaryKey(),
    code: varchar("code", { length: 64 }).notNull(),

    // Host organization (who this code refers to)
    organizationId: text("organization_id")
      .notNull()
      .references(() => organizations.id, { onDelete: "cascade" }),

    // Optional: scoped to specific team/workspace
    teamId: text("team_id").references(() => teams.id, { onDelete: "cascade" }),

    // Affiliate/growth partner user
    affiliateUserId: text("affiliate_user_id")
      .notNull()
      .references(() => users.id, { onDelete: "cascade" }),

    // Commission config (overrides default)
    commissionRate: decimal("commission_rate", { precision: 5, scale: 4 }), // e.g., 0.0500 = 5%

    active: boolean("active").notNull().default(true),

    metadata: jsonb("metadata"),

    createdAt: timestamp("created_at", { withTimezone: true })
      .defaultNow()
      .notNull(),
  },
  (t) => ({
    codeOrgUniq: uniqueIndex("aff_code_org_uq").on(t.organizationId, t.code),
    affiliateIdx: index("aff_user_idx").on(t.affiliateUserId),
    teamIdx: index("aff_team_idx").on(t.teamId),
  })
);
```

### Step 3: Team-Scoped Role Management (Optional)

**Use Case**: Limit specific roles to specific teams

Example: User has role "venue_manager" but only for Team A, not Team B

```typescript
// packages/database/src/schema/rbac-extensions.ts

/**
 * Optional: Constrain member roles to specific teams
 *
 * BetterAuth provides org-level roles; this extends with team-level scoping
 */
export const memberRoleScopes = pgTable(
  "member_role_scope",
  {
    id: text("id").primaryKey(),

    memberId: text("member_id")
      .notNull()
      .references(() => members.id, { onDelete: "cascade" }),

    roleName: text("role_name").notNull(), // One of the roles assigned to member

    scope: varchar("scope", { length: 16 }).notNull(), // "org" or "teams"

    createdAt: timestamp("created_at", { withTimezone: true })
      .defaultNow()
      .notNull(),
  },
  (t) => ({
    memberRoleUniq: uniqueIndex("member_role_scope_uq").on(
      t.memberId,
      t.roleName
    ),
  })
);

/**
 * If scope = "teams", enumerate which teams the role applies to
 */
export const memberRoleScopeTeams = pgTable(
  "member_role_scope_team",
  {
    id: text("id").primaryKey(),

    memberId: text("member_id").notNull(),
    roleName: text("role_name").notNull(),
    teamId: text("team_id")
      .notNull()
      .references(() => teams.id, { onDelete: "cascade" }),

    createdAt: timestamp("created_at", { withTimezone: true })
      .defaultNow()
      .notNull(),
  },
  (t) => ({
    memberRoleTeamUniq: uniqueIndex("member_role_team_uq").on(
      t.memberId,
      t.roleName,
      t.teamId
    ),
    teamIdx: index("member_role_team_idx").on(t.teamId),
  })
);
```

**Usage Pattern**:

1. User has `member` record with role `["venue_manager", "sales"]`
2. `memberRoleScopes` says `venue_manager` has scope `"teams"` (not org-wide)
3. `memberRoleScopeTeams` lists which teams that role applies to
4. Your code checks both org permission AND team scope before allowing action

---

## RBAC Patterns

### Access Control Configuration

Define permissions in `auth.ts` using BetterAuth's AC system:

```typescript
// packages/auth/src/config.ts
import { betterAuth } from "better-auth";
import { organization } from "better-auth/plugins";
import { createAccessControl } from "better-auth/plugins/access-control";

// Define resources and actions
const ac = createAccessControl({
  event: ["create", "read", "update", "delete", "publish"],
  ticket: ["create", "read", "transfer", "refund", "check_in"],
  venue: ["create", "read", "update", "delete"],
  analytics: ["read"],
  payout: ["read", "request"],
  team: ["create", "read", "update", "delete", "manage_members"],
});

// Define roles with permissions
ac.newRole("owner", {
  "*": ["*"], // Owner has all permissions
});

ac.newRole("admin", {
  event: ["create", "read", "update", "delete", "publish"],
  ticket: ["create", "read", "transfer", "refund", "check_in"],
  venue: ["create", "read", "update", "delete"],
  analytics: ["read"],
  payout: ["read", "request"],
  team: ["create", "read", "update", "delete", "manage_members"],
});

ac.newRole("manager", {
  event: ["create", "read", "update", "publish"],
  ticket: ["read", "check_in"],
  venue: ["read", "update"],
  analytics: ["read"],
});

ac.newRole("door_staff", {
  ticket: ["read", "check_in"],
  event: ["read"],
});

ac.newRole("growth_partner", {
  event: ["read"],
  analytics: ["read"], // Can see their referral stats
  payout: ["read"], // Can see their earnings
});

ac.newRole("affiliate", {
  event: ["read"],
  analytics: ["read"],
});

ac.newRole("organizer", {
  // For group trip orgs
  event: ["read"],
  team: ["read", "manage_members"], // Can invite to group
});

ac.newRole("member", {
  // Basic member (in any org type)
  event: ["read"],
});

export const auth = betterAuth({
  database: {
    // Drizzle adapter config
  },
  plugins: [
    organization({
      ac,
      dynamicAccessControl: {
        enabled: false, // Start false; enable later if you need runtime role creation
      },
      teams: {
        enabled: true, // Enable workspaces/teams
      },
      sendInvitationEmail: async (data) => {
        // Send invite email via your system (Inngest?)
        await inngest.send({
          name: "organization.invitation.sent",
          data,
        });
      },
    }),
  ],
  advanced: {
    crossSubDomainCookies: {
      enabled: true,
      domain: ".dayof.ai", // Share cookies across subdomains
    },
  },
  trustedOrigins: [
    "https://dayof.ai",
    "https://backstage.dayof.ai",
    "https://auth.dayof.ai",
  ],
  databaseHooks: {
    session: {
      create: {
        before: async (session) => {
          // Default to user's first org (or preferred org)
          const userOrgs = await db.query.members.findMany({
            where: eq(members.userId, session.userId),
            with: { organization: true },
          });

          if (userOrgs.length > 0) {
            // Prefer venue orgs over group orgs
            const venueOrg =
              userOrgs.find((m) => m.organization.metadata?.type === "venue") ||
              userOrgs[0];

            return {
              data: {
                ...session,
                activeOrganizationId: venueOrg.organizationId,
              },
            };
          }

          return {};
        },
      },
    },
  },
});
```

### Server-Side Permission Checks

**Org-Wide Permission** (Hono middleware):

```typescript
// packages/backstage/src/middleware/auth.ts
import { auth } from "@repo/auth";

export async function requireOrgPermission(permissions: {
  [resource: string]: string[];
}) {
  return async (c, next) => {
    const hasPermission = await auth.api.hasPermission({
      headers: c.req.raw.headers,
      body: { permissions },
    });

    if (!hasPermission) {
      return c.json({ error: "Forbidden" }, 403);
    }

    return next();
  };
}

// Usage in routes:
app.post("/events", requireOrgPermission({ event: ["create"] }), async (c) => {
  // User has permission to create events in active org
});
```

**Team-Scoped Permission** (with memberRoleScopes):

```typescript
// packages/backstage/src/middleware/auth.ts

export async function requireTeamScopedPermission(
  permissions: { [resource: string]: string[] },
  targetTeamId: string
) {
  return async (c, next) => {
    // 1. Check org-level permission first
    const hasOrgPermission = await auth.api.hasPermission({
      headers: c.req.raw.headers,
      body: { permissions },
    });

    if (!hasOrgPermission) {
      return c.json({ error: "Forbidden" }, 403);
    }

    // 2. Get active member
    const activeMember = await auth.api.getActiveMember({
      headers: c.req.raw.headers,
    });

    if (!activeMember) {
      return c.json({ error: "No active organization" }, 400);
    }

    // 3. Check if any roles are team-scoped
    const resourceName = Object.keys(permissions)[0]; // e.g., "event"
    const memberRoles = Array.isArray(activeMember.role)
      ? activeMember.role
      : [activeMember.role];

    for (const roleName of memberRoles) {
      const scope = await db.query.memberRoleScopes.findFirst({
        where: and(
          eq(memberRoleScopes.memberId, activeMember.id),
          eq(memberRoleScopes.roleName, roleName)
        ),
      });

      // If scope is "org", role applies everywhere - allow
      if (!scope || scope.scope === "org") {
        return next();
      }

      // If scope is "teams", check if this team is allowed
      if (scope.scope === "teams") {
        const allowedTeam = await db.query.memberRoleScopeTeams.findFirst({
          where: and(
            eq(memberRoleScopeTeams.memberId, activeMember.id),
            eq(memberRoleScopeTeams.roleName, roleName),
            eq(memberRoleScopeTeams.teamId, targetTeamId)
          ),
        });

        if (allowedTeam) {
          return next();
        }
      }
    }

    // No role with access to this team
    return c.json({ error: "Team access denied" }, 403);
  };
}

// Usage:
app.post(
  "/events/:teamId/publish",
  async (c, next) => {
    const teamId = c.req.param("teamId");
    return requireTeamScopedPermission({ event: ["publish"] }, teamId)(c, next);
  },
  async (c) => {
    // User has permission to publish events for this specific team
  }
);
```

### Client-Side Permission Checks (TanStack Start)

```typescript
// apps/backstage/src/hooks/usePermissions.ts
import { authClient } from "@repo/auth/client";

export function usePermissions() {
  const { data: activeMember } = authClient.organization.useActiveMember();

  const can = (resource: string, action: string) => {
    if (!activeMember) return false;

    // Quick client-side check (not authoritative)
    return authClient.organization.checkRolePermission({
      permissions: { [resource]: [action] },
      role: activeMember.role,
    });
  };

  return { can };
}

// Usage in component:
export function EventActions({ event }) {
  const { can } = usePermissions();

  return (
    <div>
      {can("event", "publish") && (
        <Button onClick={() => publishEvent(event.id)}>Publish Event</Button>
      )}
      {can("event", "delete") && (
        <Button onClick={() => deleteEvent(event.id)}>Delete Event</Button>
      )}
    </div>
  );
}
```

---

## Session & Context Switching

### Default Active Organization

Set a default active org when user logs in (from `auth.ts` config above):

```typescript
databaseHooks: {
  session: {
    create: {
      before: async (session) => {
        // Get user's organizations
        const userOrgs = await db.query.members.findMany({
          where: eq(members.userId, session.userId),
          with: { organization: true },
        });

        if (userOrgs.length > 0) {
          // Prefer venue orgs, then growth partner orgs, then group orgs
          const preferredOrg =
            userOrgs.find(m => m.organization.metadata?.type === "venue") ||
            userOrgs.find(m => m.organization.metadata?.type === "growth_partner") ||
            userOrgs[0];

          return {
            data: {
              ...session,
              activeOrganizationId: preferredOrg.organizationId,
            },
          };
        }

        return {};
      },
    },
  },
}
```

### Switching Organizations (Web)

```typescript
// apps/backstage/src/components/OrgSwitcher.tsx
import { authClient } from "@repo/auth/client";

export function OrgSwitcher() {
  const { data: orgs } = authClient.organization.useUserOrganizations();
  const { data: activeOrg } = authClient.organization.useActiveOrganization();

  const switchOrg = async (orgId: string) => {
    await authClient.organization.setActive({
      organizationId: orgId,
    });

    // Refresh page or trigger data reload
    window.location.reload();
  };

  return (
    <Select value={activeOrg?.id} onValueChange={switchOrg}>
      {orgs?.map((org) => (
        <SelectItem key={org.id} value={org.id}>
          {org.name}
        </SelectItem>
      ))}
    </Select>
  );
}
```

### Switching Teams (Web)

```typescript
// apps/backstage/src/components/TeamSwitcher.tsx
import { authClient } from "@repo/auth/client";

export function TeamSwitcher() {
  const { data: teams } = authClient.organization.useTeams();
  const { data: session } = authClient.useSession();

  const switchTeam = async (teamId: string | null) => {
    await authClient.organization.setActiveTeam({
      teamId, // null to clear team context
    });

    window.location.reload();
  };

  return (
    <Select
      value={session?.activeTeamId || "all"}
      onValueChange={(val) => switchTeam(val === "all" ? null : val)}
    >
      <SelectItem value="all">All Teams</SelectItem>
      {teams?.map((team) => (
        <SelectItem key={team.id} value={team.id}>
          {team.name}
        </SelectItem>
      ))}
    </Select>
  );
}
```

### Hono Middleware (Server-Side Session Access)

```typescript
// apps/backstage/src/middleware/session.ts
import { auth } from "@repo/auth";

export async function requireAuth() {
  return async (c, next) => {
    const session = await auth.api.getSession({
      headers: c.req.raw.headers,
    });

    if (!session) {
      return c.json({ error: "Unauthorized" }, 401);
    }

    c.set("user", session.user);
    c.set("session", session.session);

    return next();
  };
}

// Usage:
app.use("*", requireAuth());

app.get("/me", async (c) => {
  const user = c.get("user");
  const session = c.get("session");

  return c.json({
    user,
    activeOrganizationId: session.activeOrganizationId,
    activeTeamId: session.activeTeamId,
  });
});
```

---

## Scenario Mappings

### Scenario 1: Venue Owner + External Attendee

**User Profile**: Jon owns "Miami Beach Nightclub Group" and wants to attend a concert at "Madison Square Garden"

**Implementation**:

```typescript
// Jon's memberships:
// - member(userId: jon, orgId: miami_nightclub, role: ["owner"])
// - NO member record for Madison Square Garden

// When Jon buys ticket to MSG concert:
const order = await createOrder({
  userId: "jon",
  eventId: "msg_concert_123",
  purchaserOrganizationId: null, // Not buying as org
});

// Ticket created:
const ticket = await createTicket({
  orderId: order.id,
  holderUserId: "jon",
  hostOrganizationId: "msg_venue_org", // MSG's org
  hostTeamId: null,
});

// Jon can access ticket without being member of MSG's org
```

**Key Point**: `holderUserId` on ticket is all that's needed; no membership check

### Scenario 2: Multi-Venue Organization with Shared Affiliates

**User Profile**: "Las Vegas Entertainment Group" has 3 venues; affiliate Sarah promotes all of them

**Implementation**:

```typescript
// Organization:
const org = await createOrganization({
  name: "Las Vegas Entertainment Group",
  metadata: { type: "venue" },
});

// Teams (one per venue):
const venue1Team = await createTeam({
  organizationId: org.id,
  name: "Club Luxe",
});
const venue2Team = await createTeam({
  organizationId: org.id,
  name: "Rooftop Bar",
});
const venue3Team = await createTeam({
  organizationId: org.id,
  name: "Concert Hall",
});

// Sarah is member with org-wide affiliate role:
await addMember({
  organizationId: org.id,
  userId: "sarah",
  role: ["affiliate"],
});

// Sarah is NOT added to specific teams - her role is org-wide
// She can promote events from any team

// Affiliate link:
await createAffiliateLink({
  code: "SARAH_VIP",
  organizationId: org.id,
  teamId: null, // Org-wide (works for all venues)
  affiliateUserId: "sarah",
  commissionRate: 0.15, // 15% of app fee
});
```

**RBAC Check**: When Sarah accesses analytics, check `member.role` includes `"affiliate"` and `memberRoleScopes` is either absent or has scope `"org"`

### Scenario 3: Affiliate in Multiple Organizations, Limited Teams

**User Profile**: Mike is affiliate for "Miami Beach Nightclub Group" (only Club Oasis) and "Fort Lauderdale Events" (all venues)

**Implementation**:

```typescript
// Organization 1: Miami Beach Nightclub Group
const miamiOrg = { id: "miami_org" };
const clubOasisTeam = { id: "club_oasis_team" };

// Add Mike as member with team-scoped affiliate role:
await addMember({
  organizationId: miamiOrg.id,
  userId: "mike",
  role: ["affiliate"],
});

// Constrain affiliate role to specific team:
await createMemberRoleScope({
  memberId: "mike_miami_member_id",
  roleName: "affiliate",
  scope: "teams",
});

await createMemberRoleScopeTeam({
  memberId: "mike_miami_member_id",
  roleName: "affiliate",
  teamId: clubOasisTeam.id,
});

// Organization 2: Fort Lauderdale Events
const ftlOrg = { id: "ftl_org" };

await addMember({
  organizationId: ftlOrg.id,
  userId: "mike",
  role: ["affiliate"],
});

// No role scope entry = org-wide access
```

**RBAC Check**: When Mike tries to view analytics for a team, check:

1. Does Mike have `affiliate` role in org? (Yes)
2. Does `memberRoleScopes` exist for this role? (Yes for Miami, No for FTL)
3. If scope is `"teams"`, is this team in `memberRoleScopeTeams`? (Check)

### Scenario 4: Group Trip Organization

**User Profile**: Fraternity "Alpha Beta" creates org for Spring Break 2026; 32 members, 2 organizers

**Implementation**:

```typescript
// Create group organization:
const groupOrg = await createOrganization({
  name: "Alpha Beta Spring Break 2026",
  slug: "alpha-beta-sb26",
  metadata: {
    type: "group",
    tripDates: ["2026-03-10", "2026-03-17"],
    maxMembers: 50,
  },
});

// Invite organizers:
await inviteToOrganization({
  organizationId: groupOrg.id,
  email: "john@example.com",
  role: "organizer",
});

await inviteToOrganization({
  organizationId: groupOrg.id,
  email: "mike@example.com",
  role: "organizer",
});

// Invite regular members (30 more):
for (const email of memberEmails) {
  await inviteToOrganization({
    organizationId: groupOrg.id,
    email,
    role: "member",
  });
}

// When buying tickets for the group:
const order = await createOrder({
  userId: "john", // Organizer buying
  purchaserOrganizationId: groupOrg.id, // Links purchase to group
});

// Each ticket still has individual holder:
for (const attendee of attendees) {
  await createTicket({
    orderId: order.id,
    holderUserId: attendee.userId,
    hostOrganizationId: "venue_org_id", // Host venue
    purchaserOrganizationId: groupOrg.id, // Group context
  });
}
```

**UI Differentiation**:

- Organizers see: Group management, invite members, itinerary, room assignments
- Regular members see: Their tickets, group chat, schedule

### Scenario 5: Multi-Role Member

**User Profile**: Lisa is both "manager" and "door_staff" at a venue

**Implementation**:

```typescript
// Add Lisa with multiple roles:
await addMember({
  organizationId: venueOrg.id,
  userId: "lisa",
  role: ["manager", "door_staff"],
});

// Permission check evaluates union of both roles:
const canCheckIn = await auth.api.hasPermission({
  headers,
  body: {
    permissions: { ticket: ["check_in"] },
  },
});
// Returns true (door_staff has this permission)

const canCreateEvent = await auth.api.hasPermission({
  headers,
  body: {
    permissions: { event: ["create"] },
  },
});
// Returns true (manager has this permission)
```

---

## Implementation Checklist

### Phase 1: BetterAuth Setup

- [ ] Install BetterAuth: `npm install better-auth`
- [ ] Run CLI to generate schema: `npx @better-auth/cli generate`
- [ ] Merge BetterAuth schema with Drizzle schema
- [ ] Run migrations: `drizzle-kit push` or `drizzle-kit migrate`
- [ ] Configure `auth.ts` with organization plugin + teams + AC
- [ ] Enable cross-subdomain cookies for `*.dayof.ai`
- [ ] Set trusted origins for CORS
- [ ] Add database hook for default active org

### Phase 2: RBAC Configuration

- [ ] Define resources and actions in AC config
- [ ] Define roles with permissions (owner, admin, manager, door_staff, growth_partner, affiliate, organizer, member)
- [ ] Test permission checks with sample users
- [ ] Document role hierarchy

### Phase 3: DayOf Schema Extensions

- [ ] Create `organizationMetadata` table
- [ ] Create `venues` table
- [ ] Create `events` table
- [ ] Create `orders` table
- [ ] Create `tickets` table
- [ ] Create `affiliateLinks` table
- [ ] (Optional) Create `memberRoleScopes` and `memberRoleScopeTeams` tables
- [ ] Add indexes for performance

### Phase 4: Middleware & Guards

- [ ] Create `requireAuth` middleware (Hono)
- [ ] Create `requireOrgPermission` middleware
- [ ] Create `requireTeamScopedPermission` middleware (if using team-scoped roles)
- [ ] Add session hydration to Hono app
- [ ] Test middleware with various user types

### Phase 5: Client Integration (Web)

- [ ] Install BetterAuth client: `npm install @better-auth/client`
- [ ] Create auth client instance
- [ ] Build OrgSwitcher component
- [ ] Build TeamSwitcher component
- [ ] Create `usePermissions` hook
- [ ] Test context switching
- [ ] Implement invite acceptance flow

### Phase 6: Mobile (Expo)

- [ ] Install BetterAuth Expo client
- [ ] Configure secure storage for session
- [ ] Implement deep link handling for invites
- [ ] Test session persistence across app restarts
- [ ] Implement org/team context in mobile UI

### Phase 7: Testing

- [ ] Unit tests for permission checks
- [ ] Integration tests for org switching
- [ ] E2E tests for invite flows
- [ ] Load test org/team queries
- [ ] Security audit of RBAC implementation

---

## Mobile Considerations (Expo)

### Setup

```typescript
// apps/crew/src/lib/auth.ts
import { createAuthClient } from "@better-auth/expo";
import * as SecureStore from "expo-secure-store";

export const authClient = createAuthClient({
  baseURL: "https://auth.dayof.ai",

  // Persist session in secure storage
  storage: {
    getItem: async (key) => {
      return await SecureStore.getItemAsync(key);
    },
    setItem: async (key, value) => {
      await SecureStore.setItemAsync(key, value);
    },
    removeItem: async (key) => {
      await SecureStore.deleteItemAsync(key);
    },
  },
});
```

### Session Rehydration

```typescript
// apps/crew/App.tsx
import { useEffect } from "react";
import { authClient } from "./lib/auth";

export function App() {
  const [isReady, setIsReady] = useState(false);

  useEffect(() => {
    // Rehydrate session on app start
    authClient.session
      .get()
      .then(() => setIsReady(true))
      .catch(() => setIsReady(true));
  }, []);

  if (!isReady) {
    return <LoadingScreen />;
  }

  return <MainApp />;
}
```

### Active Org Context in Mobile

```typescript
// apps/crew/src/contexts/OrgContext.tsx
import { createContext, useContext, useState, useEffect } from "react";
import { authClient } from "../lib/auth";

const OrgContext = createContext(null);

export function OrgProvider({ children }) {
  const [activeOrg, setActiveOrg] = useState(null);

  useEffect(() => {
    authClient.organization
      .getActiveOrganization()
      .then((org) => setActiveOrg(org));
  }, []);

  const switchOrg = async (orgId: string) => {
    await authClient.organization.setActive({ organizationId: orgId });
    const org = await authClient.organization.getActiveOrganization();
    setActiveOrg(org);
  };

  return (
    <OrgContext.Provider value={{ activeOrg, switchOrg }}>
      {children}
    </OrgContext.Provider>
  );
}

export const useActiveOrg = () => useContext(OrgContext);
```

### Deep Link Handling (Invites)

```typescript
// apps/crew/src/navigation/LinkingConfiguration.ts
import * as Linking from "expo-linking";

const config = {
  screens: {
    AcceptInvite: "invite/:inviteId",
  },
};

// apps/crew/src/screens/AcceptInvite.tsx
export function AcceptInviteScreen({ route }) {
  const { inviteId } = route.params;

  const acceptInvite = async () => {
    try {
      await authClient.organization.acceptInvitation({
        invitationId: inviteId,
      });

      // Navigate to new org
      navigation.navigate("Home");
    } catch (error) {
      Alert.alert("Error", "Failed to accept invitation");
    }
  };

  return (
    <View>
      <Text>You've been invited to join an organization</Text>
      <Button onPress={acceptInvite}>Accept</Button>
    </View>
  );
}
```

### Offline Considerations

**Critical**: Crew app uses PowerSync for offline-first scanning

```typescript
// apps/crew/src/lib/powersync.ts

// Sync only data for active organization
export function configurePowerSync() {
  const { activeOrg } = useActiveOrg();

  return new PowerSyncDatabase({
    schema: appSchema,
    database: {
      dbFilename: "crew.db",
    },
    sync: {
      params: {
        organizationId: activeOrg?.id, // Scope sync to active org
      },
    },
  });
}
```

---

## Security & Best Practices

### 1. Never Trust Client-Side Permission Checks

**âŒ Bad**:

```typescript
// Client decides if user can delete event
if (user.role === "admin") {
  await deleteEvent(eventId);
}
```

**âœ… Good**:

```typescript
// Server enforces permission
app.delete(
  "/events/:id",
  requireOrgPermission({ event: ["delete"] }),
  async (c) => {
    // Server-side check passed, safe to proceed
  }
);
```

### 2. Always Validate Organization Context

**âŒ Bad**:

```typescript
// Trust activeOrganizationId from client
const events = await db.query.events.findMany({
  where: eq(events.organizationId, req.body.organizationId),
});
```

**âœ… Good**:

```typescript
// Get active org from server-side session
const session = await auth.api.getSession({ headers });
const events = await db.query.events.findMany({
  where: eq(events.organizationId, session.session.activeOrganizationId),
});
```

### 3. Scope API Endpoints by Organization

**Pattern**: Include org context in all queries

```typescript
// apps/backstage/src/routes/events.ts

app.get("/events", requireAuth(), async (c) => {
  const session = c.get("session");

  // Always filter by active organization
  const events = await db.query.events.findMany({
    where: eq(events.organizationId, session.activeOrganizationId),
  });

  return c.json({ events });
});
```

### 4. Use Transactions for Multi-Table Operations

```typescript
// When creating event with team scope:
await db.transaction(async (tx) => {
  const event = await tx
    .insert(events)
    .values({
      organizationId: activeOrg.id,
      teamId: activeTeam?.id,
      name: "New Event",
    })
    .returning();

  // Create initial ticket types
  await tx.insert(ticketTypes).values({
    eventId: event.id,
    name: "General Admission",
    priceCents: 5000,
  });
});
```

### 5. Rate Limit Sensitive Operations

```typescript
// Prevent invitation spam
app.post(
  "/invitations",
  requireAuth(),
  requireOrgPermission({ team: ["manage_members"] }),
  rateLimit({ windowMs: 60000, max: 10 }), // 10 invites per minute
  async (c) => {
    // Send invitation
  }
);
```

### 6. Audit Critical Actions

```typescript
// Use Inngest to log all org changes
import { inngest } from "@repo/inngest";

export async function auditOrgAction(action: string, data: any) {
  await inngest.send({
    name: "organization.action.logged",
    data: {
      action,
      ...data,
      timestamp: new Date(),
    },
  });
}

// Usage:
app.post("/members", requireOrgPermission({ team: ["manage_members"] }), async (c) => {
  const newMember = await addMember(...);

  await auditOrgAction("member.added", {
    organizationId: activeOrg.id,
    addedBy: session.userId,
    newMemberId: newMember.id,
    role: newMember.role,
  });

  return c.json({ member: newMember });
});
```

### 7. Handle Deleted Organizations Gracefully

```typescript
// Check if org still exists before operations
app.use("/org/:orgId/*", async (c, next) => {
  const orgId = c.req.param("orgId");

  const org = await db.query.organizations.findFirst({
    where: eq(organizations.id, orgId),
  });

  if (!org) {
    return c.json({ error: "Organization not found" }, 404);
  }

  return next();
});
```

### 8. Separate Platform Admin from Org Admin

**Platform admins** (DayOf employees) should NOT use org RBAC:

```typescript
// packages/database/src/schema/platform.ts

export const platformAdmins = pgTable("platform_admin", {
  userId: text("user_id")
    .primaryKey()
    .references(() => users.id, { onDelete: "cascade" }),
  role: varchar("role", { length: 32 }).notNull(), // "support", "engineer", "superadmin"
  createdAt: timestamp("created_at", { withTimezone: true }).defaultNow(),
});

// Middleware:
export async function requirePlatformAdmin() {
  return async (c, next) => {
    const session = await auth.api.getSession({ headers: c.req.raw.headers });

    const isAdmin = await db.query.platformAdmins.findFirst({
      where: eq(platformAdmins.userId, session.user.id),
    });

    if (!isAdmin) {
      return c.json({ error: "Platform admin access required" }, 403);
    }

    return next();
  };
}
```

---

## Summary

### What BetterAuth Provides

âœ… Many-to-many user â†” organization relationships  
âœ… Teams/workspaces within organizations  
âœ… Active context tracking (org + team)  
âœ… Multi-role support per membership  
âœ… Invitation system with team scoping  
âœ… RBAC via Access Control system  
âœ… Cross-subdomain cookie support

### What You Need to Build

ðŸ”§ Organization type metadata (venue, growth_partner, group, sponsor)  
ðŸ”§ Application tables (venues, events, orders, tickets)  
ðŸ”§ Team-scoped role constraints (optional `memberRoleScopes` tables)  
ðŸ”§ Permission middleware for Hono routes  
ðŸ”§ Client-side org/team switchers  
ðŸ”§ Mobile session persistence  
ðŸ”§ Affiliate tracking and payout logic  
ðŸ”§ Group purchase coordination

### Key Patterns

**Attendees don't need membership**: Tickets link to `holderUserId`, not org membership  
**Multi-context users**: Same user can be owner, affiliate, and attendee across different orgs  
**Team scoping**: Optional granular control via custom `memberRoleScopes` tables  
**Context switching**: Use `setActive` and `setActiveTeam` APIs, never manually manipulate cookies  
**Permission checks**: Always enforce server-side via `hasPermission` API

### Next Steps

1. âœ… Generate BetterAuth schema and merge with Drizzle
2. âœ… Configure auth.ts with org plugin, teams, AC, and cookie settings
3. âœ… Create DayOf application tables (organizationMetadata, venues, events, etc.)
4. âœ… Build middleware for permission checks
5. âœ… Implement org/team switchers in web apps
6. âœ… Set up mobile auth with Expo
7. âœ… Test all scenarios (venue owner, affiliate, group trip, etc.)

---

**This architecture enables DayOf's unique multi-tenant model**: venue operators manage events, growth partners earn commissions, attendees buy tickets freely, and group organizers coordinate trips - all with one unified authentication system and flexible RBAC.

> Last updated: Based on BetterAuth v1.2+ documentation and DayOf tech stack
