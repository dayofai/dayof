import { __toESM, require_cjs, schema } from "../schema-CZqfn_Cg.js";

//#region ../../node_modules/.bun/effect@3.17.14/node_modules/effect/dist/esm/Function.js
/**
* Tests if a value is a `function`.
*
* @example
* ```ts
* import * as assert from "node:assert"
* import { isFunction } from "effect/Predicate"
*
* assert.deepStrictEqual(isFunction(isFunction), true)
* assert.deepStrictEqual(isFunction("function"), false)
* ```
*
* @category guards
* @since 2.0.0
*/
const isFunction$1 = (input) => typeof input === "function";
/**
* Creates a function that can be used in a data-last (aka `pipe`able) or
* data-first style.
*
* The first parameter to `dual` is either the arity of the uncurried function
* or a predicate that determines if the function is being used in a data-first
* or data-last style.
*
* Using the arity is the most common use case, but there are some cases where
* you may want to use a predicate. For example, if you have a function that
* takes an optional argument, you can use a predicate to determine if the
* function is being used in a data-first or data-last style.
*
* You can pass either the arity of the uncurried function or a predicate
* which determines if the function is being used in a data-first or
* data-last style.
*
* **Example** (Using arity to determine data-first or data-last style)
*
* ```ts
* import { dual, pipe } from "effect/Function"
*
* const sum = dual<
*   (that: number) => (self: number) => number,
*   (self: number, that: number) => number
* >(2, (self, that) => self + that)
*
* console.log(sum(2, 3)) // 5
* console.log(pipe(2, sum(3))) // 5
* ```
*
* **Example** (Using call signatures to define the overloads)
*
* ```ts
* import { dual, pipe } from "effect/Function"
*
* const sum: {
*   (that: number): (self: number) => number
*   (self: number, that: number): number
* } = dual(2, (self: number, that: number): number => self + that)
*
* console.log(sum(2, 3)) // 5
* console.log(pipe(2, sum(3))) // 5
* ```
*
* **Example** (Using a predicate to determine data-first or data-last style)
*
* ```ts
* import { dual, pipe } from "effect/Function"
*
* const sum = dual<
*   (that: number) => (self: number) => number,
*   (self: number, that: number) => number
* >(
*   (args) => args.length === 2,
*   (self, that) => self + that
* )
*
* console.log(sum(2, 3)) // 5
* console.log(pipe(2, sum(3))) // 5
* ```
*
* @since 2.0.0
*/
const dual = function(arity, body) {
	if (typeof arity === "function") return function() {
		if (arity(arguments)) return body.apply(this, arguments);
		return (self) => body(self, ...arguments);
	};
	switch (arity) {
		case 0:
		case 1: throw new RangeError(`Invalid arity ${arity}`);
		case 2: return function(a, b) {
			if (arguments.length >= 2) return body(a, b);
			return function(self) {
				return body(self, a);
			};
		};
		case 3: return function(a, b, c) {
			if (arguments.length >= 3) return body(a, b, c);
			return function(self) {
				return body(self, a, b);
			};
		};
		case 4: return function(a, b, c, d) {
			if (arguments.length >= 4) return body(a, b, c, d);
			return function(self) {
				return body(self, a, b, c);
			};
		};
		case 5: return function(a, b, c, d, e) {
			if (arguments.length >= 5) return body(a, b, c, d, e);
			return function(self) {
				return body(self, a, b, c, d);
			};
		};
		default: return function() {
			if (arguments.length >= arity) return body.apply(this, arguments);
			const args$1 = arguments;
			return function(self) {
				return body(self, ...args$1);
			};
		};
	}
};
/**
* The identity function, i.e. A function that returns its input argument.
*
* @example
* ```ts
* import * as assert from "node:assert"
* import { identity } from "effect/Function"
*
* assert.deepStrictEqual(identity(5), 5)
* ```
*
* @since 2.0.0
*/
const identity = (a) => a;
/**
* Creates a constant value that never changes.
*
* This is useful when you want to pass a value to a higher-order function (a function that takes another function as its argument)
* and want that inner function to always use the same value, no matter how many times it is called.
*
* @example
* ```ts
* import * as assert from "node:assert"
* import { constant } from "effect/Function"
*
* const constNull = constant(null)
*
* assert.deepStrictEqual(constNull(), null)
* assert.deepStrictEqual(constNull(), null)
* ```
*
* @since 2.0.0
*/
const constant = (value) => () => value;
/**
* A thunk that returns always `true`.
*
* @example
* ```ts
* import * as assert from "node:assert"
* import { constTrue } from "effect/Function"
*
* assert.deepStrictEqual(constTrue(), true)
* ```
*
* @since 2.0.0
*/
const constTrue = /* @__PURE__ */ constant(true);
/**
* A thunk that returns always `false`.
*
* @example
* ```ts
* import * as assert from "node:assert"
* import { constFalse } from "effect/Function"
*
* assert.deepStrictEqual(constFalse(), false)
* ```
*
* @since 2.0.0
*/
const constFalse = /* @__PURE__ */ constant(false);
/**
* A thunk that returns always `undefined`.
*
* @example
* ```ts
* import * as assert from "node:assert"
* import { constUndefined } from "effect/Function"
*
* assert.deepStrictEqual(constUndefined(), undefined)
* ```
*
* @since 2.0.0
*/
const constUndefined = /* @__PURE__ */ constant(void 0);
/**
* A thunk that returns always `void`.
*
* @example
* ```ts
* import * as assert from "node:assert"
* import { constVoid } from "effect/Function"
*
* assert.deepStrictEqual(constVoid(), undefined)
* ```
*
* @since 2.0.0
*/
const constVoid = constUndefined;
function pipe(a, ab, bc, cd, de, ef, fg, gh, hi) {
	switch (arguments.length) {
		case 1: return a;
		case 2: return ab(a);
		case 3: return bc(ab(a));
		case 4: return cd(bc(ab(a)));
		case 5: return de(cd(bc(ab(a))));
		case 6: return ef(de(cd(bc(ab(a)))));
		case 7: return fg(ef(de(cd(bc(ab(a))))));
		case 8: return gh(fg(ef(de(cd(bc(ab(a)))))));
		case 9: return hi(gh(fg(ef(de(cd(bc(ab(a))))))));
		default: {
			let ret = arguments[0];
			for (let i = 1; i < arguments.length; i++) ret = arguments[i](ret);
			return ret;
		}
	}
}

//#endregion
//#region ../../node_modules/.bun/effect@3.17.14/node_modules/effect/dist/esm/Equivalence.js
/**
* @category constructors
* @since 2.0.0
*/
const make$45 = (isEquivalent) => (self, that) => self === that || isEquivalent(self, that);
const isStrictEquivalent = (x, y) => x === y;
/**
* Return an `Equivalence` that uses strict equality (===) to compare values.
*
* @since 2.0.0
* @category constructors
*/
const strict = () => isStrictEquivalent;
/**
* @category instances
* @since 2.0.0
*/
const number$2 = /* @__PURE__ */ strict();
/**
* @category instances
* @since 2.0.0
*/
const boolean$1 = /* @__PURE__ */ strict();
/**
* @category mapping
* @since 2.0.0
*/
const mapInput$1 = /* @__PURE__ */ dual(2, (self, f) => make$45((x, y) => self(f(x), f(y))));
/**
* @category combining
* @since 2.0.0
*/
const all$5 = (collection) => {
	return make$45((x, y) => {
		const len = Math.min(x.length, y.length);
		let collectionLength = 0;
		for (const equivalence$1 of collection) {
			if (collectionLength >= len) break;
			if (!equivalence$1(x[collectionLength], y[collectionLength])) return false;
			collectionLength++;
		}
		return true;
	});
};
/**
* Similar to `Promise.all` but operates on `Equivalence`s.
*
* ```ts skip-type-checking
* [Equivalence<A>, Equivalence<B>, ...] -> Equivalence<[A, B, ...]>
* ```
*
* Given a tuple of `Equivalence`s returns a new `Equivalence` that compares values of a tuple
* by applying each `Equivalence` to the corresponding element of the tuple.
*
* @category combinators
* @since 2.0.0
*/
const tuple$1 = (...elements) => all$5(elements);
/**
* Creates a new `Equivalence` for an array of values based on a given `Equivalence` for the elements of the array.
*
* @category combinators
* @since 2.0.0
*/
const array$2 = (item) => make$45((self, that) => {
	if (self.length !== that.length) return false;
	for (let i = 0; i < self.length; i++) if (!item(self[i], that[i])) return false;
	return true;
});
/**
* Given a struct of `Equivalence`s returns a new `Equivalence` that compares values of a struct
* by applying each `Equivalence` to the corresponding property of the struct.
*
* @category combinators
* @since 2.0.0
*/
const struct$3 = (fields) => {
	const keys$5 = Object.keys(fields);
	return make$45((self, that) => {
		for (const key of keys$5) if (!fields[key](self[key], that[key])) return false;
		return true;
	});
};

//#endregion
//#region ../../node_modules/.bun/effect@3.17.14/node_modules/effect/dist/esm/internal/doNotation.js
/** @internal */
const let_$2 = (map$17) => dual(3, (self, name, f) => map$17(self, (a) => ({
	...a,
	[name]: f(a)
})));
/** @internal */
const bindTo$2 = (map$17) => dual(2, (self, name) => map$17(self, (a) => ({ [name]: a })));
/** @internal */
const bind$2 = (map$17, flatMap$12) => dual(3, (self, name, f) => flatMap$12(self, (a) => map$17(f(a), (b) => ({
	...a,
	[name]: b
}))));

//#endregion
//#region ../../node_modules/.bun/effect@3.17.14/node_modules/effect/dist/esm/GlobalValue.js
/**
* The `GlobalValue` module ensures that a single instance of a value is created globally,
* even when modules are imported multiple times (e.g., due to mixing CommonJS and ESM builds)
* or during hot-reloading in development environments like Next.js or Remix.
*
* It achieves this by using a versioned global store, identified by a unique `Symbol` tied to
* the current version of the `effect` library. The store holds values that are keyed by an identifier,
* allowing the reuse of previously computed instances across imports or reloads.
*
* This pattern is particularly useful in scenarios where frequent reloading can cause services or
* single-instance objects to be recreated unnecessarily, such as in development environments with hot-reloading.
*
* @since 2.0.0
*/
const globalStoreId = `effect/GlobalValue`;
let globalStore;
/**
* Retrieves or computes a global value associated with the given `id`. If the value for this `id`
* has already been computed, it will be returned from the global store. If it does not exist yet,
* the provided `compute` function will be executed to compute the value, store it, and then return it.
*
* This ensures that even in cases where the module is imported multiple times (e.g., in mixed environments
* like CommonJS and ESM, or during hot-reloading in development), the value is computed only once and reused
* thereafter.
*
* @example
* ```ts
* import { globalValue } from "effect/GlobalValue"
*
* // This cache will persist as long as the module is running,
* // even if reloaded or imported elsewhere
* const myCache = globalValue(
*   Symbol.for("myCache"),
*   () => new WeakMap<object, number>()
* )
* ```
*
* @since 2.0.0
*/
const globalValue = (id$2, compute) => {
	if (!globalStore) {
		globalThis[globalStoreId] ??= /* @__PURE__ */ new Map();
		globalStore = globalThis[globalStoreId];
	}
	if (!globalStore.has(id$2)) globalStore.set(id$2, compute());
	return globalStore.get(id$2);
};

//#endregion
//#region ../../node_modules/.bun/effect@3.17.14/node_modules/effect/dist/esm/Predicate.js
/**
* A refinement that checks if a value is a `string`.
*
* @example
* ```ts
* import * as assert from "node:assert"
* import { isString } from "effect/Predicate"
*
* assert.strictEqual(isString("hello"), true)
* assert.strictEqual(isString(""), true)
*
* assert.strictEqual(isString(123), false)
* assert.strictEqual(isString(null), false)
* ```
*
* @category guards
* @since 2.0.0
*/
const isString = (input) => typeof input === "string";
/**
* A refinement that checks if a value is a `number`.
*
* @example
* ```ts
* import * as assert from "node:assert"
* import { isNumber } from "effect/Predicate"
*
* assert.strictEqual(isNumber(123), true)
* assert.strictEqual(isNumber(0), true)
* assert.strictEqual(isNumber(-1.5), true)
* assert.strictEqual(isNumber(NaN), true)
*
* assert.strictEqual(isNumber("123"), false)
* ```
*
* @category guards
* @since 2.0.0
*/
const isNumber$1 = (input) => typeof input === "number";
/**
* A refinement that checks if a value is a `boolean`.
*
* @example
* ```ts
* import * as assert from "node:assert"
* import { isBoolean } from "effect/Predicate"
*
* assert.strictEqual(isBoolean(true), true)
* assert.strictEqual(isBoolean(false), true)
*
* assert.strictEqual(isBoolean("true"), false)
* assert.strictEqual(isBoolean(0), false)
* ```
*
* @category guards
* @since 2.0.0
*/
const isBoolean$1 = (input) => typeof input === "boolean";
/**
* A refinement that checks if a value is a `bigint`.
*
* @example
* ```ts
* import * as assert from "node:assert"
* import { isBigInt } from "effect/Predicate"
*
* assert.strictEqual(isBigInt(1n), true)
*
* assert.strictEqual(isBigInt(1), false)
* assert.strictEqual(isBigInt("1"), false)
* ```
*
* @category guards
* @since 2.0.0
*/
const isBigInt = (input) => typeof input === "bigint";
/**
* A refinement that checks if a value is a `symbol`.
*
* @example
* ```ts
* import * as assert from "node:assert"
* import { isSymbol } from "effect/Predicate"
*
* assert.strictEqual(isSymbol(Symbol.for("a")), true)
*
* assert.strictEqual(isSymbol("a"), false)
* ```
*
* @category guards
* @since 2.0.0
*/
const isSymbol = (input) => typeof input === "symbol";
/**
* A refinement that checks if a value is a `Function`.
*
* @example
* ```ts
* import * as assert from "node:assert"
* import { isFunction } from "effect/Predicate"
*
* assert.strictEqual(isFunction(() => {}), true)
* assert.strictEqual(isFunction(isFunction), true)
*
* assert.strictEqual(isFunction("function"), false)
* ```
*
* @category guards
* @since 2.0.0
*/
const isFunction = isFunction$1;
/**
* A refinement that checks if a value is `undefined`.
*
* @example
* ```ts
* import * as assert from "node:assert"
* import { isUndefined } from "effect/Predicate"
*
* assert.strictEqual(isUndefined(undefined), true)
*
* assert.strictEqual(isUndefined(null), false)
* assert.strictEqual(isUndefined("undefined"), false)
* ```
*
* @category guards
* @since 2.0.0
*/
const isUndefined = (input) => input === void 0;
/**
* A refinement that always returns `false`. The type is narrowed to `never`.
*
* @example
* ```ts
* import * as assert from "node:assert"
* import { isNever } from "effect/Predicate"
*
* assert.strictEqual(isNever(1), false)
* assert.strictEqual(isNever(null), false)
* assert.strictEqual(isNever({}), false)
* ```
*
* @category guards
* @since 2.0.0
*/
const isNever = (_) => false;
/**
* Checks if the input is an object or an array.
* @internal
*/
const isRecordOrArray = (input) => typeof input === "object" && input !== null;
/**
* A refinement that checks if a value is an `object`. Note that in JavaScript,
* arrays and functions are also considered objects.
*
* @example
* ```ts
* import * as assert from "node:assert"
* import { isObject } from "effect/Predicate"
*
* assert.strictEqual(isObject({}), true)
* assert.strictEqual(isObject([]), true)
* assert.strictEqual(isObject(() => {}), true)
*
* assert.strictEqual(isObject(null), false)
* assert.strictEqual(isObject("hello"), false)
* ```
*
* @category guards
* @since 2.0.0
* @see isRecord to check for plain objects (excluding arrays and functions).
*/
const isObject$1 = (input) => isRecordOrArray(input) || isFunction(input);
/**
* A refinement that checks if a value is an object-like value and has a specific property key.
*
* @example
* ```ts
* import * as assert from "node:assert"
* import { hasProperty } from "effect/Predicate"
*
* assert.strictEqual(hasProperty({ a: 1 }, "a"), true)
* assert.strictEqual(hasProperty({ a: 1 }, "b"), false)
*
* const value: unknown = { name: "Alice" };
* if (hasProperty(value, "name")) {
*   // The type of `value` is narrowed to `{ name: unknown }`
*   // and we can safely access `value.name`
*   console.log(value.name)
* }
* ```
*
* @category guards
* @since 2.0.0
*/
const hasProperty = /* @__PURE__ */ dual(2, (self, property) => isObject$1(self) && property in self);
/**
* A refinement that checks if a value is an object with a `_tag` property
* that matches the given tag. This is a powerful tool for working with
* discriminated union types.
*
* @example
* ```ts
* import * as assert from "node:assert"
* import { isTagged } from "effect/Predicate"
*
* type Shape = { _tag: "circle"; radius: number } | { _tag: "square"; side: number }
*
* const isCircle = isTagged("circle")
*
* const shape1: Shape = { _tag: "circle", radius: 10 }
* const shape2: Shape = { _tag: "square", side: 5 }
*
* assert.strictEqual(isCircle(shape1), true)
* assert.strictEqual(isCircle(shape2), false)
*
* if (isCircle(shape1)) {
*   // shape1 is now narrowed to { _tag: "circle"; radius: number }
*   assert.strictEqual(shape1.radius, 10)
* }
* ```
*
* @category guards
* @since 2.0.0
*/
const isTagged = /* @__PURE__ */ dual(2, (self, tag) => hasProperty(self, "_tag") && self["_tag"] === tag);
/**
* A refinement that checks if a value is either `null` or `undefined`.
*
* @example
* ```ts
* import * as assert from "node:assert"
* import { isNullable } from "effect/Predicate"
*
* assert.strictEqual(isNullable(null), true)
* assert.strictEqual(isNullable(undefined), true)
*
* assert.strictEqual(isNullable(0), false)
* assert.strictEqual(isNullable(""), false)
* ```
*
* @category guards
* @since 2.0.0
* @see isNotNullable
*/
const isNullable = (input) => input === null || input === void 0;
/**
* A refinement that checks if a value is neither `null` nor `undefined`.
* The type is narrowed to `NonNullable<A>`.
*
* @example
* ```ts
* import * as assert from "node:assert"
* import { isNotNullable } from "effect/Predicate"
*
* assert.strictEqual(isNotNullable(0), true)
* assert.strictEqual(isNotNullable("hello"), true)
*
* assert.strictEqual(isNotNullable(null), false)
* assert.strictEqual(isNotNullable(undefined), false)
* ```
*
* @category guards
* @since 2.0.0
* @see isNullable
*/
const isNotNullable = (input) => input !== null && input !== void 0;
/**
* A refinement that checks if a value is a `Uint8Array`.
*
* @example
* ```ts
* import * as assert from "node:assert"
* import { isUint8Array } from "effect/Predicate"
*
* assert.strictEqual(isUint8Array(new Uint8Array()), true)
*
* assert.strictEqual(isUint8Array(new Uint16Array()), false)
* assert.strictEqual(isUint8Array([1, 2, 3]), false)
* ```
*
* @category guards
* @since 2.0.0
*/
const isUint8Array = (input) => input instanceof Uint8Array;
/**
* A refinement that checks if a value is a `Date` object.
*
* @example
* ```ts
* import * as assert from "node:assert"
* import { isDate } from "effect/Predicate"
*
* assert.strictEqual(isDate(new Date()), true)
*
* assert.strictEqual(isDate(Date.now()), false) // `Date.now()` returns a number
* assert.strictEqual(isDate("2023-01-01"), false)
* ```
*
* @category guards
* @since 2.0.0
*/
const isDate = (input) => input instanceof Date;
/**
* A refinement that checks if a value is an `Iterable`.
* Many built-in types are iterable, such as `Array`, `string`, `Map`, and `Set`.
*
* @example
* ```ts
* import * as assert from "node:assert"
* import { isIterable } from "effect/Predicate"
*
* assert.strictEqual(isIterable([]), true)
* assert.strictEqual(isIterable("hello"), true)
* assert.strictEqual(isIterable(new Set()), true)
*
* assert.strictEqual(isIterable({}), false)
* assert.strictEqual(isIterable(123), false)
* ```
*
* @category guards
* @since 2.0.0
*/
const isIterable = (input) => typeof input === "string" || hasProperty(input, Symbol.iterator);
/**
* A refinement that checks if a value is a record (i.e., a plain object).
* This check returns `false` for arrays, `null`, and functions.
*
* @example
* ```ts
* import * as assert from "node:assert"
* import { isRecord } from "effect/Predicate"
*
* assert.strictEqual(isRecord({}), true)
* assert.strictEqual(isRecord({ a: 1 }), true)
*
* assert.strictEqual(isRecord([]), false)
* assert.strictEqual(isRecord(new Date()), false)
* assert.strictEqual(isRecord(null), false)
* assert.strictEqual(isRecord(() => null), false)
* ```
*
* @category guards
* @since 2.0.0
* @see isObject
*/
const isRecord = (input) => isRecordOrArray(input) && !Array.isArray(input);
/**
* A refinement that checks if a value is `PromiseLike`. It performs a duck-typing
* check for a `.then` method.
*
* @example
* ```ts
* import * as assert from "node:assert"
* import { isPromiseLike } from "effect/Predicate"
*
* assert.strictEqual(isPromiseLike(Promise.resolve(1)), true)
* assert.strictEqual(isPromiseLike({ then: () => {} }), true)
*
* assert.strictEqual(isPromiseLike({}), false)
* ```
*
* @category guards
* @since 2.0.0
* @see isPromise
*/
const isPromiseLike = (input) => hasProperty(input, "then") && isFunction(input.then);
/**
* A refinement that checks if a value is a `RegExp`.
*
* @example
* ```ts
* import * as assert from "node:assert"
* import { Predicate } from "effect"
*
* assert.strictEqual(Predicate.isRegExp(/a/), true)
* assert.strictEqual(Predicate.isRegExp(new RegExp("a")), true)
*
* assert.strictEqual(Predicate.isRegExp("/a/"), false)
* ```
*
* @category guards
* @since 3.9.0
*/
const isRegExp$1 = (input) => input instanceof RegExp;

//#endregion
//#region ../../node_modules/.bun/effect@3.17.14/node_modules/effect/dist/esm/internal/errors.js
/**
* @since 2.0.0
*/
/** @internal */
const getBugErrorMessage = (message) => `BUG: ${message} - please report an issue at https://github.com/Effect-TS/effect/issues`;

//#endregion
//#region ../../node_modules/.bun/effect@3.17.14/node_modules/effect/dist/esm/Utils.js
/**
* @category symbols
* @since 2.0.0
*/
const GenKindTypeId = /* @__PURE__ */ Symbol.for("effect/Gen/GenKind");
/**
* @category constructors
* @since 2.0.0
*/
var GenKindImpl = class {
	value;
	constructor(value) {
		this.value = value;
	}
	/**
	* @since 2.0.0
	*/
	get _F() {
		return identity;
	}
	/**
	* @since 2.0.0
	*/
	get _R() {
		return (_) => _;
	}
	/**
	* @since 2.0.0
	*/
	get _O() {
		return (_) => _;
	}
	/**
	* @since 2.0.0
	*/
	get _E() {
		return (_) => _;
	}
	/**
	* @since 2.0.0
	*/
	[GenKindTypeId] = GenKindTypeId;
	/**
	* @since 2.0.0
	*/
	[Symbol.iterator]() {
		return new SingleShotGen(this);
	}
};
/**
* @category constructors
* @since 2.0.0
*/
var SingleShotGen = class SingleShotGen {
	self;
	called = false;
	constructor(self) {
		this.self = self;
	}
	/**
	* @since 2.0.0
	*/
	next(a) {
		return this.called ? {
			value: a,
			done: true
		} : (this.called = true, {
			value: this.self,
			done: false
		});
	}
	/**
	* @since 2.0.0
	*/
	return(a) {
		return {
			value: a,
			done: true
		};
	}
	/**
	* @since 2.0.0
	*/
	throw(e) {
		throw e;
	}
	/**
	* @since 2.0.0
	*/
	[Symbol.iterator]() {
		return new SingleShotGen(this.self);
	}
};
const defaultIncHi = 335903614;
const defaultIncLo = 4150755663;
const MUL_HI = 1481765933;
const MUL_LO = 1284865837;
const BIT_53 = 9007199254740992;
const BIT_27 = 134217728;
/**
* PCG is a family of simple fast space-efficient statistically good algorithms
* for random number generation. Unlike many general-purpose RNGs, they are also
* hard to predict.
*
* @category model
* @since 2.0.0
*/
var PCGRandom = class {
	_state;
	constructor(seedHi, seedLo, incHi, incLo) {
		if (isNullable(seedLo) && isNullable(seedHi)) {
			seedLo = Math.random() * 4294967295 >>> 0;
			seedHi = 0;
		} else if (isNullable(seedLo)) {
			seedLo = seedHi;
			seedHi = 0;
		}
		if (isNullable(incLo) && isNullable(incHi)) {
			incLo = this._state ? this._state[3] : defaultIncLo;
			incHi = this._state ? this._state[2] : defaultIncHi;
		} else if (isNullable(incLo)) {
			incLo = incHi;
			incHi = 0;
		}
		this._state = new Int32Array([
			0,
			0,
			incHi >>> 0,
			((incLo || 0) | 1) >>> 0
		]);
		this._next();
		add64(this._state, this._state[0], this._state[1], seedHi >>> 0, seedLo >>> 0);
		this._next();
		return this;
	}
	/**
	* Returns a copy of the internal state of this random number generator as a
	* JavaScript Array.
	*
	* @category getters
	* @since 2.0.0
	*/
	getState() {
		return [
			this._state[0],
			this._state[1],
			this._state[2],
			this._state[3]
		];
	}
	/**
	* Restore state previously retrieved using `getState()`.
	*
	* @since 2.0.0
	*/
	setState(state) {
		this._state[0] = state[0];
		this._state[1] = state[1];
		this._state[2] = state[2];
		this._state[3] = state[3] | 1;
	}
	/**
	* Get a uniformly distributed 32 bit integer between [0, max).
	*
	* @category getter
	* @since 2.0.0
	*/
	integer(max$4) {
		return Math.round(this.number() * Number.MAX_SAFE_INTEGER) % max$4;
	}
	/**
	* Get a uniformly distributed IEEE-754 double between 0.0 and 1.0, with
	* 53 bits of precision (every bit of the mantissa is randomized).
	*
	* @category getters
	* @since 2.0.0
	*/
	number() {
		const hi = (this._next() & 67108863) * 1;
		const lo = (this._next() & 134217727) * 1;
		return (hi * BIT_27 + lo) / BIT_53;
	}
	/** @internal */
	_next() {
		const oldHi = this._state[0] >>> 0;
		const oldLo = this._state[1] >>> 0;
		mul64(this._state, oldHi, oldLo, MUL_HI, MUL_LO);
		add64(this._state, this._state[0], this._state[1], this._state[2], this._state[3]);
		let xsHi = oldHi >>> 18;
		let xsLo = (oldLo >>> 18 | oldHi << 14) >>> 0;
		xsHi = (xsHi ^ oldHi) >>> 0;
		xsLo = (xsLo ^ oldLo) >>> 0;
		const xorshifted = (xsLo >>> 27 | xsHi << 5) >>> 0;
		const rot = oldHi >>> 27;
		const rot2 = (-rot >>> 0 & 31) >>> 0;
		return (xorshifted >>> rot | xorshifted << rot2) >>> 0;
	}
};
function mul64(out, aHi, aLo, bHi, bLo) {
	let c1 = (aLo >>> 16) * (bLo & 65535) >>> 0;
	let c0 = (aLo & 65535) * (bLo >>> 16) >>> 0;
	let lo = (aLo & 65535) * (bLo & 65535) >>> 0;
	let hi = (aLo >>> 16) * (bLo >>> 16) + ((c0 >>> 16) + (c1 >>> 16)) >>> 0;
	c0 = c0 << 16 >>> 0;
	lo = lo + c0 >>> 0;
	if (lo >>> 0 < c0 >>> 0) hi = hi + 1 >>> 0;
	c1 = c1 << 16 >>> 0;
	lo = lo + c1 >>> 0;
	if (lo >>> 0 < c1 >>> 0) hi = hi + 1 >>> 0;
	hi = hi + Math.imul(aLo, bHi) >>> 0;
	hi = hi + Math.imul(aHi, bLo) >>> 0;
	out[0] = hi;
	out[1] = lo;
}
function add64(out, aHi, aLo, bHi, bLo) {
	let hi = aHi + bHi >>> 0;
	const lo = aLo + bLo >>> 0;
	if (lo >>> 0 < aLo >>> 0) hi = hi + 1 | 0;
	out[0] = hi;
	out[1] = lo;
}
/**
* @since 3.0.6
*/
const YieldWrapTypeId = /* @__PURE__ */ Symbol.for("effect/Utils/YieldWrap");
/**
* @since 3.0.6
*/
var YieldWrap = class {
	/**
	* @since 3.0.6
	*/
	#value;
	constructor(value) {
		this.#value = value;
	}
	/**
	* @since 3.0.6
	*/
	[YieldWrapTypeId]() {
		return this.#value;
	}
};
/**
* @since 3.0.6
*/
function yieldWrapGet(self) {
	if (typeof self === "object" && self !== null && YieldWrapTypeId in self) return self[YieldWrapTypeId]();
	throw new Error(getBugErrorMessage("yieldWrapGet"));
}
/**
* Note: this is an experimental feature made available to allow custom matchers in tests, not to be directly used yet in user code
*
* @since 3.1.1
* @status experimental
* @category modifiers
*/
const structuralRegionState = /* @__PURE__ */ globalValue("effect/Utils/isStructuralRegion", () => ({
	enabled: false,
	tester: void 0
}));
const standard = { effect_internal_function: (body) => {
	return body();
} };
const forced = { effect_internal_function: (body) => {
	try {
		return body();
	} finally {}
} };
const isNotOptimizedAway = /* @__PURE__ */ standard.effect_internal_function(() => (/* @__PURE__ */ new Error()).stack)?.includes("effect_internal_function") === true;
/**
* @since 3.2.2
* @status experimental
* @category tracing
*/
const internalCall = isNotOptimizedAway ? standard.effect_internal_function : forced.effect_internal_function;
const genConstructor = function* () {}.constructor;

//#endregion
//#region ../../node_modules/.bun/effect@3.17.14/node_modules/effect/dist/esm/Hash.js
/** @internal */
const randomHashCache = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/Hash/randomHashCache"), () => /* @__PURE__ */ new WeakMap());
/**
* @since 2.0.0
* @category symbols
*/
const symbol$1 = /* @__PURE__ */ Symbol.for("effect/Hash");
/**
* @since 2.0.0
* @category hashing
*/
const hash = (self) => {
	if (structuralRegionState.enabled === true) return 0;
	switch (typeof self) {
		case "number": return number$1(self);
		case "bigint": return string(self.toString(10));
		case "boolean": return string(String(self));
		case "symbol": return string(String(self));
		case "string": return string(self);
		case "undefined": return string("undefined");
		case "function":
		case "object": if (self === null) return string("null");
		else if (self instanceof Date) return hash(self.toISOString());
		else if (self instanceof URL) return hash(self.href);
		else if (isHash(self)) return self[symbol$1]();
		else return random$2(self);
		default: throw new Error(`BUG: unhandled typeof ${typeof self} - please report an issue at https://github.com/Effect-TS/effect/issues`);
	}
};
/**
* @since 2.0.0
* @category hashing
*/
const random$2 = (self) => {
	if (!randomHashCache.has(self)) randomHashCache.set(self, number$1(Math.floor(Math.random() * Number.MAX_SAFE_INTEGER)));
	return randomHashCache.get(self);
};
/**
* @since 2.0.0
* @category hashing
*/
const combine$11 = (b) => (self) => self * 53 ^ b;
/**
* @since 2.0.0
* @category hashing
*/
const optimize = (n) => n & 3221225471 | n >>> 1 & 1073741824;
/**
* @since 2.0.0
* @category guards
*/
const isHash = (u) => hasProperty(u, symbol$1);
/**
* @since 2.0.0
* @category hashing
*/
const number$1 = (n) => {
	if (n !== n || n === Infinity) return 0;
	let h = n | 0;
	if (h !== n) h ^= n * 4294967295;
	while (n > 4294967295) h ^= n /= 4294967295;
	return optimize(h);
};
/**
* @since 2.0.0
* @category hashing
*/
const string = (str) => {
	let h = 5381, i = str.length;
	while (i) h = h * 33 ^ str.charCodeAt(--i);
	return optimize(h);
};
/**
* @since 2.0.0
* @category hashing
*/
const structureKeys = (o, keys$5) => {
	let h = 12289;
	for (let i = 0; i < keys$5.length; i++) h ^= pipe(string(keys$5[i]), combine$11(hash(o[keys$5[i]])));
	return optimize(h);
};
/**
* @since 2.0.0
* @category hashing
*/
const structure = (o) => structureKeys(o, Object.keys(o));
/**
* @since 2.0.0
* @category hashing
*/
const array$1 = (arr) => {
	let h = 6151;
	for (let i = 0; i < arr.length; i++) h = pipe(h, combine$11(hash(arr[i])));
	return optimize(h);
};
/**
* @since 2.0.0
* @category hashing
*/
const cached$2 = function() {
	if (arguments.length === 1) {
		const self$1 = arguments[0];
		return function(hash$2) {
			Object.defineProperty(self$1, symbol$1, {
				value() {
					return hash$2;
				},
				enumerable: false
			});
			return hash$2;
		};
	}
	const self = arguments[0];
	const hash$1 = arguments[1];
	Object.defineProperty(self, symbol$1, {
		value() {
			return hash$1;
		},
		enumerable: false
	});
	return hash$1;
};

//#endregion
//#region ../../node_modules/.bun/effect@3.17.14/node_modules/effect/dist/esm/Equal.js
/**
* @since 2.0.0
* @category symbols
*/
const symbol = /* @__PURE__ */ Symbol.for("effect/Equal");
function equals() {
	if (arguments.length === 1) return (self) => compareBoth(self, arguments[0]);
	return compareBoth(arguments[0], arguments[1]);
}
function compareBoth(self, that) {
	if (self === that) return true;
	const selfType = typeof self;
	if (selfType !== typeof that) return false;
	if (selfType === "object" || selfType === "function") {
		if (self !== null && that !== null) {
			if (isEqual(self) && isEqual(that)) if (hash(self) === hash(that) && self[symbol](that)) return true;
			else return structuralRegionState.enabled && structuralRegionState.tester ? structuralRegionState.tester(self, that) : false;
			else if (self instanceof Date && that instanceof Date) return self.toISOString() === that.toISOString();
			else if (self instanceof URL && that instanceof URL) return self.href === that.href;
		}
		if (structuralRegionState.enabled) {
			if (Array.isArray(self) && Array.isArray(that)) return self.length === that.length && self.every((v, i) => compareBoth(v, that[i]));
			if (Object.getPrototypeOf(self) === Object.prototype && Object.getPrototypeOf(self) === Object.prototype) {
				const keysSelf = Object.keys(self);
				const keysThat = Object.keys(that);
				if (keysSelf.length === keysThat.length) {
					for (const key of keysSelf) if (!(key in that && compareBoth(self[key], that[key]))) return structuralRegionState.tester ? structuralRegionState.tester(self, that) : false;
					return true;
				}
			}
			return structuralRegionState.tester ? structuralRegionState.tester(self, that) : false;
		}
	}
	return structuralRegionState.enabled && structuralRegionState.tester ? structuralRegionState.tester(self, that) : false;
}
/**
* @since 2.0.0
* @category guards
*/
const isEqual = (u) => hasProperty(u, symbol);
/**
* @since 2.0.0
* @category instances
*/
const equivalence = () => equals;

//#endregion
//#region ../../node_modules/.bun/effect@3.17.14/node_modules/effect/dist/esm/Inspectable.js
/**
* @since 2.0.0
* @category symbols
*/
const NodeInspectSymbol = /* @__PURE__ */ Symbol.for("nodejs.util.inspect.custom");
/**
* @since 2.0.0
*/
const toJSON = (x) => {
	try {
		if (hasProperty(x, "toJSON") && isFunction(x["toJSON"]) && x["toJSON"].length === 0) return x.toJSON();
		else if (Array.isArray(x)) return x.map(toJSON);
	} catch {
		return {};
	}
	return redact(x);
};
/**
* @since 2.0.0
*/
const format = (x) => JSON.stringify(x, null, 2);
/**
* @since 2.0.0
*/
const BaseProto = {
	toJSON() {
		return toJSON(this);
	},
	[NodeInspectSymbol]() {
		return this.toJSON();
	},
	toString() {
		return format(this.toJSON());
	}
};
/**
* @since 2.0.0
*/
var Class$4 = class {
	/**
	* @since 2.0.0
	*/
	[NodeInspectSymbol]() {
		return this.toJSON();
	}
	/**
	* @since 2.0.0
	*/
	toString() {
		return format(this.toJSON());
	}
};
/**
* @since 2.0.0
*/
const toStringUnknown = (u, whitespace = 2) => {
	if (typeof u === "string") return u;
	try {
		return typeof u === "object" ? stringifyCircular(u, whitespace) : String(u);
	} catch {
		return String(u);
	}
};
/**
* @since 2.0.0
*/
const stringifyCircular = (obj, whitespace) => {
	let cache = [];
	const retVal = JSON.stringify(obj, (_key, value) => typeof value === "object" && value !== null ? cache.includes(value) ? void 0 : cache.push(value) && (redactableState.fiberRefs !== void 0 && isRedactable(value) ? value[symbolRedactable](redactableState.fiberRefs) : value) : value, whitespace);
	cache = void 0;
	return retVal;
};
/**
* @since 3.10.0
* @category redactable
*/
const symbolRedactable = /* @__PURE__ */ Symbol.for("effect/Inspectable/Redactable");
/**
* @since 3.10.0
* @category redactable
*/
const isRedactable = (u) => typeof u === "object" && u !== null && symbolRedactable in u;
const redactableState = /* @__PURE__ */ globalValue("effect/Inspectable/redactableState", () => ({ fiberRefs: void 0 }));
/**
* @since 3.10.0
* @category redactable
*/
const withRedactableContext = (context$2, f) => {
	const prev = redactableState.fiberRefs;
	redactableState.fiberRefs = context$2;
	try {
		return f();
	} finally {
		redactableState.fiberRefs = prev;
	}
};
/**
* @since 3.10.0
* @category redactable
*/
const redact = (u) => {
	if (isRedactable(u) && redactableState.fiberRefs !== void 0) return u[symbolRedactable](redactableState.fiberRefs);
	return u;
};

//#endregion
//#region ../../node_modules/.bun/effect@3.17.14/node_modules/effect/dist/esm/Pipeable.js
/**
* @since 2.0.0
*/
/**
* @since 2.0.0
*/
const pipeArguments = (self, args$1) => {
	switch (args$1.length) {
		case 0: return self;
		case 1: return args$1[0](self);
		case 2: return args$1[1](args$1[0](self));
		case 3: return args$1[2](args$1[1](args$1[0](self)));
		case 4: return args$1[3](args$1[2](args$1[1](args$1[0](self))));
		case 5: return args$1[4](args$1[3](args$1[2](args$1[1](args$1[0](self)))));
		case 6: return args$1[5](args$1[4](args$1[3](args$1[2](args$1[1](args$1[0](self))))));
		case 7: return args$1[6](args$1[5](args$1[4](args$1[3](args$1[2](args$1[1](args$1[0](self)))))));
		case 8: return args$1[7](args$1[6](args$1[5](args$1[4](args$1[3](args$1[2](args$1[1](args$1[0](self))))))));
		case 9: return args$1[8](args$1[7](args$1[6](args$1[5](args$1[4](args$1[3](args$1[2](args$1[1](args$1[0](self)))))))));
		default: {
			let ret = self;
			for (let i = 0, len = args$1.length; i < len; i++) ret = args$1[i](ret);
			return ret;
		}
	}
};

//#endregion
//#region ../../node_modules/.bun/effect@3.17.14/node_modules/effect/dist/esm/internal/opCodes/effect.js
/** @internal */
const OP_ASYNC = "Async";
/** @internal */
const OP_COMMIT = "Commit";
/** @internal */
const OP_FAILURE = "Failure";
/** @internal */
const OP_ON_FAILURE = "OnFailure";
/** @internal */
const OP_ON_SUCCESS = "OnSuccess";
/** @internal */
const OP_ON_SUCCESS_AND_FAILURE = "OnSuccessAndFailure";
/** @internal */
const OP_SUCCESS = "Success";
/** @internal */
const OP_SYNC = "Sync";
/** @internal */
const OP_TAG = "Tag";
/** @internal */
const OP_UPDATE_RUNTIME_FLAGS = "UpdateRuntimeFlags";
/** @internal */
const OP_WHILE = "While";
/** @internal */
const OP_ITERATOR = "Iterator";
/** @internal */
const OP_WITH_RUNTIME = "WithRuntime";
/** @internal */
const OP_YIELD = "Yield";
/** @internal */
const OP_REVERT_FLAGS = "RevertFlags";

//#endregion
//#region ../../node_modules/.bun/effect@3.17.14/node_modules/effect/dist/esm/internal/version.js
let moduleVersion = "3.17.14";
const getCurrentVersion = () => moduleVersion;

//#endregion
//#region ../../node_modules/.bun/effect@3.17.14/node_modules/effect/dist/esm/internal/effectable.js
/** @internal */
const EffectTypeId$3 = /* @__PURE__ */ Symbol.for("effect/Effect");
/** @internal */
const StreamTypeId$1 = /* @__PURE__ */ Symbol.for("effect/Stream");
/** @internal */
const SinkTypeId$1 = /* @__PURE__ */ Symbol.for("effect/Sink");
/** @internal */
const ChannelTypeId$1 = /* @__PURE__ */ Symbol.for("effect/Channel");
/** @internal */
const effectVariance = {
	_R: (_) => _,
	_E: (_) => _,
	_A: (_) => _,
	_V: /* @__PURE__ */ getCurrentVersion()
};
const sinkVariance = {
	_A: (_) => _,
	_In: (_) => _,
	_L: (_) => _,
	_E: (_) => _,
	_R: (_) => _
};
const channelVariance = {
	_Env: (_) => _,
	_InErr: (_) => _,
	_InElem: (_) => _,
	_InDone: (_) => _,
	_OutErr: (_) => _,
	_OutElem: (_) => _,
	_OutDone: (_) => _
};
/** @internal */
const EffectPrototype$1 = {
	[EffectTypeId$3]: effectVariance,
	[StreamTypeId$1]: effectVariance,
	[SinkTypeId$1]: sinkVariance,
	[ChannelTypeId$1]: channelVariance,
	[symbol](that) {
		return this === that;
	},
	[symbol$1]() {
		return cached$2(this, random$2(this));
	},
	[Symbol.iterator]() {
		return new SingleShotGen(new YieldWrap(this));
	},
	pipe() {
		return pipeArguments(this, arguments);
	}
};
/** @internal */
const StructuralPrototype = {
	[symbol$1]() {
		return cached$2(this, structure(this));
	},
	[symbol](that) {
		const selfKeys = Object.keys(this);
		const thatKeys = Object.keys(that);
		if (selfKeys.length !== thatKeys.length) return false;
		for (const key of selfKeys) if (!(key in that && equals(this[key], that[key]))) return false;
		return true;
	}
};
/** @internal */
const CommitPrototype$1 = {
	...EffectPrototype$1,
	_op: OP_COMMIT
};
/** @internal */
const StructuralCommitPrototype$1 = {
	...CommitPrototype$1,
	...StructuralPrototype
};
/** @internal */
const Base$1 = /* @__PURE__ */ function() {
	function Base$2() {}
	Base$2.prototype = CommitPrototype$1;
	return Base$2;
}();
/** @internal */
const StructuralBase$1 = /* @__PURE__ */ function() {
	function Base$2() {}
	Base$2.prototype = StructuralCommitPrototype$1;
	return Base$2;
}();

//#endregion
//#region ../../node_modules/.bun/effect@3.17.14/node_modules/effect/dist/esm/internal/option.js
const TypeId$17 = /* @__PURE__ */ Symbol.for("effect/Option");
const CommonProto$1 = {
	...EffectPrototype$1,
	[TypeId$17]: { _A: (_) => _ },
	[NodeInspectSymbol]() {
		return this.toJSON();
	},
	toString() {
		return format(this.toJSON());
	}
};
const SomeProto = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(CommonProto$1), {
	_tag: "Some",
	_op: "Some",
	[symbol](that) {
		return isOption$1(that) && isSome$1(that) && equals(this.value, that.value);
	},
	[symbol$1]() {
		return cached$2(this, combine$11(hash(this._tag))(hash(this.value)));
	},
	toJSON() {
		return {
			_id: "Option",
			_tag: this._tag,
			value: toJSON(this.value)
		};
	}
});
const NoneHash = /* @__PURE__ */ hash("None");
const NoneProto = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(CommonProto$1), {
	_tag: "None",
	_op: "None",
	[symbol](that) {
		return isOption$1(that) && isNone$3(that);
	},
	[symbol$1]() {
		return NoneHash;
	},
	toJSON() {
		return {
			_id: "Option",
			_tag: this._tag
		};
	}
});
/** @internal */
const isOption$1 = (input) => hasProperty(input, TypeId$17);
/** @internal */
const isNone$3 = (fa) => fa._tag === "None";
/** @internal */
const isSome$1 = (fa) => fa._tag === "Some";
/** @internal */
const none$8 = /* @__PURE__ */ Object.create(NoneProto);
/** @internal */
const some$5 = (value) => {
	const a = Object.create(SomeProto);
	a.value = value;
	return a;
};

//#endregion
//#region ../../node_modules/.bun/effect@3.17.14/node_modules/effect/dist/esm/internal/either.js
/**
* @internal
*/
const TypeId$16 = /* @__PURE__ */ Symbol.for("effect/Either");
const CommonProto = {
	...EffectPrototype$1,
	[TypeId$16]: { _R: (_) => _ },
	[NodeInspectSymbol]() {
		return this.toJSON();
	},
	toString() {
		return format(this.toJSON());
	}
};
const RightProto = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(CommonProto), {
	_tag: "Right",
	_op: "Right",
	[symbol](that) {
		return isEither$1(that) && isRight$1(that) && equals(this.right, that.right);
	},
	[symbol$1]() {
		return combine$11(hash(this._tag))(hash(this.right));
	},
	toJSON() {
		return {
			_id: "Either",
			_tag: this._tag,
			right: toJSON(this.right)
		};
	}
});
const LeftProto = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(CommonProto), {
	_tag: "Left",
	_op: "Left",
	[symbol](that) {
		return isEither$1(that) && isLeft$1(that) && equals(this.left, that.left);
	},
	[symbol$1]() {
		return combine$11(hash(this._tag))(hash(this.left));
	},
	toJSON() {
		return {
			_id: "Either",
			_tag: this._tag,
			left: toJSON(this.left)
		};
	}
});
/** @internal */
const isEither$1 = (input) => hasProperty(input, TypeId$16);
/** @internal */
const isLeft$1 = (ma) => ma._tag === "Left";
/** @internal */
const isRight$1 = (ma) => ma._tag === "Right";
/** @internal */
const left$1 = (left$2) => {
	const a = Object.create(LeftProto);
	a.left = left$2;
	return a;
};
/** @internal */
const right$1 = (right$2) => {
	const a = Object.create(RightProto);
	a.right = right$2;
	return a;
};
/** @internal */
const getLeft$2 = (self) => isRight$1(self) ? none$8 : some$5(self.left);
/** @internal */
const getRight$2 = (self) => isLeft$1(self) ? none$8 : some$5(self.right);
/** @internal */
const fromOption$4 = /* @__PURE__ */ dual(2, (self, onNone) => isNone$3(self) ? left$1(onNone()) : right$1(self.value));

//#endregion
//#region ../../node_modules/.bun/effect@3.17.14/node_modules/effect/dist/esm/Either.js
/**
* @category symbols
* @since 2.0.0
*/
const TypeId$15 = TypeId$16;
/**
* Constructs a new `Either` holding a `Right` value. This usually represents a successful value due to the right bias
* of this structure.
*
* @category constructors
* @since 2.0.0
*/
const right = right$1;
/**
* Constructs a new `Either` holding a `Left` value. This usually represents a failure, due to the right-bias of this
* structure.
*
* @category constructors
* @since 2.0.0
*/
const left = left$1;
/**
* @example
* ```ts
* import * as assert from "node:assert"
* import { Either, Option } from "effect"
*
* assert.deepStrictEqual(Either.fromOption(Option.some(1), () => 'error'), Either.right(1))
* assert.deepStrictEqual(Either.fromOption(Option.none(), () => 'error'), Either.left('error'))
* ```
*
* @category constructors
* @since 2.0.0
*/
const fromOption$3 = fromOption$4;
const try_$2 = (evaluate$1) => {
	if (isFunction(evaluate$1)) try {
		return right(evaluate$1());
	} catch (e) {
		return left(e);
	}
	else try {
		return right(evaluate$1.try());
	} catch (e) {
		return left(evaluate$1.catch(e));
	}
};
/**
* Tests if a value is a `Either`.
*
* @example
* ```ts
* import * as assert from "node:assert"
* import { Either } from "effect"
*
* assert.deepStrictEqual(Either.isEither(Either.right(1)), true)
* assert.deepStrictEqual(Either.isEither(Either.left("a")), true)
* assert.deepStrictEqual(Either.isEither({ right: 1 }), false)
* ```
*
* @category guards
* @since 2.0.0
*/
const isEither = isEither$1;
/**
* Determine if a `Either` is a `Left`.
*
* @example
* ```ts
* import * as assert from "node:assert"
* import { Either } from "effect"
*
* assert.deepStrictEqual(Either.isLeft(Either.right(1)), false)
* assert.deepStrictEqual(Either.isLeft(Either.left("a")), true)
* ```
*
* @category guards
* @since 2.0.0
*/
const isLeft = isLeft$1;
/**
* Determine if a `Either` is a `Right`.
*
* @example
* ```ts
* import * as assert from "node:assert"
* import { Either } from "effect"
*
* assert.deepStrictEqual(Either.isRight(Either.right(1)), true)
* assert.deepStrictEqual(Either.isRight(Either.left("a")), false)
* ```
*
* @category guards
* @since 2.0.0
*/
const isRight = isRight$1;
/**
* Converts a `Either` to an `Option` discarding the `Left`.
*
* @example
* ```ts
* import * as assert from "node:assert"
* import { Either, Option } from "effect"
*
* assert.deepStrictEqual(Either.getRight(Either.right('ok')), Option.some('ok'))
* assert.deepStrictEqual(Either.getRight(Either.left('err')), Option.none())
* ```
*
* @category getters
* @since 2.0.0
*/
const getRight$1 = getRight$2;
/**
* Converts a `Either` to an `Option` discarding the value.
*
* @example
* ```ts
* import * as assert from "node:assert"
* import { Either, Option } from "effect"
*
* assert.deepStrictEqual(Either.getLeft(Either.right('ok')), Option.none())
* assert.deepStrictEqual(Either.getLeft(Either.left('err')), Option.some('err'))
* ```
*
* @category getters
* @since 2.0.0
*/
const getLeft$1 = getLeft$2;
/**
* Maps the `Left` side of an `Either` value to a new `Either` value.
*
* @category mapping
* @since 2.0.0
*/
const mapLeft = /* @__PURE__ */ dual(2, (self, f) => isLeft(self) ? left(f(self.left)) : right(self.right));
/**
* Maps the `Right` side of an `Either` value to a new `Either` value.
*
* @category mapping
* @since 2.0.0
*/
const map$16 = /* @__PURE__ */ dual(2, (self, f) => isRight(self) ? right(f(self.right)) : left(self.left));
/**
* Takes two functions and an `Either` value, if the value is a `Left` the inner value is applied to the `onLeft function,
* if the value is a `Right` the inner value is applied to the `onRight` function.
*
* @example
* ```ts
* import * as assert from "node:assert"
* import { pipe, Either } from "effect"
*
* const onLeft  = (strings: ReadonlyArray<string>): string => `strings: ${strings.join(', ')}`
*
* const onRight = (value: number): string => `Ok: ${value}`
*
* assert.deepStrictEqual(pipe(Either.right(1), Either.match({ onLeft, onRight })), 'Ok: 1')
* assert.deepStrictEqual(
*   pipe(Either.left(['string 1', 'string 2']), Either.match({ onLeft, onRight })),
*   'strings: string 1, string 2'
* )
* ```
*
* @category pattern matching
* @since 2.0.0
*/
const match$11 = /* @__PURE__ */ dual(2, (self, { onLeft, onRight }) => isLeft(self) ? onLeft(self.left) : onRight(self.right));
/**
* @category getters
* @since 2.0.0
*/
const merge$6 = /* @__PURE__ */ match$11({
	onLeft: identity,
	onRight: identity
});
/**
* Extracts the value of an `Either` or throws if the `Either` is `Left`.
*
* If a default error is sufficient for your use case and you don't need to configure the thrown error, see {@link getOrThrow}.
*
* @example
* ```ts
* import * as assert from "node:assert"
* import { Either } from "effect"
*
* assert.deepStrictEqual(
*   Either.getOrThrowWith(Either.right(1), () => new Error('Unexpected Left')),
*   1
* )
* assert.throws(() => Either.getOrThrowWith(Either.left("error"), () => new Error('Unexpected Left')))
* ```
*
* @category getters
* @since 2.0.0
*/
const getOrThrowWith$1 = /* @__PURE__ */ dual(2, (self, onLeft) => {
	if (isRight(self)) return self.right;
	throw onLeft(self.left);
});

//#endregion
//#region ../../node_modules/.bun/effect@3.17.14/node_modules/effect/dist/esm/internal/array.js
/**
* @since 2.0.0
*/
/** @internal */
const isNonEmptyArray$1 = (self) => self.length > 0;

//#endregion
//#region ../../node_modules/.bun/effect@3.17.14/node_modules/effect/dist/esm/Order.js
/**
* @category constructors
* @since 2.0.0
*/
const make$44 = (compare$1) => (self, that) => self === that ? 0 : compare$1(self, that);
/**
* @category instances
* @since 2.0.0
*/
const number = /* @__PURE__ */ make$44((self, that) => self < that ? -1 : 1);
/**
* @category instances
* @since 2.0.0
*/
const boolean = /* @__PURE__ */ make$44((self, that) => self < that ? -1 : 1);
/**
* @category mapping
* @since 2.0.0
*/
const mapInput = /* @__PURE__ */ dual(2, (self, f) => make$44((b1, b2) => self(f(b1), f(b2))));
/**
* @category combining
* @since 2.0.0
*/
const all$4 = (collection) => {
	return make$44((x, y) => {
		const len = Math.min(x.length, y.length);
		let collectionLength = 0;
		for (const O of collection) {
			if (collectionLength >= len) break;
			const o = O(x[collectionLength], y[collectionLength]);
			if (o !== 0) return o;
			collectionLength++;
		}
		return 0;
	});
};
/**
* Similar to `Promise.all` but operates on `Order`s.
*
* ```
* [Order<A>, Order<B>, ...] -> Order<[A, B, ...]>
* ```
*
* This function creates and returns a new `Order` for a tuple of values based on the given `Order`s for each element in the tuple.
* The returned `Order` compares two tuples of the same type by applying the corresponding `Order` to each element in the tuple.
* It is useful when you need to compare two tuples of the same type and you have a specific way of comparing each element
* of the tuple.
*
* @category combinators
* @since 2.0.0
*/
const tuple = (...elements) => all$4(elements);
/**
* This function creates and returns a new `Order` for an array of values based on a given `Order` for the elements of the array.
* The returned `Order` compares two arrays by applying the given `Order` to each element in the arrays.
* If all elements are equal, the arrays are then compared based on their length.
* It is useful when you need to compare two arrays of the same type and you have a specific way of comparing each element of the array.
*
* @category combinators
* @since 2.0.0
*/
const array = (O) => make$44((self, that) => {
	const aLen = self.length;
	const bLen = that.length;
	const len = Math.min(aLen, bLen);
	for (let i = 0; i < len; i++) {
		const o = O(self[i], that[i]);
		if (o !== 0) return o;
	}
	return number(aLen, bLen);
});
/**
* This function creates and returns a new `Order` for a struct of values based on the given `Order`s
* for each property in the struct.
*
* @category combinators
* @since 2.0.0
*/
const struct$2 = (fields) => {
	const keys$5 = Object.keys(fields);
	return make$44((self, that) => {
		for (const key of keys$5) {
			const o = fields[key](self[key], that[key]);
			if (o !== 0) return o;
		}
		return 0;
	});
};
/**
* Test whether one value is _strictly greater than_ another.
*
* @since 2.0.0
*/
const greaterThan$3 = (O) => dual(2, (self, that) => O(self, that) === 1);

//#endregion
//#region ../../node_modules/.bun/effect@3.17.14/node_modules/effect/dist/esm/Option.js
/**
* Represents the absence of a value by creating an empty `Option`.
*
* `Option.none` returns an `Option<never>`, which is a subtype of `Option<A>`.
* This means you can use it in place of any `Option<A>` regardless of the type
* `A`.
*
* **Example** (Creating an Option with No Value)
*
* ```ts
* import { Option } from "effect"
*
* // An Option holding no value
* //
* //      ┌─── Option<never>
* //      ▼
* const noValue = Option.none()
*
* console.log(noValue)
* // Output: { _id: 'Option', _tag: 'None' }
* ```
*
* @see {@link some} for the opposite operation.
*
* @category Constructors
* @since 2.0.0
*/
const none$7 = () => none$8;
/**
* Wraps the given value into an `Option` to represent its presence.
*
* **Example** (Creating an Option with a Value)
*
* ```ts
* import { Option } from "effect"
*
* // An Option holding the number 1
* //
* //      ┌─── Option<number>
* //      ▼
* const value = Option.some(1)
*
* console.log(value)
* // Output: { _id: 'Option', _tag: 'Some', value: 1 }
* ```
*
* @see {@link none} for the opposite operation.
*
* @category Constructors
* @since 2.0.0
*/
const some$4 = some$5;
/**
* Determines whether the given value is an `Option`.
*
* **Details**
*
* This function checks if a value is an instance of `Option`. It returns `true`
* if the value is either `Option.some` or `Option.none`, and `false` otherwise.
* This is particularly useful when working with unknown values or when you need
* to ensure type safety in your code.
*
* @example
* ```ts
* import { Option } from "effect"
*
* console.log(Option.isOption(Option.some(1)))
* // Output: true
*
* console.log(Option.isOption(Option.none()))
* // Output: true
*
* console.log(Option.isOption({}))
* // Output: false
* ```
*
* @category Guards
* @since 2.0.0
*/
const isOption = isOption$1;
/**
* Checks whether an `Option` represents the absence of a value (`None`).
*
* @example
* ```ts
* import { Option } from "effect"
*
* console.log(Option.isNone(Option.some(1)))
* // Output: false
*
* console.log(Option.isNone(Option.none()))
* // Output: true
* ```
*
* @see {@link isSome} for the opposite check.
*
* @category Guards
* @since 2.0.0
*/
const isNone$2 = isNone$3;
/**
* Checks whether an `Option` contains a value (`Some`).
*
* @example
* ```ts
* import { Option } from "effect"
*
* console.log(Option.isSome(Option.some(1)))
* // Output: true
*
* console.log(Option.isSome(Option.none()))
* // Output: false
* ```
*
* @see {@link isNone} for the opposite check.
*
* @category Guards
* @since 2.0.0
*/
const isSome = isSome$1;
/**
* Performs pattern matching on an `Option` to handle both `Some` and `None`
* cases.
*
* **Details**
*
* This function allows you to match against an `Option` and handle both
* scenarios: when the `Option` is `None` (i.e., contains no value), and when
* the `Option` is `Some` (i.e., contains a value). It executes one of the
* provided functions based on the case:
*
* - If the `Option` is `None`, the `onNone` function is executed and its result
*   is returned.
* - If the `Option` is `Some`, the `onSome` function is executed with the
*   contained value, and its result is returned.
*
* This function provides a concise and functional way to handle optional values
* without resorting to `if` or manual checks, making your code more declarative
* and readable.
*
* **Example** (Pattern Matching with Option)
*
* ```ts
* import { Option } from "effect"
*
* const foo = Option.some(1)
*
* const message = Option.match(foo, {
*   onNone: () => "Option is empty",
*   onSome: (value) => `Option has a value: ${value}`
* })
*
* console.log(message)
* // Output: "Option has a value: 1"
* ```
*
* @category Pattern matching
* @since 2.0.0
*/
const match$10 = /* @__PURE__ */ dual(2, (self, { onNone, onSome }) => isNone$2(self) ? onNone() : onSome(self.value));
/**
* Converts an `Either` into an `Option` by discarding the error and extracting
* the right value.
*
* **Details**
*
* This function takes an `Either` and returns an `Option` based on its value:
*
* - If the `Either` is a `Right`, its value is wrapped in a `Some` and
*   returned.
* - If the `Either` is a `Left`, the error is discarded, and `None` is
*   returned.
*
* This is particularly useful when you only care about the success case
* (`Right`) of an `Either` and want to handle the result using `Option`. By
* using this function, you can convert `Either` into a simpler structure for
* cases where error handling is not required.
*
* @example
* ```ts
* import { Either, Option } from "effect"
*
* console.log(Option.getRight(Either.right("ok")))
* // Output: { _id: 'Option', _tag: 'Some', value: 'ok' }
*
* console.log(Option.getRight(Either.left("err")))
* // Output: { _id: 'Option', _tag: 'None' }
* ```
*
* @see {@link getLeft} for the opposite operation.
*
* @category Conversions
* @since 2.0.0
*/
const getRight = getRight$2;
/**
* Converts an `Either` into an `Option` by discarding the right value and
* extracting the left value.
*
* **Details**
*
* This function transforms an `Either` into an `Option` as follows:
*
* - If the `Either` is a `Left`, its value is wrapped in a `Some` and returned.
* - If the `Either` is a `Right`, the value is discarded, and `None` is
*   returned.
*
* This utility is useful when you only care about the error case (`Left`) of an
* `Either` and want to handle it as an `Option`. By discarding the right value,
* it simplifies error-focused workflows.
*
* @example
* ```ts
* import { Either, Option } from "effect"
*
* console.log(Option.getLeft(Either.right("ok")))
* // Output: { _id: 'Option', _tag: 'None' }
*
* console.log(Option.getLeft(Either.left("err")))
* // Output: { _id: 'Option', _tag: 'Some', value: 'err' }
* ```
*
* @see {@link getRight} for the opposite operation.
*
* @category Conversions
* @since 2.0.0
*/
const getLeft = getLeft$2;
/**
* Returns the value contained in the `Option` if it is `Some`, otherwise
* evaluates and returns the result of `onNone`.
*
* **Details**
*
* This function allows you to provide a fallback value or computation for when
* an `Option` is `None`. If the `Option` contains a value (`Some`), that value
* is returned. If it is empty (`None`), the `onNone` function is executed, and
* its result is returned instead.
*
* This utility is helpful for safely handling `Option` values by ensuring you
* always receive a meaningful result, whether or not the `Option` contains a
* value. It is particularly useful for providing default values or alternative
* logic when working with optional values.
*
* @example
* ```ts
* import { Option } from "effect"
*
* console.log(Option.some(1).pipe(Option.getOrElse(() => 0)))
* // Output: 1
*
* console.log(Option.none().pipe(Option.getOrElse(() => 0)))
* // Output: 0
* ```
*
* @see {@link getOrNull} for a version that returns `null` instead of executing a function.
* @see {@link getOrUndefined} for a version that returns `undefined` instead of executing a function.
*
* @category Getters
* @since 2.0.0
*/
const getOrElse$5 = /* @__PURE__ */ dual(2, (self, onNone) => isNone$2(self) ? onNone() : self.value);
/**
* Returns the provided `Option` `that` if the current `Option` (`self`) is
* `None`; otherwise, it returns `self`.
*
* **Details**
*
* This function provides a fallback mechanism for `Option` values. If the
* current `Option` is `None` (i.e., it contains no value), the `that` function
* is evaluated, and its resulting `Option` is returned. If the current `Option`
* is `Some` (i.e., it contains a value), the original `Option` is returned
* unchanged.
*
* This is particularly useful for chaining fallback values or computations,
* allowing you to provide alternative `Option` values when the first one is
* empty.
*
* @example
* ```ts
* import { Option } from "effect"
*
* console.log(Option.none().pipe(Option.orElse(() => Option.none())))
* // Output: { _id: 'Option', _tag: 'None' }
*
* console.log(Option.some("a").pipe(Option.orElse(() => Option.none())))
* // Output: { _id: 'Option', _tag: 'Some', value: 'a' }
*
* console.log(Option.none().pipe(Option.orElse(() => Option.some("b"))))
* // Output: { _id: 'Option', _tag: 'Some', value: 'b' }
*
* console.log(Option.some("a").pipe(Option.orElse(() => Option.some("b"))))
* // Output: { _id: 'Option', _tag: 'Some', value: 'a' }
* ```
*
* @category Error handling
* @since 2.0.0
*/
const orElse$5 = /* @__PURE__ */ dual(2, (self, that) => isNone$2(self) ? that() : self);
/**
* Returns the provided default value wrapped in `Some` if the current `Option`
* (`self`) is `None`; otherwise, returns `self`.
*
* **Details**
*
* This function provides a way to supply a default value for cases where an
* `Option` is `None`. If the current `Option` is empty (`None`), the `onNone`
* function is executed to compute the default value, which is then wrapped in a
* `Some`. If the current `Option` contains a value (`Some`), it is returned as
* is.
*
* This is particularly useful for handling optional values where a fallback
* default needs to be provided explicitly in case of absence.
*
* @example
* ```ts
* import { Option } from "effect"
*
* console.log(Option.none().pipe(Option.orElseSome(() => "b")))
* // Output: { _id: 'Option', _tag: 'Some', value: 'b' }
*
* console.log(Option.some("a").pipe(Option.orElseSome(() => "b")))
* // Output: { _id: 'Option', _tag: 'Some', value: 'a' }
* ```
*
* @category Error handling
* @since 2.0.0
*/
const orElseSome = /* @__PURE__ */ dual(2, (self, onNone) => isNone$2(self) ? some$4(onNone()) : self);
/**
* Converts a nullable value into an `Option`. Returns `None` if the value is
* `null` or `undefined`, otherwise wraps the value in a `Some`.
*
* @example
* ```ts
* import { Option } from "effect"
*
* console.log(Option.fromNullable(undefined))
* // Output: { _id: 'Option', _tag: 'None' }
*
* console.log(Option.fromNullable(null))
* // Output: { _id: 'Option', _tag: 'None' }
*
* console.log(Option.fromNullable(1))
* // Output: { _id: 'Option', _tag: 'Some', value: 1 }
* ```
*
* @category Conversions
* @since 2.0.0
*/
const fromNullable$2 = (nullableValue) => nullableValue == null ? none$7() : some$4(nullableValue);
/**
* Returns the value contained in the `Option` if it is `Some`; otherwise,
* returns `undefined`.
*
* **Details**
*
* This function provides a way to extract the value of an `Option` while
* falling back to `undefined` if the `Option` is `None`.
*
* It is particularly useful in scenarios where `undefined` is an acceptable
* placeholder for the absence of a value, such as when interacting with APIs or
* systems that use `undefined` as a default for missing values.
*
* @example
* ```ts
* import { Option } from "effect"
*
* console.log(Option.getOrUndefined(Option.some(1)))
* // Output: 1
*
* console.log(Option.getOrUndefined(Option.none()))
* // Output: undefined
* ```
*
* @category Getters
* @since 2.0.0
*/
const getOrUndefined = /* @__PURE__ */ getOrElse$5(constUndefined);
/**
* Lifts a function that throws exceptions into a function that returns an
* `Option`.
*
* **Details**
*
* This utility function takes a function `f` that might throw an exception and
* transforms it into a safer function that returns an `Option`. If the original
* function executes successfully, the result is wrapped in a `Some`. If an
* exception is thrown, the result is `None`, allowing the developer to handle
* errors in a functional, type-safe way.
*
* @example
* ```ts
* import { Option } from "effect"
*
* const parse = Option.liftThrowable(JSON.parse)
*
* console.log(parse("1"))
* // Output: { _id: 'Option', _tag: 'Some', value: 1 }
*
* console.log(parse(""))
* // Output: { _id: 'Option', _tag: 'None' }
* ```
*
* @category Conversions
* @since 2.0.0
*/
const liftThrowable = (f) => (...a) => {
	try {
		return some$4(f(...a));
	} catch {
		return none$7();
	}
};
/**
* Extracts the value of an `Option` or throws an error if the `Option` is
* `None`, using a custom error factory.
*
* **Details**
*
* This function allows you to extract the value of an `Option` when it is
* `Some`. If the `Option` is `None`, it throws an error generated by the
* provided `onNone` function. This utility is particularly useful when you need
* a fail-fast behavior for empty `Option` values and want to provide a custom
* error message or object.
*
* @example
* ```ts
* import * as assert from "node:assert"
* import { Option } from "effect"
*
* assert.deepStrictEqual(
*   Option.getOrThrowWith(Option.some(1), () => new Error('Unexpected None')),
*   1
* )
* assert.throws(() => Option.getOrThrowWith(Option.none(), () => new Error('Unexpected None')))
* ```
*
* @see {@link getOrThrow} for a version that throws a default error.
*
* @category Conversions
* @since 2.0.0
*/
const getOrThrowWith = /* @__PURE__ */ dual(2, (self, onNone) => {
	if (isSome(self)) return self.value;
	throw onNone();
});
/**
* Extracts the value of an `Option` or throws a default error if the `Option`
* is `None`.
*
* **Details**
*
* This function extracts the value from an `Option` if it is `Some`. If the
* `Option` is `None`, it throws a default error. It is useful for fail-fast
* scenarios where the absence of a value is treated as an exceptional case and
* a default error is sufficient.
*
* @example
* ```ts
* import * as assert from "node:assert"
* import { Option } from "effect"
*
* assert.deepStrictEqual(Option.getOrThrow(Option.some(1)), 1)
* assert.throws(() => Option.getOrThrow(Option.none()))
* ```
*
* @see {@link getOrThrowWith} for a version that allows you to provide a custom error.
*
* @category Conversions
* @since 2.0.0
*/
const getOrThrow = /* @__PURE__ */ getOrThrowWith(() => /* @__PURE__ */ new Error("getOrThrow called on a None"));
/**
* Transforms the value inside a `Some` to a new value using the provided
* function, while leaving `None` unchanged.
*
* **Details**
*
* This function applies a mapping function `f` to the value inside an `Option`
* if it is a `Some`. If the `Option` is `None`, it remains unchanged. The
* result is a new `Option` with the transformed value (if it was a `Some`) or
* still `None`.
*
* This utility is particularly useful for chaining transformations in a
* functional way without needing to manually handle `None` cases.
*
* @example
* ```ts
* import { Option } from "effect"
*
* // Mapping over a `Some`
* const someValue = Option.some(2)
*
* console.log(Option.map(someValue, (n) => n * 2))
* // Output: { _id: 'Option', _tag: 'Some', value: 4 }
*
* // Mapping over a `None`
* const noneValue = Option.none<number>()
*
* console.log(Option.map(noneValue, (n) => n * 2))
* // Output: { _id: 'Option', _tag: 'None' }
* ```
*
* @category Mapping
* @since 2.0.0
*/
const map$15 = /* @__PURE__ */ dual(2, (self, f) => isNone$2(self) ? none$7() : some$4(f(self.value)));
/**
* Applies a function to the value of a `Some` and flattens the resulting
* `Option`. If the input is `None`, it remains `None`.
*
* **Details**
*
* This function allows you to chain computations that return `Option` values.
* If the input `Option` is `Some`, the provided function `f` is applied to the
* contained value, and the resulting `Option` is returned. If the input is
* `None`, the function is not applied, and the result remains `None`.
*
* This utility is particularly useful for sequencing operations that may fail
* or produce optional results, enabling clean and concise workflows for
* handling such cases.
*
* @example
* ```ts
* import { Option } from "effect"
*
* interface Address {
*   readonly city: string
*   readonly street: Option.Option<string>
* }
*
* interface User {
*   readonly id: number
*   readonly username: string
*   readonly email: Option.Option<string>
*   readonly address: Option.Option<Address>
* }
*
* const user: User = {
*   id: 1,
*   username: "john_doe",
*   email: Option.some("john.doe@example.com"),
*   address: Option.some({
*     city: "New York",
*     street: Option.some("123 Main St")
*   })
* }
*
* // Use flatMap to extract the street value
* const street = user.address.pipe(
*   Option.flatMap((address) => address.street)
* )
*
* console.log(street)
* // Output: { _id: 'Option', _tag: 'Some', value: '123 Main St' }
* ```
*
* @category Sequencing
* @since 2.0.0
*/
const flatMap$11 = /* @__PURE__ */ dual(2, (self, f) => isNone$2(self) ? none$7() : f(self.value));
/**
* Converts an `Option` into an `Array`.
* If the input is `None`, an empty array is returned.
* If the input is `Some`, its value is wrapped in a single-element array.
*
* @example
* ```ts
* import { Option } from "effect"
*
* console.log(Option.toArray(Option.some(1)))
* // Output: [1]
*
* console.log(Option.toArray(Option.none()))
* // Output: []
* ```
*
* @category Conversions
* @since 2.0.0
*/
const toArray$1 = (self) => isNone$2(self) ? [] : [self.value];
/**
* Alias of {@link flatMap}.
*
* @example
* ```ts
* import { Option } from "effect"
*
* // Transform and filter numbers
* const transformEven = (n: Option.Option<number>): Option.Option<string> =>
*   Option.filterMap(n, (n) => (n % 2 === 0 ? Option.some(`Even: ${n}`) : Option.none()))
*
* console.log(transformEven(Option.none()))
* // Output: { _id: 'Option', _tag: 'None' }
*
* console.log(transformEven(Option.some(1)))
* // Output: { _id: 'Option', _tag: 'None' }
*
* console.log(transformEven(Option.some(2)))
* // Output: { _id: 'Option', _tag: 'Some', value: 'Even: 2' }
* ```
*
* @category Filtering
* @since 2.0.0
*/
const filterMap$5 = flatMap$11;
/**
* Returns a function that checks if an `Option` contains a specified value,
* using a provided equivalence function.
*
* **Details**
*
* This function allows you to check whether an `Option` contains a specific
* value. It uses an equivalence function `isEquivalent` to compare the value
* inside the `Option` to the provided value. If the `Option` is `Some` and the
* equivalence function returns `true`, the result is `true`. If the `Option` is
* `None` or the values are not equivalent, the result is `false`.
*
* @example
* ```ts
* import { Number, Option } from "effect"
*
* const contains = Option.containsWith(Number.Equivalence)
*
* console.log(Option.some(2).pipe(contains(2)))
* // Output: true
*
* console.log(Option.some(1).pipe(contains(2)))
* // Output: false
*
* console.log(Option.none().pipe(contains(2)))
* // Output: false
* ```
*
* @see {@link contains} for a version that uses the default `Equivalence`.
*
* @category Elements
* @since 2.0.0
*/
const containsWith$2 = (isEquivalent) => dual(2, (self, a) => isNone$2(self) ? false : isEquivalent(self.value, a));
const _equivalence$3 = /* @__PURE__ */ equivalence();
/**
* Returns a function that checks if an `Option` contains a specified value
* using the default `Equivalence`.
*
* **Details**
*
* This function allows you to check whether an `Option` contains a specific
* value. It uses the default `Equivalence` for equality comparison. If the
* `Option` is `Some` and its value is equivalent to the provided value, the
* result is `true`. If the `Option` is `None` or the values are not equivalent,
* the result is `false`.
*
* @example
* ```ts
* import { Option } from "effect"
*
* console.log(Option.some(2).pipe(Option.contains(2)))
* // Output: true
*
* console.log(Option.some(1).pipe(Option.contains(2)))
* // Output: false
*
* console.log(Option.none().pipe(Option.contains(2)))
* // Output: false
* ```
*
* @see {@link containsWith} for a version that allows you to specify a custom equivalence function.
*
* @category Elements
* @since 2.0.0
*/
const contains$2 = /* @__PURE__ */ containsWith$2(_equivalence$3);
/**
* Checks if a value in an `Option` satisfies a given predicate or refinement.
*
* **Details**
*
* This function allows you to check if a value inside a `Some` meets a
* specified condition. If the `Option` is `None`, the result is `false`. If the
* `Option` is `Some`, the provided predicate or refinement is applied to the
* value:
*
* - If the condition is met, the result is `true`.
* - If the condition is not met, the result is `false`.
*
* @example
* ```ts
* import { Option } from "effect"
*
* const isEven = (n: number) => n % 2 === 0
*
* console.log(Option.some(2).pipe(Option.exists(isEven)))
* // Output: true
*
* console.log(Option.some(1).pipe(Option.exists(isEven)))
* // Output: false
*
* console.log(Option.none().pipe(Option.exists(isEven)))
* // Output: false
* ```
*
* @category Elements
* @since 2.0.0
*/
const exists$3 = /* @__PURE__ */ dual(2, (self, refinement) => isNone$2(self) ? false : refinement(self.value));
/**
* Merges two optional values, applying a function if both exist.
* Unlike {@link zipWith}, this function returns `None` only if both inputs are `None`.
*
* @internal
*/
const mergeWith = (f) => (o1, o2) => {
	if (isNone$2(o1)) return o2;
	else if (isNone$2(o2)) return o1;
	return some$4(f(o1.value, o2.value));
};

//#endregion
//#region ../../node_modules/.bun/effect@3.17.14/node_modules/effect/dist/esm/Tuple.js
/**
* Constructs a new tuple from the provided values.
*
* @example
* ```ts
* import * as assert from "node:assert"
* import { make } from "effect/Tuple"
*
* assert.deepStrictEqual(make(1, 'hello', true), [1, 'hello', true])
* ```
*
* @category constructors
* @since 2.0.0
*/
const make$43 = (...elements) => elements;
/**
* Given a tuple of `Equivalence`s returns a new `Equivalence` that compares values of a tuple
* by applying each `Equivalence` to the corresponding element of the tuple.
*
* @category combinators
* @since 2.0.0
*/
const getEquivalence$4 = tuple$1;
/**
* This function creates and returns a new `Order` for a tuple of values based on the given `Order`s for each element in the tuple.
* The returned `Order` compares two tuples of the same type by applying the corresponding `Order` to each element in the tuple.
* It is useful when you need to compare two tuples of the same type and you have a specific way of comparing each element
* of the tuple.
*
* @category combinators
* @since 2.0.0
*/
const getOrder$4 = tuple;

//#endregion
//#region ../../node_modules/.bun/effect@3.17.14/node_modules/effect/dist/esm/Iterable.js
/**
* Returns the first element that satisfies the specified
* predicate, or `None` if no such element exists.
*
* @category elements
* @since 2.0.0
*/
const findFirst$8 = /* @__PURE__ */ dual(2, (self, f) => {
	let i = 0;
	for (const a of self) {
		const o = f(a, i);
		if (isBoolean$1(o)) {
			if (o) return some$4(a);
		} else if (isSome(o)) return o;
		i++;
	}
	return none$7();
});

//#endregion
//#region ../../node_modules/.bun/effect@3.17.14/node_modules/effect/dist/esm/Record.js
/**
* Transforms the values of a record into an `Array` with a custom mapping function.
*
* @example
* ```ts
* import * as assert from "node:assert"
* import { collect } from "effect/Record"
*
* const x = { a: 1, b: 2, c: 3 }
* assert.deepStrictEqual(collect(x, (key, n) => [key, n]), [["a", 1], ["b", 2], ["c", 3]])
* ```
*
* @category conversions
* @since 2.0.0
*/
const collect = /* @__PURE__ */ dual(2, (self, f) => {
	const out = [];
	for (const key of keys$4(self)) out.push(f(key, self[key]));
	return out;
});
/**
* Takes a record and returns an array of tuples containing its keys and values.
*
* @example
* ```ts
* import * as assert from "node:assert"
* import { toEntries } from "effect/Record"
*
* const x = { a: 1, b: 2, c: 3 }
* assert.deepStrictEqual(toEntries(x), [["a", 1], ["b", 2], ["c", 3]])
* ```
*
* @category conversions
* @since 2.0.0
*/
const toEntries = /* @__PURE__ */ collect((key, value) => [key, value]);
/**
* Retrieve the keys of a given record as an array.
*
* @since 2.0.0
*/
const keys$4 = (self) => Object.keys(self);

//#endregion
//#region ../../node_modules/.bun/effect@3.17.14/node_modules/effect/dist/esm/Array.js
/**
* Creates a new `Array` of the specified length.
*
* **Example**
*
* ```ts
* import { Array } from "effect"
*
* const result = Array.allocate<number>(3)
* console.log(result) // [ <3 empty items> ]
* ```
*
* @category constructors
* @since 2.0.0
*/
const allocate = (n) => new Array(n);
/**
* Return a `NonEmptyArray` of length `n` with element `i` initialized with `f(i)`.
*
* **Note**. `n` is normalized to an integer >= 1.
*
* **Example**
*
* ```ts
* import { makeBy } from "effect/Array"
*
* const result = makeBy(5, n => n * 2)
* console.log(result) // [0, 2, 4, 6, 8]
* ```
*
* @category constructors
* @since 2.0.0
*/
const makeBy = /* @__PURE__ */ dual(2, (n, f) => {
	const max$4 = Math.max(1, Math.floor(n));
	const out = new Array(max$4);
	for (let i = 0; i < max$4; i++) out[i] = f(i);
	return out;
});
/**
* Creates a new `Array` from an iterable collection of values.
* If the input is already an array, it returns the input as-is.
* Otherwise, it converts the iterable collection to an array.
*
* **Example**
*
* ```ts
* import { Array } from "effect"
*
* const result = Array.fromIterable(new Set([1, 2, 3]))
* console.log(result) // [1, 2, 3]
* ```
*
* @category constructors
* @since 2.0.0
*/
const fromIterable$10 = (collection) => Array.isArray(collection) ? collection : Array.from(collection);
/**
* Creates a new `Array` from a value that might not be an iterable.
*
* **Example**
*
* ```ts
* import { Array } from "effect"
*
* console.log(Array.ensure("a")) // ["a"]
* console.log(Array.ensure(["a"])) // ["a"]
* console.log(Array.ensure(["a", "b", "c"])) // ["a", "b", "c"]
* ```
*
* @category constructors
* @since 3.3.0
*/
const ensure = (self) => Array.isArray(self) ? self : [self];
/**
* Takes a record and returns an array of tuples containing its keys and values.
*
* **Example**
*
* ```ts
* import { Array } from "effect"
*
* const result = Array.fromRecord({ a: 1, b: 2, c: 3 })
* console.log(result) // [["a", 1], ["b", 2], ["c", 3]]
* ```
*
* @category conversions
* @since 2.0.0
*/
const fromRecord = toEntries;
/**
* Converts an `Option` to an array.
*
* **Example**
*
* ```ts
* import { Array, Option } from "effect"
*
* console.log(Array.fromOption(Option.some(1))) // [1]
* console.log(Array.fromOption(Option.none())) // []
* ```
*
* @category conversions
* @since 2.0.0
*/
const fromOption$2 = toArray$1;
/**
* Matches the elements of an array from the left, applying functions to cases of empty and non-empty arrays.
*
* **Example**
*
* ```ts
* import { Array } from "effect"
*
* const matchLeft = Array.matchLeft({
*   onEmpty: () => "empty",
*   onNonEmpty: (head, tail) => `head: ${head}, tail: ${tail.length}`
* })
* console.log(matchLeft([])) // "empty"
* console.log(matchLeft([1, 2, 3])) // "head: 1, tail: 2"
* ```
*
* @category pattern matching
* @since 2.0.0
*/
const matchLeft = /* @__PURE__ */ dual(2, (self, { onEmpty, onNonEmpty }) => isNonEmptyReadonlyArray(self) ? onNonEmpty(headNonEmpty$1(self), tailNonEmpty$1(self)) : onEmpty());
/**
* Prepend an element to the front of an `Iterable`, creating a new `NonEmptyArray`.
*
* **Example**
*
* ```ts
* import { Array } from "effect"
*
* const result = Array.prepend([2, 3, 4], 1)
* console.log(result) // [1, 2, 3, 4]
* ```
*
* @category concatenating
* @since 2.0.0
*/
const prepend$2 = /* @__PURE__ */ dual(2, (self, head$4) => [head$4, ...self]);
/**
* Append an element to the end of an `Iterable`, creating a new `NonEmptyArray`.
*
* **Example**
*
* ```ts
* import { Array } from "effect"
*
* const result = Array.append([1, 2, 3], 4);
* console.log(result) // [1, 2, 3, 4]
* ```
*
* @category concatenating
* @since 2.0.0
*/
const append$2 = /* @__PURE__ */ dual(2, (self, last$3) => [...self, last$3]);
/**
* Concatenates two arrays (or iterables), combining their elements.
* If either array is non-empty, the result is also a non-empty array.
*
* @category concatenating
* @since 2.0.0
*/
const appendAll$2 = /* @__PURE__ */ dual(2, (self, that) => fromIterable$10(self).concat(fromIterable$10(that)));
/**
* Determine if `unknown` is an Array.
*
* **Example**
*
* ```ts
* import { Array } from "effect"
*
* console.log(Array.isArray(null)) // false
* console.log(Array.isArray([1, 2, 3])) // true
* ```
*
* @category guards
* @since 2.0.0
*/
const isArray = Array.isArray;
/**
* Determine if an `Array` is empty narrowing down the type to `[]`.
*
* **Example**
*
* ```ts
* import { Array } from "effect"
*
* console.log(Array.isEmptyArray([])) // true
* console.log(Array.isEmptyArray([1, 2, 3])) // false
* ```
*
* @category guards
* @since 2.0.0
*/
const isEmptyArray = (self) => self.length === 0;
/**
* Determine if a `ReadonlyArray` is empty narrowing down the type to `readonly []`.
*
* **Example**
*
* ```ts
* import { Array } from "effect"
*
* console.log(Array.isEmptyReadonlyArray([])) // true
* console.log(Array.isEmptyReadonlyArray([1, 2, 3])) // false
* ```
*
* @category guards
* @since 2.0.0
*/
const isEmptyReadonlyArray = isEmptyArray;
/**
* Determine if an `Array` is non empty narrowing down the type to `NonEmptyArray`.
*
* An `Array` is considered to be a `NonEmptyArray` if it contains at least one element.
*
* **Example**
*
* ```ts
* import { Array } from "effect"
*
* console.log(Array.isNonEmptyArray([])) // false
* console.log(Array.isNonEmptyArray([1, 2, 3])) // true
* ```
*
* @category guards
* @since 2.0.0
*/
const isNonEmptyArray = isNonEmptyArray$1;
/**
* Determine if a `ReadonlyArray` is non empty narrowing down the type to `NonEmptyReadonlyArray`.
*
* A `ReadonlyArray` is considered to be a `NonEmptyReadonlyArray` if it contains at least one element.
*
* **Example**
*
* ```ts
* import { Array } from "effect"
*
* console.log(Array.isNonEmptyReadonlyArray([])) // false
* console.log(Array.isNonEmptyReadonlyArray([1, 2, 3])) // true
* ```
*
* @category guards
* @since 2.0.0
*/
const isNonEmptyReadonlyArray = isNonEmptyArray$1;
const isOutOfBounds = (i, as$4) => i < 0 || i >= as$4.length;
const clamp = (i, as$4) => Math.floor(Math.min(Math.max(0, i), as$4.length));
/**
* This function provides a safe way to read a value at a particular index from a `ReadonlyArray`.
*
* @category getters
* @since 2.0.0
*/
const get$11 = /* @__PURE__ */ dual(2, (self, index) => {
	const i = Math.floor(index);
	return isOutOfBounds(i, self) ? none$7() : some$4(self[i]);
});
/**
* Gets an element unsafely, will throw on out of bounds.
*
* @since 2.0.0
* @category unsafe
*/
const unsafeGet$5 = /* @__PURE__ */ dual(2, (self, index) => {
	const i = Math.floor(index);
	if (isOutOfBounds(i, self)) throw new Error(`Index ${i} out of bounds`);
	return self[i];
});
/**
* Get the first element of a `ReadonlyArray`, or `None` if the `ReadonlyArray` is empty.
*
* @category getters
* @since 2.0.0
*/
const head$3 = /* @__PURE__ */ get$11(0);
/**
* Get the first element of a non empty array.
*
* **Example**
*
* ```ts
* import { Array } from "effect"
*
* const result = Array.headNonEmpty([1, 2, 3, 4])
* console.log(result) // 1
* ```
*
* @category getters
* @since 2.0.0
*/
const headNonEmpty$1 = /* @__PURE__ */ unsafeGet$5(0);
/**
* Get the last element in a `ReadonlyArray`, or `None` if the `ReadonlyArray` is empty.
*
* @category getters
* @since 2.0.0
*/
const last$2 = (self) => isNonEmptyReadonlyArray(self) ? some$4(lastNonEmpty(self)) : none$7();
/**
* Get the last element of a non empty array.
*
* **Example**
*
* ```ts
* import { Array } from "effect"
*
* const result = Array.lastNonEmpty([1, 2, 3, 4])
* console.log(result) // 4
* ```
*
* @category getters
* @since 2.0.0
*/
const lastNonEmpty = (self) => self[self.length - 1];
/**
* Get all but the first element of a `NonEmptyReadonlyArray`.
*
* **Example**
*
* ```ts
* import { Array } from "effect"
*
* const result = Array.tailNonEmpty([1, 2, 3, 4])
* console.log(result) // [2, 3, 4]
* ```
*
* @category getters
* @since 2.0.0
*/
const tailNonEmpty$1 = (self) => self.slice(1);
const spanIndex = (self, predicate) => {
	let i = 0;
	for (const a of self) {
		if (!predicate(a, i)) break;
		i++;
	}
	return i;
};
/**
* Split an `Iterable` into two parts:
*
* 1. the longest initial subarray for which all elements satisfy the specified predicate
* 2. the remaining elements
*
* @category splitting
* @since 2.0.0
*/
const span = /* @__PURE__ */ dual(2, (self, predicate) => splitAt(self, spanIndex(self, predicate)));
/**
* Drop a max number of elements from the start of an `Iterable`, creating a new `Array`.
*
* **Note**. `n` is normalized to a non negative integer.
*
* **Example**
*
* ```ts
* import { Array } from "effect"
*
* const result = Array.drop([1, 2, 3, 4, 5], 2)
* console.log(result) // [3, 4, 5]
* ```
*
* @category getters
* @since 2.0.0
*/
const drop$1 = /* @__PURE__ */ dual(2, (self, n) => {
	const input = fromIterable$10(self);
	return input.slice(clamp(n, input), input.length);
});
/**
* Return the first index for which a predicate holds.
*
* **Example**
*
* ```ts
* import { Array } from "effect"
*
* const result = Array.findFirstIndex([5, 3, 8, 9], x => x > 5)
* console.log(result) // Option.some(2)
* ```
*
* @category elements
* @since 2.0.0
*/
const findFirstIndex$1 = /* @__PURE__ */ dual(2, (self, predicate) => {
	let i = 0;
	for (const a of self) {
		if (predicate(a, i)) return some$4(i);
		i++;
	}
	return none$7();
});
/**
* Return the last index for which a predicate holds.
*
* **Example**
*
* ```ts
* import { Array } from "effect"
*
* const result = Array.findLastIndex([1, 3, 8, 9], x => x < 5)
* console.log(result) // Option.some(1)
* ```
*
* @category elements
* @since 2.0.0
*/
const findLastIndex$1 = /* @__PURE__ */ dual(2, (self, predicate) => {
	const input = fromIterable$10(self);
	for (let i = input.length - 1; i >= 0; i--) if (predicate(input[i], i)) return some$4(i);
	return none$7();
});
/**
* Returns the first element that satisfies the specified
* predicate, or `None` if no such element exists.
*
* **Example**
*
* ```ts
* import { Array } from "effect"
*
* const result = Array.findFirst([1, 2, 3, 4, 5], x => x > 3)
* console.log(result) // Option.some(4)
* ```
*
* @category elements
* @since 2.0.0
*/
const findFirst$7 = findFirst$8;
/**
* Finds the last element in an iterable collection that satisfies the given predicate or refinement.
* Returns an `Option` containing the found element, or `Option.none` if no element matches.
*
* **Example**
*
* ```ts
* import { Array } from "effect"
*
* const result = Array.findLast([1, 2, 3, 4, 5], n => n % 2 === 0)
* console.log(result) // Option.some(4)
* ```
*
* @category elements
* @since 2.0.0
*/
const findLast$1 = /* @__PURE__ */ dual(2, (self, f) => {
	const input = fromIterable$10(self);
	for (let i = input.length - 1; i >= 0; i--) {
		const a = input[i];
		const o = f(a, i);
		if (isBoolean$1(o)) {
			if (o) return some$4(a);
		} else if (isSome(o)) return o;
	}
	return none$7();
});
/**
* Reverse an `Iterable`, creating a new `Array`.
*
* **Example**
*
* ```ts
* import { Array } from "effect"
*
* const result = Array.reverse([1, 2, 3, 4])
* console.log(result) // [4, 3, 2, 1]
* ```
*
* @category elements
* @since 2.0.0
*/
const reverse$2 = (self) => Array.from(self).reverse();
/**
* Create a new array with elements sorted in increasing order based on the specified comparator.
* If the input is a `NonEmptyReadonlyArray`, the output will also be a `NonEmptyReadonlyArray`.
*
* @category sorting
* @since 2.0.0
*/
const sort = /* @__PURE__ */ dual(2, (self, O) => {
	const out = Array.from(self);
	out.sort(O);
	return out;
});
/**
* Takes two `Iterable`s and returns an `Array` of corresponding pairs.
* If one input `Iterable` is short, excess elements of the
* longer `Iterable` are discarded.
*
* **Example**
*
* ```ts
* import { Array } from "effect"
*
* const result = Array.zip([1, 2, 3], ['a', 'b'])
* console.log(result) // [[1, 'a'], [2, 'b']]
* ```
*
* @category zipping
* @since 2.0.0
*/
const zip$6 = /* @__PURE__ */ dual(2, (self, that) => zipWith$5(self, that, make$43));
/**
* Apply a function to pairs of elements at the same index in two `Iterable`s, collecting the results in a new `Array`. If one
* input `Iterable` is short, excess elements of the longer `Iterable` are discarded.
*
* **Example**
*
* ```ts
* import { Array } from "effect"
*
* const result = Array.zipWith([1, 2, 3], [4, 5, 6], (a, b) => a + b)
* console.log(result) // [5, 7, 9]
* ```
*
* @category zipping
* @since 2.0.0
*/
const zipWith$5 = /* @__PURE__ */ dual(3, (self, that, f) => {
	const as$4 = fromIterable$10(self);
	const bs = fromIterable$10(that);
	if (isNonEmptyReadonlyArray(as$4) && isNonEmptyReadonlyArray(bs)) {
		const out = [f(headNonEmpty$1(as$4), headNonEmpty$1(bs))];
		const len = Math.min(as$4.length, bs.length);
		for (let i = 1; i < len; i++) out[i] = f(as$4[i], bs[i]);
		return out;
	}
	return [];
});
/**
* Returns a function that checks if a `ReadonlyArray` contains a given value using a provided `isEquivalent` function.
*
* **Example**
*
* ```ts
* import { Array, pipe } from "effect"
*
* const isEquivalent = (a: number, b: number) => a === b
* const containsNumber = Array.containsWith(isEquivalent)
* const result = pipe([1, 2, 3, 4], containsNumber(3))
* console.log(result) // true
* ```
*
* @category elements
* @since 2.0.0
*/
const containsWith$1 = (isEquivalent) => dual(2, (self, a) => {
	for (const i of self) if (isEquivalent(a, i)) return true;
	return false;
});
const _equivalence$2 = /* @__PURE__ */ equivalence();
/**
* Returns a function that checks if a `ReadonlyArray` contains a given value using the default `Equivalence`.
*
* **Example**
*
* ```ts
* import { Array, pipe } from "effect"
*
* const result = pipe(['a', 'b', 'c', 'd'], Array.contains('c'))
* console.log(result) // true
* ```
*
* @category elements
* @since 2.0.0
*/
const contains$1 = /* @__PURE__ */ containsWith$1(_equivalence$2);
/**
* Splits an `Iterable` into two segments, with the first segment containing a maximum of `n` elements.
* The value of `n` can be `0`.
*
* **Example**
*
* ```ts
* import { Array } from "effect"
*
* const result = Array.splitAt([1, 2, 3, 4, 5], 3)
* console.log(result) // [[1, 2, 3], [4, 5]]
* ```
*
* @category splitting
* @since 2.0.0
*/
const splitAt = /* @__PURE__ */ dual(2, (self, n) => {
	const input = Array.from(self);
	const _n = Math.floor(n);
	if (isNonEmptyReadonlyArray(input)) {
		if (_n >= 1) return splitNonEmptyAt(input, _n);
		return [[], input];
	}
	return [input, []];
});
/**
* Splits a `NonEmptyReadonlyArray` into two segments, with the first segment containing a maximum of `n` elements.
* The value of `n` must be `>= 1`.
*
* **Example**
*
* ```ts
* import { Array } from "effect"
*
* const result = Array.splitNonEmptyAt(["a", "b", "c", "d", "e"], 3)
* console.log(result) // [["a", "b", "c"], ["d", "e"]]
* ```
*
* @category splitting
* @since 2.0.0
*/
const splitNonEmptyAt = /* @__PURE__ */ dual(2, (self, n) => {
	const _n = Math.max(1, Math.floor(n));
	return _n >= self.length ? [copy$1(self), []] : [prepend$2(self.slice(1, _n), headNonEmpty$1(self)), self.slice(_n)];
});
/**
* Copies an array.
*
* **Example**
*
* ```ts
* import { Array } from "effect"
*
* const result = Array.copy([1, 2, 3])
* console.log(result) // [1, 2, 3]
* ```
*
* @since 2.0.0
*/
const copy$1 = (self) => self.slice();
/**
* Calculates the union of two arrays using the provided equivalence relation.
*
* **Example**
*
* ```ts
* import { Array } from "effect"
*
* const union = Array.unionWith([1, 2], [2, 3], (a, b) => a === b)
* console.log(union) // [1, 2, 3]
* ```
*
* @since 2.0.0
*/
const unionWith = /* @__PURE__ */ dual(3, (self, that, isEquivalent) => {
	const a = fromIterable$10(self);
	const b = fromIterable$10(that);
	if (isNonEmptyReadonlyArray(a)) {
		if (isNonEmptyReadonlyArray(b)) return dedupeWith(isEquivalent)(appendAll$2(a, b));
		return a;
	}
	return b;
});
/**
* Creates a union of two arrays, removing duplicates.
*
* **Example**
*
* ```ts
* import { Array } from "effect"
*
* const result = Array.union([1, 2], [2, 3])
* console.log(result) // [1, 2, 3]
* ```
*
* @since 2.0.0
*/
const union$8 = /* @__PURE__ */ dual(2, (self, that) => unionWith(self, that, _equivalence$2));
/**
* @category constructors
* @since 2.0.0
*/
const empty$32 = () => [];
/**
* Constructs a new `NonEmptyArray<A>` from the specified value.
*
* @category constructors
* @since 2.0.0
*/
const of$4 = (a) => [a];
/**
* @category mapping
* @since 2.0.0
*/
const map$14 = /* @__PURE__ */ dual(2, (self, f) => self.map(f));
/**
* Applies a function to each element in an array and returns a new array containing the concatenated mapped elements.
*
* @category sequencing
* @since 2.0.0
*/
const flatMap$10 = /* @__PURE__ */ dual(2, (self, f) => {
	if (isEmptyReadonlyArray(self)) return [];
	const out = [];
	for (let i = 0; i < self.length; i++) {
		const inner = f(self[i], i);
		for (let j = 0; j < inner.length; j++) out.push(inner[j]);
	}
	return out;
});
/**
* Combines multiple arrays into a single array by concatenating all elements
* from each nested array. This function ensures that the structure of nested
* arrays is collapsed into a single, flat array.
*
* **Example**
*
* ```ts
* import { Array } from "effect"
*
* const result = Array.flatten([[1, 2], [], [3, 4], [], [5, 6]])
* console.log(result) // [1, 2, 3, 4, 5, 6]
* ```
*
* @category sequencing
* @since 2.0.0
*/
const flatten$6 = /* @__PURE__ */ flatMap$10(identity);
/**
* Applies a function to each element of the `Iterable` and filters based on the result, keeping the transformed values where the function returns `Some`.
* This method combines filtering and mapping functionalities, allowing transformations and filtering of elements based on a single function pass.
*
* **Example**
*
* ```ts
* import { Array, Option } from "effect"
*
* const evenSquares = (x: number) => x % 2 === 0 ? Option.some(x * x) : Option.none()
*
* const result = Array.filterMap([1, 2, 3, 4, 5], evenSquares);
* console.log(result) // [4, 16]
* ```
*
* @category filtering
* @since 2.0.0
*/
const filterMap$4 = /* @__PURE__ */ dual(2, (self, f) => {
	const as$4 = fromIterable$10(self);
	const out = [];
	for (let i = 0; i < as$4.length; i++) {
		const o = f(as$4[i], i);
		if (isSome(o)) out.push(o.value);
	}
	return out;
});
/**
* Applies a function to each element of the `Iterable`, categorizing the results into two separate arrays.
* This function is particularly useful for operations where each element can result in two possible types,
* and you want to separate these types into different collections. For instance, separating validation results
* into successes and failures.
*
* **Example**
*
* ```ts
* import { Array, Either } from "effect";
*
* const isEven = (x: number) => x % 2 === 0
*
* const result = Array.partitionMap([1, 2, 3, 4, 5], x =>
*   isEven(x) ? Either.right(x) : Either.left(x)
* )
* console.log(result)
* // [
* //   [1, 3, 5],
* //   [2, 4]
* // ]
* ```
*
* @category filtering
* @since 2.0.0
*/
const partitionMap$1 = /* @__PURE__ */ dual(2, (self, f) => {
	const left$2 = [];
	const right$2 = [];
	const as$4 = fromIterable$10(self);
	for (let i = 0; i < as$4.length; i++) {
		const e = f(as$4[i], i);
		if (isLeft(e)) left$2.push(e.left);
		else right$2.push(e.right);
	}
	return [left$2, right$2];
});
/**
* Retrieves the `Some` values from an `Iterable` of `Option`s, collecting them into an array.
*
* **Example**
*
* ```ts
* import { Array, Option } from "effect"
*
* const result = Array.getSomes([Option.some(1), Option.none(), Option.some(2)])
* console.log(result) // [1, 2]
* ```
*
* @category filtering
* @since 2.0.0
*/
const getSomes = /* @__PURE__ */ filterMap$4(identity);
/**
* Reduces an array from the left.
*
* **Example**
*
* ```ts
* import { Array } from "effect"
*
* const result = Array.reduce([1, 2, 3], 0, (acc, n) => acc + n)
* console.log(result) // 6
* ```
*
* @category folding
* @since 2.0.0
*/
const reduce$11 = /* @__PURE__ */ dual(3, (self, b, f) => fromIterable$10(self).reduce((b$1, a, i) => f(b$1, a, i), b));
/**
* Reduces an array from the right.
*
* **Example**
*
* ```ts
* import { Array } from "effect"
*
* const result = Array.reduceRight([1, 2, 3], 0, (acc, n) => acc + n)
* console.log(result) // 6
* ```
*
* @category folding
* @since 2.0.0
*/
const reduceRight$3 = /* @__PURE__ */ dual(3, (self, b, f) => fromIterable$10(self).reduceRight((b$1, a, i) => f(b$1, a, i), b));
/**
* @category constructors
* @since 2.0.0
*/
const unfold$1 = (b, f) => {
	const out = [];
	let next = b;
	let o;
	while (isSome(o = f(next))) {
		const [a, b$1] = o.value;
		out.push(a);
		next = b$1;
	}
	return out;
};
/**
* This function creates and returns a new `Order` for an array of values based on a given `Order` for the elements of the array.
* The returned `Order` compares two arrays by applying the given `Order` to each element in the arrays.
* If all elements are equal, the arrays are then compared based on their length.
* It is useful when you need to compare two arrays of the same type and you have a specific way of comparing each element of the array.
*
* @category instances
* @since 2.0.0
*/
const getOrder$3 = array;
/**
* Creates an equivalence relation for arrays.
*
* **Example**
*
* ```ts
* import { Array } from "effect"
*
* const eq = Array.getEquivalence<number>((a, b) => a === b)
* console.log(eq([1, 2, 3], [1, 2, 3])) // true
* ```
*
* @category instances
* @since 2.0.0
*/
const getEquivalence$3 = array$2;
/**
* Remove duplicates from an `Iterable` using the provided `isEquivalent` function,
* preserving the order of the first occurrence of each element.
*
* **Example**
*
* ```ts
* import { Array } from "effect"
*
* const result = Array.dedupeWith([1, 2, 2, 3, 3, 3], (a, b) => a === b)
* console.log(result) // [1, 2, 3]
* ```
*
* @since 2.0.0
*/
const dedupeWith = /* @__PURE__ */ dual(2, (self, isEquivalent) => {
	const input = fromIterable$10(self);
	if (isNonEmptyReadonlyArray(input)) {
		const out = [headNonEmpty$1(input)];
		const rest = tailNonEmpty$1(input);
		for (const r of rest) if (out.every((a) => !isEquivalent(r, a))) out.push(r);
		return out;
	}
	return [];
});
/**
* Remove duplicates from an `Iterable`, preserving the order of the first occurrence of each element.
* The equivalence used to compare elements is provided by `Equal.equivalence()` from the `Equal` module.
*
* @since 2.0.0
*/
const dedupe = (self) => dedupeWith(self, equivalence());
/**
* Joins the elements together with "sep" in the middle.
*
* **Example**
*
* ```ts
* import { Array } from "effect"
*
* const strings = ["a", "b", "c"]
* const joined = Array.join(strings, "-")
* console.log(joined) // "a-b-c"
* ```
*
* @since 2.0.0
* @category folding
*/
const join$3 = /* @__PURE__ */ dual(2, (self, sep) => fromIterable$10(self).join(sep));

//#endregion
//#region ../../node_modules/.bun/effect@3.17.14/node_modules/effect/dist/esm/Boolean.js
/**
* Tests if a value is a `boolean`.
*
* @example
* ```ts
* import * as assert from "node:assert"
* import { isBoolean } from "effect/Boolean"
*
* assert.deepStrictEqual(isBoolean(true), true)
* assert.deepStrictEqual(isBoolean("true"), false)
* ```
*
* @category guards
* @since 2.0.0
*/
const isBoolean = isBoolean$1;
/**
* @category instances
* @since 2.0.0
*/
const Equivalence$2 = boolean$1;
/**
* @category instances
* @since 2.0.0
*/
const Order$4 = boolean;
/**
* Negates the given boolean: `!self`
*
* @example
* ```ts
* import * as assert from "node:assert"
* import { not } from "effect/Boolean"
*
* assert.deepStrictEqual(not(true), false)
* assert.deepStrictEqual(not(false), true)
* ```
*
* @category combinators
* @since 2.0.0
*/
const not = (self) => !self;

//#endregion
//#region ../../node_modules/.bun/effect@3.17.14/node_modules/effect/dist/esm/Chunk.js
const TypeId$14 = /* @__PURE__ */ Symbol.for("effect/Chunk");
function copy(src, srcPos, dest, destPos, len) {
	for (let i = srcPos; i < Math.min(src.length, srcPos + len); i++) dest[destPos + i - srcPos] = src[i];
	return dest;
}
const emptyArray = [];
/**
* Compares the two chunks of equal length using the specified function
*
* @category equivalence
* @since 2.0.0
*/
const getEquivalence$2 = (isEquivalent) => make$45((self, that) => self.length === that.length && toReadonlyArray(self).every((value, i) => isEquivalent(value, unsafeGet$4(that, i))));
const _equivalence$1 = /* @__PURE__ */ getEquivalence$2(equals);
const ChunkProto = {
	[TypeId$14]: { _A: (_) => _ },
	toString() {
		return format(this.toJSON());
	},
	toJSON() {
		return {
			_id: "Chunk",
			values: toReadonlyArray(this).map(toJSON)
		};
	},
	[NodeInspectSymbol]() {
		return this.toJSON();
	},
	[symbol](that) {
		return isChunk(that) && _equivalence$1(this, that);
	},
	[symbol$1]() {
		return cached$2(this, array$1(toReadonlyArray(this)));
	},
	[Symbol.iterator]() {
		switch (this.backing._tag) {
			case "IArray": return this.backing.array[Symbol.iterator]();
			case "IEmpty": return emptyArray[Symbol.iterator]();
			default: return toReadonlyArray(this)[Symbol.iterator]();
		}
	},
	pipe() {
		return pipeArguments(this, arguments);
	}
};
const makeChunk = (backing) => {
	const chunk$2 = Object.create(ChunkProto);
	chunk$2.backing = backing;
	switch (backing._tag) {
		case "IEmpty":
			chunk$2.length = 0;
			chunk$2.depth = 0;
			chunk$2.left = chunk$2;
			chunk$2.right = chunk$2;
			break;
		case "IConcat":
			chunk$2.length = backing.left.length + backing.right.length;
			chunk$2.depth = 1 + Math.max(backing.left.depth, backing.right.depth);
			chunk$2.left = backing.left;
			chunk$2.right = backing.right;
			break;
		case "IArray":
			chunk$2.length = backing.array.length;
			chunk$2.depth = 0;
			chunk$2.left = _empty$9;
			chunk$2.right = _empty$9;
			break;
		case "ISingleton":
			chunk$2.length = 1;
			chunk$2.depth = 0;
			chunk$2.left = _empty$9;
			chunk$2.right = _empty$9;
			break;
		case "ISlice":
			chunk$2.length = backing.length;
			chunk$2.depth = backing.chunk.depth + 1;
			chunk$2.left = _empty$9;
			chunk$2.right = _empty$9;
			break;
	}
	return chunk$2;
};
/**
* Checks if `u` is a `Chunk<unknown>`
*
* @category constructors
* @since 2.0.0
*/
const isChunk = (u) => hasProperty(u, TypeId$14);
const _empty$9 = /* @__PURE__ */ makeChunk({ _tag: "IEmpty" });
/**
* @category constructors
* @since 2.0.0
*/
const empty$31 = () => _empty$9;
/**
* Builds a `NonEmptyChunk` from an non-empty collection of elements.
*
* @category constructors
* @since 2.0.0
*/
const make$42 = (...as$4) => unsafeFromNonEmptyArray(as$4);
/**
* Builds a `NonEmptyChunk` from a single element.
*
* @category constructors
* @since 2.0.0
*/
const of$3 = (a) => makeChunk({
	_tag: "ISingleton",
	a
});
/**
* Creates a new `Chunk` from an iterable collection of values.
*
* @category constructors
* @since 2.0.0
*/
const fromIterable$9 = (self) => isChunk(self) ? self : unsafeFromArray(fromIterable$10(self));
const copyToArray = (self, array$3, initial) => {
	switch (self.backing._tag) {
		case "IArray":
			copy(self.backing.array, 0, array$3, initial, self.length);
			break;
		case "IConcat":
			copyToArray(self.left, array$3, initial);
			copyToArray(self.right, array$3, initial + self.left.length);
			break;
		case "ISingleton":
			array$3[initial] = self.backing.a;
			break;
		case "ISlice": {
			let i = 0;
			let j = initial;
			while (i < self.length) {
				array$3[j] = unsafeGet$4(self, i);
				i += 1;
				j += 1;
			}
			break;
		}
	}
};
const toReadonlyArray_ = (self) => {
	switch (self.backing._tag) {
		case "IEmpty": return emptyArray;
		case "IArray": return self.backing.array;
		default: {
			const arr = new Array(self.length);
			copyToArray(self, arr, 0);
			self.backing = {
				_tag: "IArray",
				array: arr
			};
			self.left = _empty$9;
			self.right = _empty$9;
			self.depth = 0;
			return arr;
		}
	}
};
/**
* Converts a `Chunk` into a `ReadonlyArray`. If the provided `Chunk` is
* non-empty (`NonEmptyChunk`), the function will return a
* `NonEmptyReadonlyArray`, ensuring the non-empty property is preserved.
*
* @category conversions
* @since 2.0.0
*/
const toReadonlyArray = toReadonlyArray_;
const reverseChunk = (self) => {
	switch (self.backing._tag) {
		case "IEmpty":
		case "ISingleton": return self;
		case "IArray": return makeChunk({
			_tag: "IArray",
			array: reverse$2(self.backing.array)
		});
		case "IConcat": return makeChunk({
			_tag: "IConcat",
			left: reverse$1(self.backing.right),
			right: reverse$1(self.backing.left)
		});
		case "ISlice": return unsafeFromArray(reverse$2(toReadonlyArray(self)));
	}
};
/**
* Reverses the order of elements in a `Chunk`.
* Importantly, if the input chunk is a `NonEmptyChunk`, the reversed chunk will also be a `NonEmptyChunk`.
*
* **Example**
*
* ```ts
* import { Chunk } from "effect"
*
* const chunk = Chunk.make(1, 2, 3)
* const result = Chunk.reverse(chunk)
*
* console.log(result)
* // { _id: 'Chunk', values: [ 3, 2, 1 ] }
* ```
*
* @since 2.0.0
* @category elements
*/
const reverse$1 = reverseChunk;
/**
* This function provides a safe way to read a value at a particular index from a `Chunk`.
*
* @category elements
* @since 2.0.0
*/
const get$10 = /* @__PURE__ */ dual(2, (self, index) => index < 0 || index >= self.length ? none$7() : some$4(unsafeGet$4(self, index)));
/**
* Wraps an array into a chunk without copying, unsafe on mutable arrays
*
* @since 2.0.0
* @category unsafe
*/
const unsafeFromArray = (self) => self.length === 0 ? empty$31() : self.length === 1 ? of$3(self[0]) : makeChunk({
	_tag: "IArray",
	array: self
});
/**
* Wraps an array into a chunk without copying, unsafe on mutable arrays
*
* @since 2.0.0
* @category unsafe
*/
const unsafeFromNonEmptyArray = (self) => unsafeFromArray(self);
/**
* Gets an element unsafely, will throw on out of bounds
*
* @since 2.0.0
* @category unsafe
*/
const unsafeGet$4 = /* @__PURE__ */ dual(2, (self, index) => {
	switch (self.backing._tag) {
		case "IEmpty": throw new Error(`Index out of bounds`);
		case "ISingleton":
			if (index !== 0) throw new Error(`Index out of bounds`);
			return self.backing.a;
		case "IArray":
			if (index >= self.length || index < 0) throw new Error(`Index out of bounds`);
			return self.backing.array[index];
		case "IConcat": return index < self.left.length ? unsafeGet$4(self.left, index) : unsafeGet$4(self.right, index - self.left.length);
		case "ISlice": return unsafeGet$4(self.backing.chunk, index + self.backing.offset);
	}
});
/**
* Appends the specified element to the end of the `Chunk`.
*
* @category concatenating
* @since 2.0.0
*/
const append$1 = /* @__PURE__ */ dual(2, (self, a) => appendAll$1(self, of$3(a)));
/**
* Prepend an element to the front of a `Chunk`, creating a new `NonEmptyChunk`.
*
* @category concatenating
* @since 2.0.0
*/
const prepend$1 = /* @__PURE__ */ dual(2, (self, elem) => appendAll$1(of$3(elem), self));
/**
* Drops the first up to `n` elements from the chunk
*
* @since 2.0.0
*/
const drop = /* @__PURE__ */ dual(2, (self, n) => {
	if (n <= 0) return self;
	else if (n >= self.length) return _empty$9;
	else switch (self.backing._tag) {
		case "ISlice": return makeChunk({
			_tag: "ISlice",
			chunk: self.backing.chunk,
			offset: self.backing.offset + n,
			length: self.backing.length - n
		});
		case "IConcat":
			if (n > self.left.length) return drop(self.right, n - self.left.length);
			return makeChunk({
				_tag: "IConcat",
				left: drop(self.left, n),
				right: self.right
			});
		default: return makeChunk({
			_tag: "ISlice",
			chunk: self,
			offset: n,
			length: self.length - n
		});
	}
});
/**
* Concatenates two chunks, combining their elements.
* If either chunk is non-empty, the result is also a non-empty chunk.
*
* **Example**
*
* ```ts
* import { Chunk } from "effect"
*
* const result = Chunk.make(1, 2).pipe(Chunk.appendAll(Chunk.make("a", "b")), Chunk.toArray)
*
* console.log(result)
* // [ 1, 2, "a", "b" ]
* ```
*
* @category concatenating
* @since 2.0.0
*/
const appendAll$1 = /* @__PURE__ */ dual(2, (self, that) => {
	if (self.backing._tag === "IEmpty") return that;
	if (that.backing._tag === "IEmpty") return self;
	const diff$10 = that.depth - self.depth;
	if (Math.abs(diff$10) <= 1) return makeChunk({
		_tag: "IConcat",
		left: self,
		right: that
	});
	else if (diff$10 < -1) if (self.left.depth >= self.right.depth) {
		const nr = appendAll$1(self.right, that);
		return makeChunk({
			_tag: "IConcat",
			left: self.left,
			right: nr
		});
	} else {
		const nrr = appendAll$1(self.right.right, that);
		if (nrr.depth === self.depth - 3) {
			const nr = makeChunk({
				_tag: "IConcat",
				left: self.right.left,
				right: nrr
			});
			return makeChunk({
				_tag: "IConcat",
				left: self.left,
				right: nr
			});
		} else {
			const nl = makeChunk({
				_tag: "IConcat",
				left: self.left,
				right: self.right.left
			});
			return makeChunk({
				_tag: "IConcat",
				left: nl,
				right: nrr
			});
		}
	}
	else if (that.right.depth >= that.left.depth) {
		const nl = appendAll$1(self, that.left);
		return makeChunk({
			_tag: "IConcat",
			left: nl,
			right: that.right
		});
	} else {
		const nll = appendAll$1(self, that.left.left);
		if (nll.depth === that.depth - 3) {
			const nl = makeChunk({
				_tag: "IConcat",
				left: nll,
				right: that.left.right
			});
			return makeChunk({
				_tag: "IConcat",
				left: nl,
				right: that.right
			});
		} else {
			const nr = makeChunk({
				_tag: "IConcat",
				left: that.left.right,
				right: that.right
			});
			return makeChunk({
				_tag: "IConcat",
				left: nll,
				right: nr
			});
		}
	}
});
/**
* Determines if the chunk is empty.
*
* @since 2.0.0
* @category elements
*/
const isEmpty$8 = (self) => self.length === 0;
/**
* Determines if the chunk is not empty.
*
* @since 2.0.0
* @category elements
*/
const isNonEmpty$5 = (self) => self.length > 0;
/**
* Returns the first element of this chunk if it exists.
*
* @since 2.0.0
* @category elements
*/
const head$2 = /* @__PURE__ */ get$10(0);
/**
* Returns the first element of this chunk.
*
* It will throw an error if the chunk is empty.
*
* @since 2.0.0
* @category unsafe
*/
const unsafeHead = (self) => unsafeGet$4(self, 0);
/**
* Returns the first element of this non empty chunk.
*
* @since 2.0.0
* @category elements
*/
const headNonEmpty = unsafeHead;
/**
* Returns every elements after the first.
*
* @since 2.0.0
* @category elements
*/
const tailNonEmpty = (self) => drop(self, 1);
/**
* Returns a function that checks if a `Chunk` contains a given value using the default `Equivalence`.
*
* @category elements
* @since 2.0.0
*/
const contains = contains$1;
/**
* Returns a function that checks if a `Chunk` contains a given value using a provided `isEquivalent` function.
*
* @category elements
* @since 2.0.0
*/
const containsWith = containsWith$1;
/**
* Returns the first element that satisfies the specified
* predicate, or `None` if no such element exists.
*
* @category elements
* @since 2.0.0
*/
const findFirst$6 = findFirst$7;
/**
* Return the first index for which a predicate holds.
*
* @category elements
* @since 2.0.0
*/
const findFirstIndex = findFirstIndex$1;
/**
* Find the last element for which a predicate holds.
*
* @category elements
* @since 2.0.0
*/
const findLast = findLast$1;
/**
* Return the last index for which a predicate holds.
*
* @category elements
* @since 2.0.0
*/
const findLastIndex = findLastIndex$1;
/**
* Joins the elements together with "sep" in the middle.
*
* @category folding
* @since 2.0.0
*/
const join$2 = join$3;
/**
* @category folding
* @since 2.0.0
*/
const reduce$10 = reduce$11;
/**
* @category folding
* @since 2.0.0
*/
const reduceRight$2 = reduceRight$3;

//#endregion
//#region ../../node_modules/.bun/effect@3.17.14/node_modules/effect/dist/esm/internal/hashMap/config.js
/** @internal */
const SIZE = 5;
/** @internal */
const BUCKET_SIZE = /* @__PURE__ */ Math.pow(2, SIZE);
/** @internal */
const MASK = BUCKET_SIZE - 1;
/** @internal */
const MAX_INDEX_NODE = BUCKET_SIZE / 2;
/** @internal */
const MIN_ARRAY_NODE = BUCKET_SIZE / 4;

//#endregion
//#region ../../node_modules/.bun/effect@3.17.14/node_modules/effect/dist/esm/internal/hashMap/bitwise.js
/**
* Hamming weight.
*
* Taken from: http://jsperf.com/hamming-weight
*
* @internal
*/
function popcount(x) {
	x -= x >> 1 & 1431655765;
	x = (x & 858993459) + (x >> 2 & 858993459);
	x = x + (x >> 4) & 252645135;
	x += x >> 8;
	x += x >> 16;
	return x & 127;
}
/** @internal */
function hashFragment(shift$1, h) {
	return h >>> shift$1 & MASK;
}
/** @internal */
function toBitmap(x) {
	return 1 << x;
}
/** @internal */
function fromBitmap(bitmap, bit) {
	return popcount(bitmap & bit - 1);
}

//#endregion
//#region ../../node_modules/.bun/effect@3.17.14/node_modules/effect/dist/esm/internal/stack.js
const make$41 = (value, previous) => ({
	value,
	previous
});

//#endregion
//#region ../../node_modules/.bun/effect@3.17.14/node_modules/effect/dist/esm/internal/hashMap/array.js
/** @internal */
function arrayUpdate(mutate$4, at$2, v, arr) {
	let out = arr;
	if (!mutate$4) {
		const len = arr.length;
		out = new Array(len);
		for (let i = 0; i < len; ++i) out[i] = arr[i];
	}
	out[at$2] = v;
	return out;
}
/** @internal */
function arraySpliceOut(mutate$4, at$2, arr) {
	const newLen = arr.length - 1;
	let i = 0;
	let g = 0;
	let out = arr;
	if (mutate$4) i = g = at$2;
	else {
		out = new Array(newLen);
		while (i < at$2) out[g++] = arr[i++];
	}
	++i;
	while (i <= newLen) out[g++] = arr[i++];
	if (mutate$4) out.length = newLen;
	return out;
}
/** @internal */
function arraySpliceIn(mutate$4, at$2, v, arr) {
	const len = arr.length;
	if (mutate$4) {
		let i$1 = len;
		while (i$1 >= at$2) arr[i$1--] = arr[i$1];
		arr[at$2] = v;
		return arr;
	}
	let i = 0, g = 0;
	const out = new Array(len + 1);
	while (i < at$2) out[g++] = arr[i++];
	out[at$2] = v;
	while (i < len) out[++g] = arr[i++];
	return out;
}

//#endregion
//#region ../../node_modules/.bun/effect@3.17.14/node_modules/effect/dist/esm/internal/hashMap/node.js
/** @internal */
var EmptyNode = class EmptyNode {
	_tag = "EmptyNode";
	modify(edit, _shift, f, hash$1, key, size$9) {
		const v = f(none$7());
		if (isNone$2(v)) return new EmptyNode();
		++size$9.value;
		return new LeafNode(edit, hash$1, key, v);
	}
};
/** @internal */
function isEmptyNode(a) {
	return isTagged(a, "EmptyNode");
}
/** @internal */
function isLeafNode(node) {
	return isEmptyNode(node) || node._tag === "LeafNode" || node._tag === "CollisionNode";
}
/** @internal */
function canEditNode(node, edit) {
	return isEmptyNode(node) ? false : edit === node.edit;
}
/** @internal */
var LeafNode = class LeafNode {
	edit;
	hash;
	key;
	value;
	_tag = "LeafNode";
	constructor(edit, hash$1, key, value) {
		this.edit = edit;
		this.hash = hash$1;
		this.key = key;
		this.value = value;
	}
	modify(edit, shift$1, f, hash$1, key, size$9) {
		if (equals(key, this.key)) {
			const v$1 = f(this.value);
			if (v$1 === this.value) return this;
			else if (isNone$2(v$1)) {
				--size$9.value;
				return new EmptyNode();
			}
			if (canEditNode(this, edit)) {
				this.value = v$1;
				return this;
			}
			return new LeafNode(edit, hash$1, key, v$1);
		}
		const v = f(none$7());
		if (isNone$2(v)) return this;
		++size$9.value;
		return mergeLeaves(edit, shift$1, this.hash, this, hash$1, new LeafNode(edit, hash$1, key, v));
	}
};
/** @internal */
var CollisionNode = class CollisionNode {
	edit;
	hash;
	children;
	_tag = "CollisionNode";
	constructor(edit, hash$1, children$2) {
		this.edit = edit;
		this.hash = hash$1;
		this.children = children$2;
	}
	modify(edit, shift$1, f, hash$1, key, size$9) {
		if (hash$1 === this.hash) {
			const canEdit = canEditNode(this, edit);
			const list = this.updateCollisionList(canEdit, edit, this.hash, this.children, f, key, size$9);
			if (list === this.children) return this;
			return list.length > 1 ? new CollisionNode(edit, this.hash, list) : list[0];
		}
		const v = f(none$7());
		if (isNone$2(v)) return this;
		++size$9.value;
		return mergeLeaves(edit, shift$1, this.hash, this, hash$1, new LeafNode(edit, hash$1, key, v));
	}
	updateCollisionList(mutate$4, edit, hash$1, list, f, key, size$9) {
		const len = list.length;
		for (let i = 0; i < len; ++i) {
			const child = list[i];
			if ("key" in child && equals(key, child.key)) {
				const value = child.value;
				const newValue$1 = f(value);
				if (newValue$1 === value) return list;
				if (isNone$2(newValue$1)) {
					--size$9.value;
					return arraySpliceOut(mutate$4, i, list);
				}
				return arrayUpdate(mutate$4, i, new LeafNode(edit, hash$1, key, newValue$1), list);
			}
		}
		const newValue = f(none$7());
		if (isNone$2(newValue)) return list;
		++size$9.value;
		return arrayUpdate(mutate$4, len, new LeafNode(edit, hash$1, key, newValue), list);
	}
};
/** @internal */
var IndexedNode = class IndexedNode {
	edit;
	mask;
	children;
	_tag = "IndexedNode";
	constructor(edit, mask, children$2) {
		this.edit = edit;
		this.mask = mask;
		this.children = children$2;
	}
	modify(edit, shift$1, f, hash$1, key, size$9) {
		const mask = this.mask;
		const children$2 = this.children;
		const frag = hashFragment(shift$1, hash$1);
		const bit = toBitmap(frag);
		const indx = fromBitmap(mask, bit);
		const exists$4 = mask & bit;
		const canEdit = canEditNode(this, edit);
		if (!exists$4) {
			const _newChild = new EmptyNode().modify(edit, shift$1 + SIZE, f, hash$1, key, size$9);
			if (!_newChild) return this;
			return children$2.length >= MAX_INDEX_NODE ? expand(edit, frag, _newChild, mask, children$2) : new IndexedNode(edit, mask | bit, arraySpliceIn(canEdit, indx, _newChild, children$2));
		}
		const current = children$2[indx];
		const child = current.modify(edit, shift$1 + SIZE, f, hash$1, key, size$9);
		if (current === child) return this;
		let bitmap = mask;
		let newChildren;
		if (isEmptyNode(child)) {
			bitmap &= ~bit;
			if (!bitmap) return new EmptyNode();
			if (children$2.length <= 2 && isLeafNode(children$2[indx ^ 1])) return children$2[indx ^ 1];
			newChildren = arraySpliceOut(canEdit, indx, children$2);
		} else newChildren = arrayUpdate(canEdit, indx, child, children$2);
		if (canEdit) {
			this.mask = bitmap;
			this.children = newChildren;
			return this;
		}
		return new IndexedNode(edit, bitmap, newChildren);
	}
};
/** @internal */
var ArrayNode = class ArrayNode {
	edit;
	size;
	children;
	_tag = "ArrayNode";
	constructor(edit, size$9, children$2) {
		this.edit = edit;
		this.size = size$9;
		this.children = children$2;
	}
	modify(edit, shift$1, f, hash$1, key, size$9) {
		let count = this.size;
		const children$2 = this.children;
		const frag = hashFragment(shift$1, hash$1);
		const child = children$2[frag];
		const newChild = (child || new EmptyNode()).modify(edit, shift$1 + SIZE, f, hash$1, key, size$9);
		if (child === newChild) return this;
		const canEdit = canEditNode(this, edit);
		let newChildren;
		if (isEmptyNode(child) && !isEmptyNode(newChild)) {
			++count;
			newChildren = arrayUpdate(canEdit, frag, newChild, children$2);
		} else if (!isEmptyNode(child) && isEmptyNode(newChild)) {
			--count;
			if (count <= MIN_ARRAY_NODE) return pack(edit, count, frag, children$2);
			newChildren = arrayUpdate(canEdit, frag, new EmptyNode(), children$2);
		} else newChildren = arrayUpdate(canEdit, frag, newChild, children$2);
		if (canEdit) {
			this.size = count;
			this.children = newChildren;
			return this;
		}
		return new ArrayNode(edit, count, newChildren);
	}
};
function pack(edit, count, removed, elements) {
	const children$2 = new Array(count - 1);
	let g = 0;
	let bitmap = 0;
	for (let i = 0, len = elements.length; i < len; ++i) if (i !== removed) {
		const elem = elements[i];
		if (elem && !isEmptyNode(elem)) {
			children$2[g++] = elem;
			bitmap |= 1 << i;
		}
	}
	return new IndexedNode(edit, bitmap, children$2);
}
function expand(edit, frag, child, bitmap, subNodes) {
	const arr = [];
	let bit = bitmap;
	let count = 0;
	for (let i = 0; bit; ++i) {
		if (bit & 1) arr[i] = subNodes[count++];
		bit >>>= 1;
	}
	arr[frag] = child;
	return new ArrayNode(edit, count + 1, arr);
}
function mergeLeavesInner(edit, shift$1, h1, n1, h2, n2) {
	if (h1 === h2) return new CollisionNode(edit, h1, [n2, n1]);
	const subH1 = hashFragment(shift$1, h1);
	const subH2 = hashFragment(shift$1, h2);
	if (subH1 === subH2) return (child) => new IndexedNode(edit, toBitmap(subH1) | toBitmap(subH2), [child]);
	else {
		const children$2 = subH1 < subH2 ? [n1, n2] : [n2, n1];
		return new IndexedNode(edit, toBitmap(subH1) | toBitmap(subH2), children$2);
	}
}
function mergeLeaves(edit, shift$1, h1, n1, h2, n2) {
	let stack = void 0;
	let currentShift = shift$1;
	while (true) {
		const res = mergeLeavesInner(edit, currentShift, h1, n1, h2, n2);
		if (typeof res === "function") {
			stack = make$41(res, stack);
			currentShift = currentShift + SIZE;
		} else {
			let final = res;
			while (stack != null) {
				final = stack.value(final);
				stack = stack.previous;
			}
			return final;
		}
	}
}

//#endregion
//#region ../../node_modules/.bun/effect@3.17.14/node_modules/effect/dist/esm/internal/hashMap.js
const HashMapSymbolKey = "effect/HashMap";
/** @internal */
const HashMapTypeId = /* @__PURE__ */ Symbol.for(HashMapSymbolKey);
const HashMapProto = {
	[HashMapTypeId]: HashMapTypeId,
	[Symbol.iterator]() {
		return new HashMapIterator(this, (k, v) => [k, v]);
	},
	[symbol$1]() {
		let hash$1 = hash(HashMapSymbolKey);
		for (const item of this) hash$1 ^= pipe(hash(item[0]), combine$11(hash(item[1])));
		return cached$2(this, hash$1);
	},
	[symbol](that) {
		if (isHashMap$1(that)) {
			if (that._size !== this._size) return false;
			for (const item of this) {
				const elem = pipe(that, getHash$1(item[0], hash(item[0])));
				if (isNone$2(elem)) return false;
				else if (!equals(item[1], elem.value)) return false;
			}
			return true;
		}
		return false;
	},
	toString() {
		return format(this.toJSON());
	},
	toJSON() {
		return {
			_id: "HashMap",
			values: Array.from(this).map(toJSON)
		};
	},
	[NodeInspectSymbol]() {
		return this.toJSON();
	},
	pipe() {
		return pipeArguments(this, arguments);
	}
};
const makeImpl$2 = (editable, edit, root, size$9) => {
	const map$17 = Object.create(HashMapProto);
	map$17._editable = editable;
	map$17._edit = edit;
	map$17._root = root;
	map$17._size = size$9;
	return map$17;
};
var HashMapIterator = class HashMapIterator {
	map;
	f;
	v;
	constructor(map$17, f) {
		this.map = map$17;
		this.f = f;
		this.v = visitLazy(this.map._root, this.f, void 0);
	}
	next() {
		if (isNone$2(this.v)) return {
			done: true,
			value: void 0
		};
		const v0 = this.v.value;
		this.v = applyCont(v0.cont);
		return {
			done: false,
			value: v0.value
		};
	}
	[Symbol.iterator]() {
		return new HashMapIterator(this.map, this.f);
	}
};
const applyCont = (cont) => cont ? visitLazyChildren(cont[0], cont[1], cont[2], cont[3], cont[4]) : none$7();
const visitLazy = (node, f, cont = void 0) => {
	switch (node._tag) {
		case "LeafNode":
			if (isSome(node.value)) return some$4({
				value: f(node.key, node.value.value),
				cont
			});
			return applyCont(cont);
		case "CollisionNode":
		case "ArrayNode":
		case "IndexedNode": {
			const children$2 = node.children;
			return visitLazyChildren(children$2.length, children$2, 0, f, cont);
		}
		default: return applyCont(cont);
	}
};
const visitLazyChildren = (len, children$2, i, f, cont) => {
	while (i < len) {
		const child = children$2[i++];
		if (child && !isEmptyNode(child)) return visitLazy(child, f, [
			len,
			children$2,
			i,
			f,
			cont
		]);
	}
	return applyCont(cont);
};
const _empty$8 = /* @__PURE__ */ makeImpl$2(false, 0, /* @__PURE__ */ new EmptyNode(), 0);
/** @internal */
const empty$30 = () => _empty$8;
/** @internal */
const make$40 = (...entries$2) => fromIterable$8(entries$2);
/** @internal */
const fromIterable$8 = (entries$2) => {
	const map$17 = beginMutation$3(empty$30());
	for (const entry of entries$2) set$5(map$17, entry[0], entry[1]);
	return endMutation$3(map$17);
};
/** @internal */
const isHashMap$1 = (u) => hasProperty(u, HashMapTypeId);
/** @internal */
const isEmpty$7 = (self) => self && isEmptyNode(self._root);
/** @internal */
const get$9 = /* @__PURE__ */ dual(2, (self, key) => getHash$1(self, key, hash(key)));
/** @internal */
const getHash$1 = /* @__PURE__ */ dual(3, (self, key, hash$1) => {
	let node = self._root;
	let shift$1 = 0;
	while (true) switch (node._tag) {
		case "LeafNode": return equals(key, node.key) ? node.value : none$7();
		case "CollisionNode":
			if (hash$1 === node.hash) {
				const children$2 = node.children;
				for (let i = 0, len = children$2.length; i < len; ++i) {
					const child = children$2[i];
					if ("key" in child && equals(key, child.key)) return child.value;
				}
			}
			return none$7();
		case "IndexedNode": {
			const frag = hashFragment(shift$1, hash$1);
			const bit = toBitmap(frag);
			if (node.mask & bit) {
				node = node.children[fromBitmap(node.mask, bit)];
				shift$1 += SIZE;
				break;
			}
			return none$7();
		}
		case "ArrayNode":
			node = node.children[hashFragment(shift$1, hash$1)];
			if (node) {
				shift$1 += SIZE;
				break;
			}
			return none$7();
		default: return none$7();
	}
});
/** @internal */
const unsafeGet$3 = /* @__PURE__ */ dual(2, (self, key) => {
	const element = getHash$1(self, key, hash(key));
	if (isNone$2(element)) throw new Error("Expected map to contain key");
	return element.value;
});
/** @internal */
const has$6 = /* @__PURE__ */ dual(2, (self, key) => isSome(getHash$1(self, key, hash(key))));
/** @internal */
const hasHash$1 = /* @__PURE__ */ dual(3, (self, key, hash$1) => isSome(getHash$1(self, key, hash$1)));
/** @internal */
const hasBy$1 = /* @__PURE__ */ dual(2, (self, predicate) => isSome(findFirst$5(self, predicate)));
/** @internal */
const set$5 = /* @__PURE__ */ dual(3, (self, key, value) => modifyAt$1(self, key, () => some$4(value)));
/** @internal */
const setTree = /* @__PURE__ */ dual(3, (self, newRoot, newSize) => {
	if (self._editable) {
		self._root = newRoot;
		self._size = newSize;
		return self;
	}
	return newRoot === self._root ? self : makeImpl$2(self._editable, self._edit, newRoot, newSize);
});
/** @internal */
const keys$3 = (self) => new HashMapIterator(self, (key) => key);
/** @internal */
const values$5 = (self) => new HashMapIterator(self, (_, value) => value);
/** @internal */
const entries$1 = (self) => new HashMapIterator(self, (key, value) => [key, value]);
/** @internal */
const size$8 = (self) => self._size;
/** @internal */
const countBy$1 = /* @__PURE__ */ dual(2, (self, f) => {
	let count = 0;
	for (const [k, a] of self) if (f(a, k)) count++;
	return count;
});
/** @internal */
const beginMutation$3 = (self) => makeImpl$2(true, self._edit + 1, self._root, self._size);
/** @internal */
const endMutation$3 = (self) => {
	self._editable = false;
	return self;
};
/** @internal */
const mutate$3 = /* @__PURE__ */ dual(2, (self, f) => {
	const transient = beginMutation$3(self);
	f(transient);
	return endMutation$3(transient);
});
/** @internal */
const modifyAt$1 = /* @__PURE__ */ dual(3, (self, key, f) => modifyHash$1(self, key, hash(key), f));
/** @internal */
const modifyHash$1 = /* @__PURE__ */ dual(4, (self, key, hash$1, f) => {
	const size$9 = { value: self._size };
	const newRoot = self._root.modify(self._editable ? self._edit : NaN, 0, f, hash$1, key, size$9);
	return pipe(self, setTree(newRoot, size$9.value));
});
/** @internal */
const modify$3 = /* @__PURE__ */ dual(3, (self, key, f) => modifyAt$1(self, key, map$15(f)));
/** @internal */
const union$7 = /* @__PURE__ */ dual(2, (self, that) => {
	const result = beginMutation$3(self);
	forEach$8(that, (v, k) => set$5(result, k, v));
	return endMutation$3(result);
});
/** @internal */
const remove$6 = /* @__PURE__ */ dual(2, (self, key) => modifyAt$1(self, key, none$7));
/** @internal */
const removeMany$1 = /* @__PURE__ */ dual(2, (self, keys$5) => mutate$3(self, (map$17) => {
	for (const key of keys$5) remove$6(key)(map$17);
}));
/**
* Maps over the entries of the `HashMap` using the specified function.
*
* @since 2.0.0
* @category mapping
*/
const map$13 = /* @__PURE__ */ dual(2, (self, f) => reduce$9(self, empty$30(), (map$17, value, key) => set$5(map$17, key, f(value, key))));
/** @internal */
const flatMap$9 = /* @__PURE__ */ dual(2, (self, f) => reduce$9(self, empty$30(), (zero$1, value, key) => mutate$3(zero$1, (map$17) => forEach$8(f(value, key), (value$1, key$1) => set$5(map$17, key$1, value$1)))));
/** @internal */
const forEach$8 = /* @__PURE__ */ dual(2, (self, f) => reduce$9(self, void 0, (_, value, key) => f(value, key)));
/** @internal */
const reduce$9 = /* @__PURE__ */ dual(3, (self, zero$1, f) => {
	const root = self._root;
	if (root._tag === "LeafNode") return isSome(root.value) ? f(zero$1, root.value.value, root.key) : zero$1;
	if (root._tag === "EmptyNode") return zero$1;
	const toVisit = [root.children];
	let children$2;
	while (children$2 = toVisit.pop()) for (let i = 0, len = children$2.length; i < len;) {
		const child = children$2[i++];
		if (child && !isEmptyNode(child)) if (child._tag === "LeafNode") {
			if (isSome(child.value)) zero$1 = f(zero$1, child.value.value, child.key);
		} else toVisit.push(child.children);
	}
	return zero$1;
});
/** @internal */
const filter$6 = /* @__PURE__ */ dual(2, (self, f) => mutate$3(empty$30(), (map$17) => {
	for (const [k, a] of self) if (f(a, k)) set$5(map$17, k, a);
}));
/** @internal */
const compact$1 = (self) => filterMap$3(self, identity);
/** @internal */
const filterMap$3 = /* @__PURE__ */ dual(2, (self, f) => mutate$3(empty$30(), (map$17) => {
	for (const [k, a] of self) {
		const option$2 = f(a, k);
		if (isSome(option$2)) set$5(map$17, k, option$2.value);
	}
}));
/** @internal */
const findFirst$5 = /* @__PURE__ */ dual(2, (self, predicate) => {
	for (const ka of self) if (predicate(ka[1], ka[0])) return some$4(ka);
	return none$7();
});
/** @internal */
const some$3 = /* @__PURE__ */ dual(2, (self, predicate) => {
	for (const ka of self) if (predicate(ka[1], ka[0])) return true;
	return false;
});
/** @internal */
const every$5 = /* @__PURE__ */ dual(2, (self, predicate) => !some$3(self, (a, k) => !predicate(a, k)));

//#endregion
//#region ../../node_modules/.bun/effect@3.17.14/node_modules/effect/dist/esm/internal/hashSet.js
const HashSetSymbolKey = "effect/HashSet";
/** @internal */
const HashSetTypeId = /* @__PURE__ */ Symbol.for(HashSetSymbolKey);
const HashSetProto = {
	[HashSetTypeId]: HashSetTypeId,
	[Symbol.iterator]() {
		return keys$3(this._keyMap);
	},
	[symbol$1]() {
		return cached$2(this, combine$11(hash(this._keyMap))(hash(HashSetSymbolKey)));
	},
	[symbol](that) {
		if (isHashSet$1(that)) return size$8(this._keyMap) === size$8(that._keyMap) && equals(this._keyMap, that._keyMap);
		return false;
	},
	toString() {
		return format(this.toJSON());
	},
	toJSON() {
		return {
			_id: "HashSet",
			values: Array.from(this).map(toJSON)
		};
	},
	[NodeInspectSymbol]() {
		return this.toJSON();
	},
	pipe() {
		return pipeArguments(this, arguments);
	}
};
/** @internal */
const makeImpl$1 = (keyMap) => {
	const set$6 = Object.create(HashSetProto);
	set$6._keyMap = keyMap;
	return set$6;
};
/** @internal */
const isHashSet$1 = (u) => hasProperty(u, HashSetTypeId);
const _empty$7 = /* @__PURE__ */ makeImpl$1(/* @__PURE__ */ empty$30());
/** @internal */
const empty$29 = () => _empty$7;
/** @internal */
const fromIterable$7 = (elements) => {
	const set$6 = beginMutation$2(empty$29());
	for (const value of elements) add$4(set$6, value);
	return endMutation$2(set$6);
};
/** @internal */
const make$39 = (...elements) => {
	const set$6 = beginMutation$2(empty$29());
	for (const value of elements) add$4(set$6, value);
	return endMutation$2(set$6);
};
/** @internal */
const has$5 = /* @__PURE__ */ dual(2, (self, value) => has$6(self._keyMap, value));
/** @internal */
const some$2 = /* @__PURE__ */ dual(2, (self, f) => {
	let found = false;
	for (const value of self) {
		found = f(value);
		if (found) break;
	}
	return found;
});
/** @internal */
const every$4 = /* @__PURE__ */ dual(2, (self, refinement) => !some$2(self, (a) => !refinement(a)));
/** @internal */
const isSubset$1 = /* @__PURE__ */ dual(2, (self, that) => every$4(self, (value) => has$5(that, value)));
/** @internal */
const values$4 = (self) => keys$3(self._keyMap);
/** @internal */
const size$7 = (self) => size$8(self._keyMap);
/** @internal */
const beginMutation$2 = (self) => makeImpl$1(beginMutation$3(self._keyMap));
/** @internal */
const endMutation$2 = (self) => {
	self._keyMap._editable = false;
	return self;
};
/** @internal */
const mutate$2 = /* @__PURE__ */ dual(2, (self, f) => {
	const transient = beginMutation$2(self);
	f(transient);
	return endMutation$2(transient);
});
/** @internal */
const add$4 = /* @__PURE__ */ dual(2, (self, value) => self._keyMap._editable ? (set$5(value, true)(self._keyMap), self) : makeImpl$1(set$5(value, true)(self._keyMap)));
/** @internal */
const remove$5 = /* @__PURE__ */ dual(2, (self, value) => self._keyMap._editable ? (remove$6(value)(self._keyMap), self) : makeImpl$1(remove$6(value)(self._keyMap)));
/** @internal */
const difference$1 = /* @__PURE__ */ dual(2, (self, that) => mutate$2(self, (set$6) => {
	for (const value of that) remove$5(set$6, value);
}));
/** @internal */
const intersection$1 = /* @__PURE__ */ dual(2, (self, that) => mutate$2(empty$29(), (set$6) => {
	for (const value of that) if (has$5(value)(self)) add$4(value)(set$6);
}));
/** @internal */
const union$6 = /* @__PURE__ */ dual(2, (self, that) => mutate$2(empty$29(), (set$6) => {
	forEach$7(self, (value) => add$4(set$6, value));
	for (const value of that) add$4(set$6, value);
}));
/** @internal */
const toggle$1 = /* @__PURE__ */ dual(2, (self, value) => has$5(self, value) ? remove$5(self, value) : add$4(self, value));
/** @internal */
const map$12 = /* @__PURE__ */ dual(2, (self, f) => mutate$2(empty$29(), (set$6) => {
	forEach$7(self, (a) => {
		const b = f(a);
		if (!has$5(set$6, b)) add$4(set$6, b);
	});
}));
/** @internal */
const flatMap$8 = /* @__PURE__ */ dual(2, (self, f) => mutate$2(empty$29(), (set$6) => {
	forEach$7(self, (a) => {
		for (const b of f(a)) if (!has$5(set$6, b)) add$4(set$6, b);
	});
}));
/** @internal */
const forEach$7 = /* @__PURE__ */ dual(2, (self, f) => forEach$8(self._keyMap, (_, k) => f(k)));
/** @internal */
const reduce$8 = /* @__PURE__ */ dual(3, (self, zero$1, f) => reduce$9(self._keyMap, zero$1, (z, _, a) => f(z, a)));
/** @internal */
const filter$5 = /* @__PURE__ */ dual(2, (self, f) => {
	return mutate$2(empty$29(), (set$6) => {
		const iterator = values$4(self);
		let next;
		while (!(next = iterator.next()).done) {
			const value = next.value;
			if (f(value)) add$4(set$6, value);
		}
	});
});
/** @internal */
const partition$3 = /* @__PURE__ */ dual(2, (self, predicate) => {
	const iterator = values$4(self);
	let next;
	const right$2 = beginMutation$2(empty$29());
	const left$2 = beginMutation$2(empty$29());
	while (!(next = iterator.next()).done) {
		const value = next.value;
		if (predicate(value)) add$4(right$2, value);
		else add$4(left$2, value);
	}
	return [endMutation$2(left$2), endMutation$2(right$2)];
});

//#endregion
//#region ../../node_modules/.bun/effect@3.17.14/node_modules/effect/dist/esm/HashSet.js
HashSetTypeId;
/**
* @memberof HashSet
* @since 2.0.0
* @category refinements
*/
const isHashSet = isHashSet$1;
/**
* Creates an empty `HashSet`.
*
* Time complexity: **`O(1)`**
*
* @memberof HashSet
* @since 2.0.0
* @category constructors
* @example
*
* ```ts
* import { HashSet, pipe } from "effect"
*
* console.log(
*   pipe(
*     // Provide a type argument to create a HashSet of a specific type
*     HashSet.empty<number>(),
*     HashSet.add(1),
*     HashSet.add(1), // Notice the duplicate
*     HashSet.add(2),
*     HashSet.toValues
*   )
* ) // Output: [1, 2]
* ```
*
* @see Other `HashSet` constructors are {@link module:HashSet.make} {@link module:HashSet.fromIterable}
*/
const empty$28 = empty$29;
/**
* Creates a new `HashSet` from an iterable collection of values.
*
* Time complexity: **`O(n)`** where n is the number of elements in the iterable
*
* @memberof HashSet
* @since 2.0.0
* @category constructors
* @example
*
* ```ts
* // Creating a HashSet from an Array
* import { HashSet, pipe } from "effect"
*
* console.log(
*   pipe(
*     [1, 2, 3, 4, 5, 1, 2, 3], // Array<number> is an Iterable<number>;  Note the duplicates.
*     HashSet.fromIterable,
*     HashSet.toValues
*   )
* ) // Output: [1, 2, 3, 4, 5]
* ```
*
* @example
*
* ```ts
* // Creating a HashSet from a Set
* import { HashSet, pipe } from "effect"
*
* console.log(
*   pipe(
*     new Set(["apple", "banana", "orange", "apple"]), // Set<string> is an Iterable<string>
*     HashSet.fromIterable,
*     HashSet.toValues
*   )
* ) // Output: ["apple", "banana", "orange"]
* ```
*
* @example
*
* ```ts
* // Creating a HashSet from a Generator
* import { HashSet } from "effect"
*
* // Generator functions return iterables
* function* fibonacci(n: number): Generator<number, void, unknown> {
*   let [a, b] = [0, 1]
*   for (let i = 0; i < n; i++) {
*     yield a
*     ;[a, b] = [b, a + b]
*   }
* }
*
* // Create a HashSet from the first 10 Fibonacci numbers
* const fibonacciSet = HashSet.fromIterable(fibonacci(10))
*
* console.log(HashSet.toValues(fibonacciSet))
* // Outputs: [0, 1, 2, 3, 5, 8, 13, 21, 34] but in unsorted order
* ```
*
* @example
*
* ```ts
* //  Creating a HashSet from another HashSet
* import { HashSet, pipe } from "effect"
*
* console.log(
*   pipe(
*     // since HashSet implements the Iterable interface, we can use it to create a new HashSet
*     HashSet.make(1, 2, 3, 4),
*     HashSet.fromIterable,
*     HashSet.toValues // turns the HashSet back into an array
*   )
* ) // Output: [1, 2, 3, 4]
* ```
*
* @example
*
* ```ts
* // Creating a HashSet from other Effect's data structures like Chunk
* import { Chunk, HashSet, pipe } from "effect"
*
* console.log(
*   pipe(
*     Chunk.make(1, 2, 3, 4), // Iterable<number>
*     HashSet.fromIterable,
*     HashSet.toValues // turns the HashSet back into an array
*   )
* ) // Outputs: [1, 2, 3, 4]
* ```
*
* @see Other `HashSet` constructors are {@link module:HashSet.empty} {@link module:HashSet.make}
*/
const fromIterable$6 = fromIterable$7;
/**
* Construct a new `HashSet` from a variable number of values.
*
* Time complexity: **`O(n)`** where n is the number of elements
*
* @memberof HashSet
* @since 2.0.0
* @category constructors
* @example
*
* ```ts
* import { Equal, Hash, HashSet, pipe } from "effect"
* import assert from "node:assert/strict"
*
* class Character implements Equal.Equal {
*   readonly name: string
*   readonly trait: string
*
*   constructor(name: string, trait: string) {
*     this.name = name
*     this.trait = trait
*   }
*
*   // Define equality based on name, and trait
*   [Equal.symbol](that: Equal.Equal): boolean {
*     if (that instanceof Character) {
*       return (
*         Equal.equals(this.name, that.name) &&
*         Equal.equals(this.trait, that.trait)
*       )
*     }
*     return false
*   }
*
*   // Generate a hash code based on the sum of the character's name and trait
*   [Hash.symbol](): number {
*     return Hash.hash(this.name + this.trait)
*   }
*
*   static readonly of = (name: string, trait: string): Character => {
*     return new Character(name, trait)
*   }
* }
*
* assert.strictEqual(
*   Equal.equals(
*     HashSet.make(
*       Character.of("Alice", "Curious"),
*       Character.of("Alice", "Curious"),
*       Character.of("White Rabbit", "Always late"),
*       Character.of("Mad Hatter", "Tea enthusiast")
*     ),
*     // Is the same as adding each character to an empty set
*     pipe(
*       HashSet.empty(),
*       HashSet.add(Character.of("Alice", "Curious")),
*       HashSet.add(Character.of("Alice", "Curious")), // Alice tried to attend twice!
*       HashSet.add(Character.of("White Rabbit", "Always late")),
*       HashSet.add(Character.of("Mad Hatter", "Tea enthusiast"))
*     )
*   ),
*   true,
*   "`HashSet.make` and `HashSet.empty() + HashSet.add()` should be equal"
* )
*
* assert.strictEqual(
*   Equal.equals(
*     HashSet.make(
*       Character.of("Alice", "Curious"),
*       Character.of("Alice", "Curious"),
*       Character.of("White Rabbit", "Always late"),
*       Character.of("Mad Hatter", "Tea enthusiast")
*     ),
*     HashSet.fromIterable([
*       Character.of("Alice", "Curious"),
*       Character.of("Alice", "Curious"),
*       Character.of("White Rabbit", "Always late"),
*       Character.of("Mad Hatter", "Tea enthusiast")
*     ])
*   ),
*   true,
*   "`HashSet.make` and `HashSet.fromIterable` should be equal"
* )
* ```
*
* @see Other `HashSet` constructors are {@link module:HashSet.fromIterable} {@link module:HashSet.empty}
*/
const make$38 = make$39;
/**
* Checks if the specified value exists in the `HashSet`.
*
* Time complexity: **`O(1)`** average
*
* @memberof HashSet
* @since 2.0.0
* @category elements
* @example
*
* ```ts
* // Syntax
* import { HashSet, pipe } from "effect"
*
* // with `data-last`, a.k.a. `pipeable` API
* pipe(HashSet.make(0, 1, 2), HashSet.has(3)) // false
*
* // or piped with the pipe function
* HashSet.make(0, 1, 2).pipe(HashSet.has(3)) // false
*
* // or with `data-first` API
* HashSet.has(HashSet.make(0, 1, 2), 3) // false
* ```
*
* @returns A `boolean` signaling the presence of the value in the HashSet
* @see Other `HashSet` elements are {@link module:HashSet.some} {@link module:HashSet.every} {@link module:HashSet.isSubset}
*/
const has$4 = has$5;
/**
* Check if a predicate holds true for some `HashSet` element.
*
* Time complexity: **`O(n)`** where n is the number of elements in the set
*
* @memberof HashSet
* @since 2.0.0
* @category elements
* @example
*
* ```ts
* // Syntax
* import { HashSet, pipe } from "effect"
*
* const set: HashSet.HashSet<number> = HashSet.make(0, 1, 2)
*
* // with `data-last`, a.k.a. `pipeable` API
* pipe(
*   set,
*   HashSet.some((n) => n > 0)
* ) // true
*
* // or piped with the pipe function
* set.pipe(HashSet.some((n) => n > 0)) // true
*
* // or with `data-first` API
* HashSet.some(set, (n) => n > 0) // true
* ```
*
* @see Other `HashSet` elements are {@link module:HashSet.has} {@link module:HashSet.every} {@link module:HashSet.isSubset}
*/
const some$1 = some$2;
/**
* Check if a predicate holds true for every `HashSet` element.
*
* Time complexity is **`O(n)`** as it needs to traverse the whole HashSet
* collection
*
* @memberof HashSet
* @since 2.0.0
* @category elements
* @example
*
* ```ts
* // Syntax with Refinement
* import { HashSet, pipe, Predicate } from "effect"
*
* const numberOrString = HashSet.make(1, "1", "one", "uno")
*
* // with `data-last`, a.k.a. `pipeable` API and `Refinement`
* pipe(
*   numberOrString, // HashSet.HashSet<number | string>
*   HashSet.every(Predicate.isString)
* ) // HashSet.HashSet<string>
*
* // or piped with the pipe function and  `Refinement`
* numberOrString // HashSet.HashSet<number | string>
*   .pipe(HashSet.every(Predicate.isString)) // HashSet.HashSet<string>
*
* // or with `data-first` API and `Refinement`
* HashSet.every(
*   numberOrString, // HashSet.HashSet<number | string>
*   Predicate.isString
* ) // HashSet.HashSet<string>
* ```
*
* @example
*
* ```ts
* // Syntax with Predicate
* import { HashSet, pipe } from "effect"
*
* const set = HashSet.make(1, 2, 3)
*
* // with `data-last`, a.k.a. `pipeable` API
* pipe(
*   set,
*   HashSet.every((n) => n >= 0)
* ) // true
*
* // or piped with the pipe function
* set.pipe(HashSet.every((n) => n >= 0)) // true
*
* // or with `data-first` API
* HashSet.every(set, (n) => n >= 0) // true
* ```
*
* @returns A boolean once it has evaluated that whole collection fulfill the
*   Predicate function
* @see Other `HashSet` elements are {@link module:HashSet.has} {@link module:HashSet.some} {@link module:HashSet.isSubset}
*/
const every$3 = every$4;
/**
* Returns `true` if and only if every element in the this `HashSet` is an
* element of the second set,
*
* **NOTE**: the hash and equal of both sets must be the same.
*
* Time complexity analysis is of **`O(n)`**
*
* @memberof HashSet
* @since 2.0.0
* @category elements
* @example
*
* ```ts
* // Syntax
* import { HashSet, pipe } from "effect"
*
* const set1 = HashSet.make(0, 1)
* const set2 = HashSet.make(1, 2)
* const set3 = HashSet.make(0, 1, 2)
*
* // with `data-last`, a.k.a. `pipeable` API
* pipe(set1, HashSet.isSubset(set2)) // false
* pipe(set1, HashSet.isSubset(set3)) // true
*
* // or piped with the pipe function
* set1.pipe(HashSet.isSubset(set2)) // false
* set1.pipe(HashSet.isSubset(set3)) // true
*
* // or with `data-first` API
* HashSet.isSubset(set1, set2) // false
* HashSet.isSubset(set1, set3) // true)
* ```
*
* @see Other `HashSet` elements are {@link module:HashSet.has} {@link module:HashSet.some} {@link module:HashSet.every}
*/
const isSubset = isSubset$1;
/**
* Returns an `IterableIterator` of the values in the `HashSet`.
*
* Time complexity: **`O(1)`**
*
* @memberof HashSet
* @since 2.0.0
* @category getters
* @example
*
* ```ts
* import { HashSet, pipe } from "effect"
*
* const numberIterable = pipe(
*   HashSet.make(0, 1, 1, 2), // HashSet.HashSet<number>
*   HashSet.values // takes an HashSet<A> and returns an IterableIterator<A>
* )
*
* for (const number of numberIterable) {
*   console.log(number) // it will logs: 0, 1, 2
* }
* ```
*
* @see Other `HashSet` getters are {@link module:HashSet.toValues} {@link module:HashSet.size}
*/
const values$3 = values$4;
/**
* Calculates the number of values in the `HashSet`.
*
* Time complexity: **`O(1)`**
*
* @memberof HashSet
* @since 2.0.0
* @category getters
* @example
*
* ```ts
* import { HashSet, pipe } from "effect"
* import assert from "node:assert/strict"
*
* assert.deepStrictEqual(pipe(HashSet.empty(), HashSet.size), 0)
*
* assert.deepStrictEqual(
*   pipe(HashSet.make(1, 2, 2, 3, 4, 3), HashSet.size),
*   4
* )
* ```
*
* @see Other `HashSet` getters are {@link module:HashSet.values} {@link module:HashSet.toValues}
*/
const size$6 = size$7;
/**
* Creates a new mutable version of the `HashSet`
*
* When a `HashSet` is mutable, operations like {@link add} and {@link remove}
* modify the data structure in place instead of creating a new one, which is
* more efficient when performing multiple operations.
*
* @memberof HashSet
* @since 2.0.0
* @example
*
* ```ts
* import { HashSet } from "effect"
* import assert from "node:assert/strict"
*
* const UPPER_BOUND = 10_000
*
* const immutableSet = HashSet.empty<number>().pipe(HashSet.add(0))
*
* // Create a mutable version of the immutableSet
* const mutableSet = HashSet.beginMutation(immutableSet)
*
* for (let i = 1; i < UPPER_BOUND; i++) {
*   // Operations now modify the set in place instead of creating new instances
*   // This is more efficient when making multiple changes
*   const pointerToMutableSet = HashSet.add(mutableSet, i)
*
*   // the two sets have the same identity, hence `add` is mutating mutableSet and not returning a new HashSet instance
*   assert(Object.is(mutableSet, pointerToMutableSet))
*   assert.equal(HashSet.has(mutableSet, i), true) // `i` is in the mutableSet
*   assert.equal(HashSet.has(immutableSet, i), false) // `i` is not in the immutableSet
* }
*
* const next = UPPER_BOUND + 1
* // When done, mark the set as immutable again
* HashSet.endMutation(mutableSet).pipe(
*   HashSet.add(next) // since this returns a new HashSet, it will not be logged as part of the mutableSet
* )
* assert.equal(HashSet.has(mutableSet, next), false)
*
* console.log(HashSet.toValues(immutableSet)) // [0]
* console.log(HashSet.toValues(mutableSet).sort((a, b) => a - b)) // [0, 1, 2, 3, ...rest]
* ```
*
* @see Other `HashSet` mutations are {@link module:HashSet.add} {@link module:HashSet.remove} {@link module:HashSet.toggle} {@link module:HashSet.endMutation} {@link module:HashSet.mutate}
*/
const beginMutation$1 = beginMutation$2;
/**
* Makes the `HashSet` immutable again.
*
* After calling `endMutation`, operations like {@link add} and {@link remove}
* will create new instances of the `HashSet` instead of modifying the existing
* one.
*
* @memberof HashSet
* @since 2.0.0
* @example
*
* ```ts
* import { HashSet } from "effect"
* import assert from "node:assert/strict"
*
* // Create a mutable set
* const mutableSet = HashSet.beginMutation(HashSet.empty<number>())
*
* // Add some elements to the mutable set
* HashSet.add(mutableSet, 1)
* HashSet.add(mutableSet, 2)
*
* // Before endMutation, operations modify the set in place
* const sameSet = HashSet.add(mutableSet, 3)
* assert(Object.is(mutableSet, sameSet)) // true - same object reference
* assert.deepStrictEqual(HashSet.toValues(mutableSet).sort(), [1, 2, 3])
*
* // Make the set immutable again
* const immutableSet = HashSet.endMutation(mutableSet)
*
* // endMutation returns the same set instance, now made immutable
* assert(Object.is(mutableSet, immutableSet)) // true - same object reference
*
* // After endMutation, operations create new instances
* const newSet = HashSet.add(immutableSet, 4)
* assert(!Object.is(immutableSet, newSet)) // false - different object references
*
* // The original set remains unchanged
* assert.deepStrictEqual(HashSet.toValues(immutableSet).sort(), [1, 2, 3])
*
* // The new set contains the added element
* assert.deepStrictEqual(HashSet.toValues(newSet).sort(), [1, 2, 3, 4])
* ```
*
* @see Other `HashSet` mutations are {@link module:HashSet.add} {@link module:HashSet.remove} {@link module:HashSet.toggle} {@link module:HashSet.beginMutation} {@link module:HashSet.mutate}
*/
const endMutation$1 = endMutation$2;
/**
* Mutates the `HashSet` within the context of the provided function.
*
* You can consider it a functional abstraction on top of the lower-level
* mutation primitives of {@link module:HashSet.beginMutation} `->` `mutable
* context` `->` {@link HashSet.endMutation}.
*
* @memberof HashSet
* @since 2.0.0
* @example
*
* ```ts
* // Syntax
* import { HashSet, pipe } from "effect"
*
* // with data-last, a.k.a. pipeable API
* pipe(
*   HashSet.make(1, 2, 3),
*   HashSet.mutate((set) => {
*     HashSet.add(set, 4)
*     HashSet.remove(set, 1)
*   })
* )
*
* // or piped with the pipe function
* HashSet.make(1, 2, 3).pipe(
*   HashSet.mutate((set) => {
*     HashSet.add(set, 4)
*     HashSet.remove(set, 1)
*   })
* )
*
* // or with data-first API
* HashSet.mutate(HashSet.make(1, 2, 3), (set) => {
*   HashSet.add(set, 4)
*   HashSet.remove(set, 1)
* })
* ```
*
* @see Other `HashSet` mutations are {@link module:HashSet.add} {@link module:HashSet.remove} {@link module:HashSet.toggle} {@link module:HashSet.beginMutation} {@link module:HashSet.endMutation}
*/
const mutate$1 = mutate$2;
/**
* Adds a value to the `HashSet`.
*
* Time complexity: **`O(1)`** average
*
* @remarks
* Remember that a `HashSet` is a collection of unique values, so adding a value
* that already exists in the `HashSet` will not add a duplicate.
*
* Remember that HashSet is an immutable data structure, so the `add` function,
* like all other functions that modify the HashSet, will return a new HashSet
* with the added value.
* @memberof HashSet
* @since 2.0.0
* @example
*
* ```ts
* // Syntax
* import { HashSet, pipe } from "effect"
*
* // with data-last, a.k.a. pipeable API
* pipe(HashSet.empty(), HashSet.add(0), HashSet.add(0))
*
* // or piped with the pipe function
* HashSet.empty().pipe(HashSet.add(0))
*
* // or with data-first API
* HashSet.add(HashSet.empty(), 0)
* ```
*
* @see Other `HashSet` mutations are {@link module:HashSet.remove} {@link module:HashSet.toggle} {@link module:HashSet.beginMutation} {@link module:HashSet.endMutation} {@link module:HashSet.mutate}
*/
const add$3 = add$4;
/**
* Removes a value from the `HashSet`.
*
* Time complexity: **`O(1)`** average
*
* @memberof HashSet
* @since 2.0.0
* @example
*
* ```ts
* // Syntax
* import { HashSet, pipe } from "effect"
*
* // with `data-last`, a.k.a. `pipeable` API
* pipe(HashSet.make(0, 1, 2), HashSet.remove(0))
*
* // or piped with the pipe function
* HashSet.make(0, 1, 2).pipe(HashSet.remove(0))
*
* // or with `data-first` API
* HashSet.remove(HashSet.make(0, 1, 2), 0)
* ```
*
* @see Other `HashSet` mutations are {@link module:HashSet.add} {@link module:HashSet.toggle} {@link module:HashSet.beginMutation} {@link module:HashSet.endMutation} {@link module:HashSet.mutate}
*/
const remove$4 = remove$5;
/**
* Computes the set difference `(A - B)` between this `HashSet` and the
* specified `Iterable<A>`.
*
* Time complexity: **`O(n)`** where n is the number of elements in the set
*
* **NOTE**: the hash and equal of the values in both the set and the iterable
* must be the same; meaning we cannot compute a difference between a `HashSet
* of bananas` and a `HashSet of elephants` as they are not the same type and
* won't implement the Equal trait in the same way.
*
* @memberof HashSet
* @since 2.0.0
* @example
*
* ```ts
* // Syntax
* import { HashSet, pipe } from "effect"
*
* // with data-last, a.k.a. pipeable API
* pipe(HashSet.make(1, 2, 3), HashSet.difference(HashSet.make(3, 4, 5)))
*
* // or piped with the pipe function
* HashSet.make(1, 2, 3).pipe(HashSet.difference(HashSet.make(3, 4, 5)))
*
* // or with data-first API
* HashSet.difference(HashSet.make(1, 2, 3), HashSet.make(3, 4, 5))
* ```
*
* @see Other `HashSet` operations are {@link module:HashSet.intersection} {@link module:HashSet.union}
*/
const difference = difference$1;
/**
* Returns a `HashSet` of values which are present in both this set and that
* `Iterable<A>`. Computes set intersection (A ∩ B)
*
* Time complexity: **`O(n)`** where n is the number of elements in the smaller
* set
*
* **NOTE**: the hash and equal of the values in both the set and the iterable
* must be the same.
*
* @memberof HashSet
* @since 2.0.0
* @example
*
* ```ts
* // Syntax
* import { HashSet, pipe } from "effect"
*
* // with data-last, a.k.a. pipeable API
* pipe(HashSet.make(1, 2, 3), HashSet.intersection(HashSet.make(2, 3, 4)))
*
* // or piped with the pipe function
* HashSet.make(1, 2, 3).pipe(HashSet.intersection(HashSet.make(2, 3, 4)))
*
* // or with data-first API
* HashSet.intersection(HashSet.make(1, 2, 3), HashSet.make(2, 3, 4))
* ```
*
* @see Other `HashSet` operations are {@link module:HashSet.difference} {@link module:HashSet.union}
*/
const intersection = intersection$1;
/**
* Computes the set union `( self ∪ that )` between this `HashSet` and the
* specified `Iterable<A>`.
*
* Time complexity: **`O(n)`** where n is the number of elements in the set
*
* **NOTE**: the hash and equal of the values in both the set and the iterable
* must be the same.
*
* @memberof HashSet
* @since 2.0.0
* @example
*
* ```ts
* // Syntax
* import { HashSet, pipe } from "effect"
*
* // with data-last, a.k.a. pipeable API
* pipe(HashSet.make(1, 2, 3), HashSet.union(HashSet.make(3, 4, 5)))
*
* // or piped with the pipe function
* HashSet.make(1, 2, 3).pipe(HashSet.union(HashSet.make(3, 4, 5)))
*
* // or with data-first API
* HashSet.union(HashSet.make(1, 2, 3), HashSet.make(3, 4, 5))
* ```
*
* @see Other `HashSet` operations are {@link module:HashSet.difference} {@link module:HashSet.intersection}
*/
const union$5 = union$6;
/**
* Checks if a value is present in the `HashSet`. If it is present, the value
* will be removed from the `HashSet`, otherwise the value will be added to the
* `HashSet`.
*
* Time complexity: **`O(1)`** average
*
* @memberof HashSet
* @since 2.0.0
* @example
*
* ```ts
* // Syntax
* import { HashSet, pipe } from "effect"
*
* // with `data-last`, a.k.a. `pipeable` API
* pipe(HashSet.make(0, 1, 2), HashSet.toggle(0))
*
* // or piped with the pipe function
* HashSet.make(0, 1, 2).pipe(HashSet.toggle(0))
*
* // or with `data-first` API
* HashSet.toggle(HashSet.make(0, 1, 2), 0)
* ```
*
* @returns A new `HashSet` where the toggled value is being either added or
*   removed based on the initial `HashSet` state.
* @see Other `HashSet` mutations are {@link module:HashSet.add} {@link module:HashSet.remove} {@link module:HashSet.beginMutation} {@link module:HashSet.endMutation} {@link module:HashSet.mutate}
*/
const toggle = toggle$1;
/**
* Maps over the values of the `HashSet` using the specified function.
*
* The time complexity is of **`O(n)`**.
*
* @memberof HashSet
* @since 2.0.0
* @category mapping
* @example
*
* ```ts
* // Syntax
* import { HashSet, pipe } from "effect"
*
* // with `data-last`, a.k.a. `pipeable` API
* pipe(
*   HashSet.make(0, 1, 2), // HashSet.HashSet<number>
*   HashSet.map(String) // HashSet.HashSet<string>
* )
*
* // or piped with the pipe method
* HashSet.make(0, 1, 2).pipe(HashSet.map(String))
*
* // or with `data-first` API
* HashSet.map(HashSet.make(0, 1, 2), String)
* ```
*/
const map$11 = map$12;
/**
* Chains over the values of the `HashSet` using the specified function.
*
* The time complexity is of **`O(n)`**.
*
* @memberof HashSet
* @since 2.0.0
* @category sequencing
* @example
*
* ```ts
* // Syntax
* import { HashSet, pipe } from "effect"
*
* // with `data-last`, a.k.a. `pipeable` API
* pipe(
*   HashSet.make(0, 1, 2), // HashSet.HashSet<number>
*   HashSet.flatMap((n) => Array.of(String(n))) // HashSet.HashSet<string>
* )
*
* // or piped with the pipe method
* HashSet.make(0, 1, 2) // HashSet.HashSet<number>
*   .pipe(
*     HashSet.flatMap((n) => Array.of(String(n))) // HashSet.HashSet<string>
*   )
*
* // or with `data-first` API
* HashSet.flatMap(HashSet.make(0, 1, 2), (n) => Array.of(String(n)))
* ```
*/
const flatMap$7 = flatMap$8;
/**
* Applies the specified function to the values of the `HashSet`.
*
* The time complexity is of **`O(n)`**.
*
* @memberof HashSet
* @since 2.0.0
* @category traversing
* @example
*
* ```ts
* // Syntax
* import { HashSet, pipe } from "effect"
*
* // with `data-last`, a.k.a. `pipeable` API
* pipe(HashSet.make(0, 1, 2), HashSet.forEach(console.log)) // logs: 0 1 2
*
* // or piped with the pipe method
* HashSet.make(0, 1, 2).pipe(HashSet.forEach(console.log)) // logs: 0 1 2
*
* // or with `data-first` API
* HashSet.forEach(HashSet.make(0, 1, 2), console.log) // logs: 0 1 2
* ```
*/
const forEach$6 = forEach$7;
/**
* Reduces the specified state over the values of the `HashSet`.
*
* The time complexity is of **`O(n)`**.
*
* @memberof HashSet
* @since 2.0.0
* @category folding
* @example
*
* ```ts
* // Syntax
* import { HashSet, pipe } from "effect"
*
* const sum = (a: number, b: number): number => a + b
*
* // with `data-last`, a.k.a. `pipeable` API
* pipe(HashSet.make(0, 1, 2), HashSet.reduce(0, sum))
*
* // or with the pipe method
* HashSet.make(0, 1, 2).pipe(HashSet.reduce(0, sum))
*
* // or with `data-first` API
* HashSet.reduce(HashSet.make(0, 1, 2), 0, sum)
* ```
*/
const reduce$7 = reduce$8;
/**
* Filters values out of a `HashSet` using the specified predicate.
*
* The time complexity is of **`O(n)`**.
*
* @memberof HashSet
* @since 2.0.0
* @category filtering
* @example
*
* ```ts
* // Syntax with  Predicate
* import { HashSet, type Predicate, pipe } from "effect"
*
* const filterPositiveNumbers: Predicate.Predicate<number> = (n) => n > 0
*
* // with `data-last`, a.k.a. `pipeable` API
* pipe(
*   HashSet.make(-2, -1, 0, 1, 2),
*   HashSet.filter(filterPositiveNumbers)
* )
*
* // or with the pipe method
* HashSet.make(-2, -1, 0, 1, 2).pipe(HashSet.filter(filterPositiveNumbers))
*
* // or with `data-first` API
* HashSet.filter(HashSet.make(-2, -1, 0, 1, 2), filterPositiveNumbers)
* ```
*
* @example
*
* ```ts
* /// Syntax with Refinement
* import { HashSet, pipe } from "effect"
*
* const stringRefinement = (value: unknown): value is string =>
*   typeof value === "string"
*
* // with `data-last`, a.k.a. `pipeable` API
* pipe(
*   HashSet.make(1, "unos", 2, "two", 3, "trois", 4, "vier"), // // HashSet.HashSet<number | string>
*   HashSet.filter(stringRefinement)
* ) // HashSet.HashSet<string>
*
* // or with the pipe method
* HashSet.make(1, "unos", 2, "two", 3, "trois", 4, "vier") // HashSet.HashSet<number | string>
*   .pipe(HashSet.filter(stringRefinement)) // HashSet.HashSet<string>
*
* // or with `data-first` API
* HashSet.filter(
*   HashSet.make(1, "unos", 2, "two", 3, "trois", 4, "vier"), // HashSet.HashSet<number | string>
*   stringRefinement
* ) // HashSet.HashSet<string>
* ```
*/
const filter$4 = filter$5;
/**
* Partition the values of a `HashSet` using the specified predicate.
*
* If a value matches the predicate, it will be placed into the `HashSet` on the
* right side of the resulting `Tuple`, otherwise the value will be placed into
* the left side.
*
* Time complexity is of **`O(n)`**.
*
* @memberof HashSet
* @since 2.0.0
* @category partitioning
* @example
*
* ```ts
* // Syntax with Predicate
* import { HashSet, pipe, Predicate } from "effect"
*
* // with `data-last`, a.k.a. `pipeable` API
* pipe(
*   HashSet.make(0, 1, 2, 3, 4, 5),
*   HashSet.partition((n) => n % 2 === 0)
* )
*
* // or with the pipe method
* HashSet.make(0, 1, 2, 3, 4, 5).pipe(
*   HashSet.partition((n) => n % 2 === 0)
* )
*
* // or with `data-first` API
* HashSet.partition(HashSet.make(0, 1, 2, 3, 4, 5), (n) => n % 2 === 0)
* ```
*
* @example
*
* ```ts
* // Syntax with Refinement
* import { HashSet, pipe, Predicate } from "effect"
*
* const stringRefinement: Predicate.Refinement<string | number, string> = (
*   value
* ) => typeof value === "string"
*
* // with `data-last`, a.k.a. `pipeable` API
* pipe(
*   HashSet.make(1, "unos", 2, "two", 3, "trois", 4, "vier"),
*   HashSet.partition(stringRefinement)
* )
*
* // or with the pipe method
* HashSet.make(1, "unos", 2, "two", 3, "trois", 4, "vier").pipe(
*   HashSet.partition(stringRefinement)
* )
*
* // or with `data-first` API
* HashSet.partition(
*   HashSet.make(1, "unos", 2, "two", 3, "trois", 4, "vier"),
*   stringRefinement
* )
* ```
*/
const partition$2 = partition$3;

//#endregion
//#region ../../node_modules/.bun/effect@3.17.14/node_modules/effect/dist/esm/internal/opCodes/cause.js
/** @internal */
const OP_DIE = "Die";
/** @internal */
const OP_EMPTY$2 = "Empty";
/** @internal */
const OP_FAIL$1 = "Fail";
/** @internal */
const OP_INTERRUPT = "Interrupt";
/** @internal */
const OP_PARALLEL$1 = "Parallel";
/** @internal */
const OP_SEQUENTIAL$1 = "Sequential";

//#endregion
//#region ../../node_modules/.bun/effect@3.17.14/node_modules/effect/dist/esm/internal/cause.js
/** @internal */
const CauseSymbolKey = "effect/Cause";
/** @internal */
const CauseTypeId = /* @__PURE__ */ Symbol.for(CauseSymbolKey);
const variance$7 = { _E: (_) => _ };
/** @internal */
const proto$2 = {
	[CauseTypeId]: variance$7,
	[symbol$1]() {
		return pipe(hash(CauseSymbolKey), combine$11(hash(flattenCause(this))), cached$2(this));
	},
	[symbol](that) {
		return isCause(that) && causeEquals(this, that);
	},
	pipe() {
		return pipeArguments(this, arguments);
	},
	toJSON() {
		switch (this._tag) {
			case "Empty": return {
				_id: "Cause",
				_tag: this._tag
			};
			case "Die": return {
				_id: "Cause",
				_tag: this._tag,
				defect: toJSON(this.defect)
			};
			case "Interrupt": return {
				_id: "Cause",
				_tag: this._tag,
				fiberId: this.fiberId.toJSON()
			};
			case "Fail": return {
				_id: "Cause",
				_tag: this._tag,
				failure: toJSON(this.error)
			};
			case "Sequential":
			case "Parallel": return {
				_id: "Cause",
				_tag: this._tag,
				left: toJSON(this.left),
				right: toJSON(this.right)
			};
		}
	},
	toString() {
		return pretty$2(this);
	},
	[NodeInspectSymbol]() {
		return this.toJSON();
	}
};
/** @internal */
const empty$27 = /* @__PURE__ */ (() => {
	const o = /* @__PURE__ */ Object.create(proto$2);
	o._tag = OP_EMPTY$2;
	return o;
})();
/** @internal */
const fail$9 = (error) => {
	const o = Object.create(proto$2);
	o._tag = OP_FAIL$1;
	o.error = error;
	return o;
};
/** @internal */
const die$4 = (defect) => {
	const o = Object.create(proto$2);
	o._tag = OP_DIE;
	o.defect = defect;
	return o;
};
/** @internal */
const interrupt$5 = (fiberId$2) => {
	const o = Object.create(proto$2);
	o._tag = OP_INTERRUPT;
	o.fiberId = fiberId$2;
	return o;
};
/** @internal */
const parallel$2 = (left$2, right$2) => {
	const o = Object.create(proto$2);
	o._tag = OP_PARALLEL$1;
	o.left = left$2;
	o.right = right$2;
	return o;
};
/** @internal */
const sequential$2 = (left$2, right$2) => {
	const o = Object.create(proto$2);
	o._tag = OP_SEQUENTIAL$1;
	o.left = left$2;
	o.right = right$2;
	return o;
};
/** @internal */
const isCause = (u) => hasProperty(u, CauseTypeId);
/** @internal */
const isEmptyType = (self) => self._tag === OP_EMPTY$2;
/** @internal */
const isDieType = (self) => self._tag === OP_DIE;
/** @internal */
const isEmpty$6 = (self) => {
	if (self._tag === OP_EMPTY$2) return true;
	return reduce$6(self, true, (acc, cause$2) => {
		switch (cause$2._tag) {
			case OP_EMPTY$2: return some$4(acc);
			case OP_DIE:
			case OP_FAIL$1:
			case OP_INTERRUPT: return some$4(false);
			default: return none$7();
		}
	});
};
/** @internal */
const isInterrupted$1 = (self) => isSome(interruptOption(self));
/** @internal */
const isInterruptedOnly = (self) => reduceWithContext(void 0, IsInterruptedOnlyCauseReducer)(self);
/** @internal */
const failures = (self) => reverse$1(reduce$6(self, empty$31(), (list, cause$2) => cause$2._tag === OP_FAIL$1 ? some$4(pipe(list, prepend$1(cause$2.error))) : none$7()));
/** @internal */
const defects = (self) => reverse$1(reduce$6(self, empty$31(), (list, cause$2) => cause$2._tag === OP_DIE ? some$4(pipe(list, prepend$1(cause$2.defect))) : none$7()));
/** @internal */
const interruptors = (self) => reduce$6(self, empty$28(), (set$6, cause$2) => cause$2._tag === OP_INTERRUPT ? some$4(pipe(set$6, add$3(cause$2.fiberId))) : none$7());
/** @internal */
const failureOption = (self) => find(self, (cause$2) => cause$2._tag === OP_FAIL$1 ? some$4(cause$2.error) : none$7());
/** @internal */
const failureOrCause = (self) => {
	const option$2 = failureOption(self);
	switch (option$2._tag) {
		case "None": return right(self);
		case "Some": return left(option$2.value);
	}
};
/** @internal */
const interruptOption = (self) => find(self, (cause$2) => cause$2._tag === OP_INTERRUPT ? some$4(cause$2.fiberId) : none$7());
/** @internal */
const keepDefects = (self) => match$9(self, {
	onEmpty: none$7(),
	onFail: () => none$7(),
	onDie: (defect) => some$4(die$4(defect)),
	onInterrupt: () => none$7(),
	onSequential: mergeWith(sequential$2),
	onParallel: mergeWith(parallel$2)
});
/** @internal */
const keepDefectsAndElectFailures = (self) => match$9(self, {
	onEmpty: none$7(),
	onFail: (failure) => some$4(die$4(failure)),
	onDie: (defect) => some$4(die$4(defect)),
	onInterrupt: () => none$7(),
	onSequential: mergeWith(sequential$2),
	onParallel: mergeWith(parallel$2)
});
/** @internal */
const stripFailures = (self) => match$9(self, {
	onEmpty: empty$27,
	onFail: () => empty$27,
	onDie: die$4,
	onInterrupt: interrupt$5,
	onSequential: sequential$2,
	onParallel: parallel$2
});
/** @internal */
const electFailures = (self) => match$9(self, {
	onEmpty: empty$27,
	onFail: die$4,
	onDie: die$4,
	onInterrupt: interrupt$5,
	onSequential: sequential$2,
	onParallel: parallel$2
});
/** @internal */
const map$10 = /* @__PURE__ */ dual(2, (self, f) => flatMap$6(self, (e) => fail$9(f(e))));
/** @internal */
const flatMap$6 = /* @__PURE__ */ dual(2, (self, f) => match$9(self, {
	onEmpty: empty$27,
	onFail: (error) => f(error),
	onDie: (defect) => die$4(defect),
	onInterrupt: (fiberId$2) => interrupt$5(fiberId$2),
	onSequential: (left$2, right$2) => sequential$2(left$2, right$2),
	onParallel: (left$2, right$2) => parallel$2(left$2, right$2)
}));
/** @internal */
const flatten$5 = (self) => flatMap$6(self, identity);
/** @internal */
const causeEquals = (left$2, right$2) => {
	let leftStack = of$3(left$2);
	let rightStack = of$3(right$2);
	while (isNonEmpty$5(leftStack) && isNonEmpty$5(rightStack)) {
		const [leftParallel, leftSequential] = pipe(headNonEmpty(leftStack), reduce$6([empty$28(), empty$31()], ([parallel$3, sequential$3], cause$2) => {
			const [par$1, seq$1] = evaluateCause(cause$2);
			return some$4([pipe(parallel$3, union$5(par$1)), pipe(sequential$3, appendAll$1(seq$1))]);
		}));
		const [rightParallel, rightSequential] = pipe(headNonEmpty(rightStack), reduce$6([empty$28(), empty$31()], ([parallel$3, sequential$3], cause$2) => {
			const [par$1, seq$1] = evaluateCause(cause$2);
			return some$4([pipe(parallel$3, union$5(par$1)), pipe(sequential$3, appendAll$1(seq$1))]);
		}));
		if (!equals(leftParallel, rightParallel)) return false;
		leftStack = leftSequential;
		rightStack = rightSequential;
	}
	return true;
};
/**
* Flattens a cause to a sequence of sets of causes, where each set represents
* causes that fail in parallel and sequential sets represent causes that fail
* after each other.
*
* @internal
*/
const flattenCause = (cause$2) => {
	return flattenCauseLoop(of$3(cause$2), empty$31());
};
/** @internal */
const flattenCauseLoop = (causes, flattened) => {
	while (1) {
		const [parallel$3, sequential$3] = pipe(causes, reduce$11([empty$28(), empty$31()], ([parallel$4, sequential$4], cause$2) => {
			const [par$1, seq$1] = evaluateCause(cause$2);
			return [pipe(parallel$4, union$5(par$1)), pipe(sequential$4, appendAll$1(seq$1))];
		}));
		const updated = size$6(parallel$3) > 0 ? pipe(flattened, prepend$1(parallel$3)) : flattened;
		if (isEmpty$8(sequential$3)) return reverse$1(updated);
		causes = sequential$3;
		flattened = updated;
	}
	throw new Error(getBugErrorMessage("Cause.flattenCauseLoop"));
};
/** @internal */
const find = /* @__PURE__ */ dual(2, (self, pf) => {
	const stack = [self];
	while (stack.length > 0) {
		const item = stack.pop();
		const option$2 = pf(item);
		switch (option$2._tag) {
			case "None":
				switch (item._tag) {
					case OP_SEQUENTIAL$1:
					case OP_PARALLEL$1:
						stack.push(item.right);
						stack.push(item.left);
						break;
				}
				break;
			case "Some": return option$2;
		}
	}
	return none$7();
});
/**
* Takes one step in evaluating a cause, returning a set of causes that fail
* in parallel and a list of causes that fail sequentially after those causes.
*
* @internal
*/
const evaluateCause = (self) => {
	let cause$2 = self;
	const stack = [];
	let _parallel = empty$28();
	let _sequential = empty$31();
	while (cause$2 !== void 0) switch (cause$2._tag) {
		case OP_EMPTY$2:
			if (stack.length === 0) return [_parallel, _sequential];
			cause$2 = stack.pop();
			break;
		case OP_FAIL$1:
			_parallel = add$3(_parallel, make$42(cause$2._tag, cause$2.error));
			if (stack.length === 0) return [_parallel, _sequential];
			cause$2 = stack.pop();
			break;
		case OP_DIE:
			_parallel = add$3(_parallel, make$42(cause$2._tag, cause$2.defect));
			if (stack.length === 0) return [_parallel, _sequential];
			cause$2 = stack.pop();
			break;
		case OP_INTERRUPT:
			_parallel = add$3(_parallel, make$42(cause$2._tag, cause$2.fiberId));
			if (stack.length === 0) return [_parallel, _sequential];
			cause$2 = stack.pop();
			break;
		case OP_SEQUENTIAL$1:
			switch (cause$2.left._tag) {
				case OP_EMPTY$2:
					cause$2 = cause$2.right;
					break;
				case OP_SEQUENTIAL$1:
					cause$2 = sequential$2(cause$2.left.left, sequential$2(cause$2.left.right, cause$2.right));
					break;
				case OP_PARALLEL$1:
					cause$2 = parallel$2(sequential$2(cause$2.left.left, cause$2.right), sequential$2(cause$2.left.right, cause$2.right));
					break;
				default:
					_sequential = prepend$1(_sequential, cause$2.right);
					cause$2 = cause$2.left;
					break;
			}
			break;
		case OP_PARALLEL$1:
			stack.push(cause$2.right);
			cause$2 = cause$2.left;
			break;
	}
	throw new Error(getBugErrorMessage("Cause.evaluateCauseLoop"));
};
/** @internal */
const IsInterruptedOnlyCauseReducer = {
	emptyCase: constTrue,
	failCase: constFalse,
	dieCase: constFalse,
	interruptCase: constTrue,
	sequentialCase: (_, left$2, right$2) => left$2 && right$2,
	parallelCase: (_, left$2, right$2) => left$2 && right$2
};
const OP_SEQUENTIAL_CASE = "SequentialCase";
const OP_PARALLEL_CASE = "ParallelCase";
/** @internal */
const match$9 = /* @__PURE__ */ dual(2, (self, { onDie, onEmpty, onFail, onInterrupt: onInterrupt$2, onParallel, onSequential }) => {
	return reduceWithContext(self, void 0, {
		emptyCase: () => onEmpty,
		failCase: (_, error) => onFail(error),
		dieCase: (_, defect) => onDie(defect),
		interruptCase: (_, fiberId$2) => onInterrupt$2(fiberId$2),
		sequentialCase: (_, left$2, right$2) => onSequential(left$2, right$2),
		parallelCase: (_, left$2, right$2) => onParallel(left$2, right$2)
	});
});
/** @internal */
const reduce$6 = /* @__PURE__ */ dual(3, (self, zero$1, pf) => {
	let accumulator = zero$1;
	let cause$2 = self;
	const causes = [];
	while (cause$2 !== void 0) {
		const option$2 = pf(accumulator, cause$2);
		accumulator = isSome(option$2) ? option$2.value : accumulator;
		switch (cause$2._tag) {
			case OP_SEQUENTIAL$1:
				causes.push(cause$2.right);
				cause$2 = cause$2.left;
				break;
			case OP_PARALLEL$1:
				causes.push(cause$2.right);
				cause$2 = cause$2.left;
				break;
			default:
				cause$2 = void 0;
				break;
		}
		if (cause$2 === void 0 && causes.length > 0) cause$2 = causes.pop();
	}
	return accumulator;
});
/** @internal */
const reduceWithContext = /* @__PURE__ */ dual(3, (self, context$2, reducer) => {
	const input = [self];
	const output = [];
	while (input.length > 0) {
		const cause$2 = input.pop();
		switch (cause$2._tag) {
			case OP_EMPTY$2:
				output.push(right(reducer.emptyCase(context$2)));
				break;
			case OP_FAIL$1:
				output.push(right(reducer.failCase(context$2, cause$2.error)));
				break;
			case OP_DIE:
				output.push(right(reducer.dieCase(context$2, cause$2.defect)));
				break;
			case OP_INTERRUPT:
				output.push(right(reducer.interruptCase(context$2, cause$2.fiberId)));
				break;
			case OP_SEQUENTIAL$1:
				input.push(cause$2.right);
				input.push(cause$2.left);
				output.push(left({ _tag: OP_SEQUENTIAL_CASE }));
				break;
			case OP_PARALLEL$1:
				input.push(cause$2.right);
				input.push(cause$2.left);
				output.push(left({ _tag: OP_PARALLEL_CASE }));
				break;
		}
	}
	const accumulator = [];
	while (output.length > 0) {
		const either$4 = output.pop();
		switch (either$4._tag) {
			case "Left":
				switch (either$4.left._tag) {
					case OP_SEQUENTIAL_CASE: {
						const left$2 = accumulator.pop();
						const right$2 = accumulator.pop();
						const value = reducer.sequentialCase(context$2, left$2, right$2);
						accumulator.push(value);
						break;
					}
					case OP_PARALLEL_CASE: {
						const left$2 = accumulator.pop();
						const right$2 = accumulator.pop();
						const value = reducer.parallelCase(context$2, left$2, right$2);
						accumulator.push(value);
						break;
					}
				}
				break;
			case "Right":
				accumulator.push(either$4.right);
				break;
		}
	}
	if (accumulator.length === 0) throw new Error("BUG: Cause.reduceWithContext - please report an issue at https://github.com/Effect-TS/effect/issues");
	return accumulator.pop();
});
/** @internal */
const pretty$2 = (cause$2, options) => {
	if (isInterruptedOnly(cause$2)) return "All fibers interrupted without errors.";
	return prettyErrors(cause$2).map(function(e) {
		if (options?.renderErrorCause !== true || e.cause === void 0) return e.stack;
		return `${e.stack} {\n${renderErrorCause(e.cause, "  ")}\n}`;
	}).join("\n");
};
const renderErrorCause = (cause$2, prefix) => {
	const lines = cause$2.stack.split("\n");
	let stack = `${prefix}[cause]: ${lines[0]}`;
	for (let i = 1, len = lines.length; i < len; i++) stack += `\n${prefix}${lines[i]}`;
	if (cause$2.cause) stack += ` {\n${renderErrorCause(cause$2.cause, `${prefix}  `)}\n${prefix}}`;
	return stack;
};
/** @internal */
var PrettyError = class PrettyError extends globalThis.Error {
	span = void 0;
	constructor(originalError) {
		const originalErrorIsObject = typeof originalError === "object" && originalError !== null;
		const prevLimit = Error.stackTraceLimit;
		Error.stackTraceLimit = 1;
		super(prettyErrorMessage(originalError), originalErrorIsObject && "cause" in originalError && typeof originalError.cause !== "undefined" ? { cause: new PrettyError(originalError.cause) } : void 0);
		if (this.message === "") this.message = "An error has occurred";
		Error.stackTraceLimit = prevLimit;
		this.name = originalError instanceof Error ? originalError.name : "Error";
		if (originalErrorIsObject) {
			if (spanSymbol in originalError) this.span = originalError[spanSymbol];
			Object.keys(originalError).forEach((key) => {
				if (!(key in this)) this[key] = originalError[key];
			});
		}
		this.stack = prettyErrorStack(`${this.name}: ${this.message}`, originalError instanceof Error && originalError.stack ? originalError.stack : "", this.span);
	}
};
/**
* A utility function for generating human-readable error messages from a generic error of type `unknown`.
*
* Rules:
*
* 1) If the input `u` is already a string, it's considered a message.
* 2) If `u` is an Error instance with a message defined, it uses the message.
* 3) If `u` has a user-defined `toString()` method, it uses that method.
* 4) Otherwise, it uses `Inspectable.stringifyCircular` to produce a string representation and uses it as the error message,
*   with "Error" added as a prefix.
*
* @internal
*/
const prettyErrorMessage = (u) => {
	if (typeof u === "string") return u;
	if (typeof u === "object" && u !== null && u instanceof Error) return u.message;
	try {
		if (hasProperty(u, "toString") && isFunction(u["toString"]) && u["toString"] !== Object.prototype.toString && u["toString"] !== globalThis.Array.prototype.toString) return u["toString"]();
	} catch {}
	return stringifyCircular(u);
};
const locationRegex = /\((.*)\)/g;
/** @internal */
const spanToTrace = /* @__PURE__ */ globalValue("effect/Tracer/spanToTrace", () => /* @__PURE__ */ new WeakMap());
const prettyErrorStack = (message, stack, span$1) => {
	const out = [message];
	const lines = stack.startsWith(message) ? stack.slice(message.length).split("\n") : stack.split("\n");
	for (let i = 1; i < lines.length; i++) {
		if (lines[i].includes(" at new BaseEffectError") || lines[i].includes(" at new YieldableError")) {
			i++;
			continue;
		}
		if (lines[i].includes("Generator.next")) break;
		if (lines[i].includes("effect_internal_function")) break;
		out.push(lines[i].replace(/at .*effect_instruction_i.*\((.*)\)/, "at $1").replace(/EffectPrimitive\.\w+/, "<anonymous>"));
	}
	if (span$1) {
		let current = span$1;
		let i = 0;
		while (current && current._tag === "Span" && i < 10) {
			const stackFn = spanToTrace.get(current);
			if (typeof stackFn === "function") {
				const stack$1 = stackFn();
				if (typeof stack$1 === "string") {
					const locationMatchAll = stack$1.matchAll(locationRegex);
					let match$12 = false;
					for (const [, location] of locationMatchAll) {
						match$12 = true;
						out.push(`    at ${current.name} (${location})`);
					}
					if (!match$12) out.push(`    at ${current.name} (${stack$1.replace(/^at /, "")})`);
				} else out.push(`    at ${current.name}`);
			} else out.push(`    at ${current.name}`);
			current = getOrUndefined(current.parent);
			i++;
		}
	}
	return out.join("\n");
};
/** @internal */
const spanSymbol = /* @__PURE__ */ Symbol.for("effect/SpanAnnotation");
/** @internal */
const prettyErrors = (cause$2) => reduceWithContext(cause$2, void 0, {
	emptyCase: () => [],
	dieCase: (_, unknownError) => {
		return [new PrettyError(unknownError)];
	},
	failCase: (_, error) => {
		return [new PrettyError(error)];
	},
	interruptCase: () => [],
	parallelCase: (_, l, r) => [...l, ...r],
	sequentialCase: (_, l, r) => [...l, ...r]
});

//#endregion
//#region ../../node_modules/.bun/effect@3.17.14/node_modules/effect/dist/esm/internal/context.js
/** @internal */
const TagTypeId = /* @__PURE__ */ Symbol.for("effect/Context/Tag");
/** @internal */
const ReferenceTypeId = /* @__PURE__ */ Symbol.for("effect/Context/Reference");
/** @internal */
const STMSymbolKey = "effect/STM";
/** @internal */
const STMTypeId = /* @__PURE__ */ Symbol.for(STMSymbolKey);
/** @internal */
const TagProto = {
	...EffectPrototype$1,
	_op: "Tag",
	[STMTypeId]: effectVariance,
	[TagTypeId]: {
		_Service: (_) => _,
		_Identifier: (_) => _
	},
	toString() {
		return format(this.toJSON());
	},
	toJSON() {
		return {
			_id: "Tag",
			key: this.key,
			stack: this.stack
		};
	},
	[NodeInspectSymbol]() {
		return this.toJSON();
	},
	of(self) {
		return self;
	},
	context(self) {
		return make$37(this, self);
	}
};
const ReferenceProto = {
	...TagProto,
	[ReferenceTypeId]: ReferenceTypeId
};
/** @internal */
const makeGenericTag = (key) => {
	const limit = Error.stackTraceLimit;
	Error.stackTraceLimit = 2;
	const creationError = /* @__PURE__ */ new Error();
	Error.stackTraceLimit = limit;
	const tag = Object.create(TagProto);
	Object.defineProperty(tag, "stack", { get() {
		return creationError.stack;
	} });
	tag.key = key;
	return tag;
};
/** @internal */
const Tag$1 = (id$2) => () => {
	const limit = Error.stackTraceLimit;
	Error.stackTraceLimit = 2;
	const creationError = /* @__PURE__ */ new Error();
	Error.stackTraceLimit = limit;
	function TagClass() {}
	Object.setPrototypeOf(TagClass, TagProto);
	TagClass.key = id$2;
	Object.defineProperty(TagClass, "stack", { get() {
		return creationError.stack;
	} });
	return TagClass;
};
/** @internal */
const Reference$1 = () => (id$2, options) => {
	const limit = Error.stackTraceLimit;
	Error.stackTraceLimit = 2;
	const creationError = /* @__PURE__ */ new Error();
	Error.stackTraceLimit = limit;
	function ReferenceClass() {}
	Object.setPrototypeOf(ReferenceClass, ReferenceProto);
	ReferenceClass.key = id$2;
	ReferenceClass.defaultValue = options.defaultValue;
	Object.defineProperty(ReferenceClass, "stack", { get() {
		return creationError.stack;
	} });
	return ReferenceClass;
};
/** @internal */
const TypeId$13 = /* @__PURE__ */ Symbol.for("effect/Context");
/** @internal */
const ContextProto = {
	[TypeId$13]: { _Services: (_) => _ },
	[symbol](that) {
		if (isContext$1(that)) {
			if (this.unsafeMap.size === that.unsafeMap.size) {
				for (const k of this.unsafeMap.keys()) if (!that.unsafeMap.has(k) || !equals(this.unsafeMap.get(k), that.unsafeMap.get(k))) return false;
				return true;
			}
		}
		return false;
	},
	[symbol$1]() {
		return cached$2(this, number$1(this.unsafeMap.size));
	},
	pipe() {
		return pipeArguments(this, arguments);
	},
	toString() {
		return format(this.toJSON());
	},
	toJSON() {
		return {
			_id: "Context",
			services: Array.from(this.unsafeMap).map(toJSON)
		};
	},
	[NodeInspectSymbol]() {
		return this.toJSON();
	}
};
/** @internal */
const makeContext = (unsafeMap) => {
	const context$2 = Object.create(ContextProto);
	context$2.unsafeMap = unsafeMap;
	return context$2;
};
const serviceNotFoundError = (tag) => {
	const error = /* @__PURE__ */ new Error(`Service not found${tag.key ? `: ${String(tag.key)}` : ""}`);
	if (tag.stack) {
		const lines = tag.stack.split("\n");
		if (lines.length > 2) {
			const afterAt = lines[2].match(/at (.*)/);
			if (afterAt) error.message = error.message + ` (defined at ${afterAt[1]})`;
		}
	}
	if (error.stack) {
		const lines = error.stack.split("\n");
		lines.splice(1, 3);
		error.stack = lines.join("\n");
	}
	return error;
};
/** @internal */
const isContext$1 = (u) => hasProperty(u, TypeId$13);
/** @internal */
const isTag$1 = (u) => hasProperty(u, TagTypeId);
/** @internal */
const isReference$1 = (u) => hasProperty(u, ReferenceTypeId);
const _empty$6 = /* @__PURE__ */ makeContext(/* @__PURE__ */ new Map());
/** @internal */
const empty$26 = () => _empty$6;
/** @internal */
const make$37 = (tag, service) => makeContext(new Map([[tag.key, service]]));
/** @internal */
const add$2 = /* @__PURE__ */ dual(3, (self, tag, service) => {
	const map$17 = new Map(self.unsafeMap);
	map$17.set(tag.key, service);
	return makeContext(map$17);
});
const defaultValueCache = /* @__PURE__ */ globalValue("effect/Context/defaultValueCache", () => /* @__PURE__ */ new Map());
const getDefaultValue = (tag) => {
	if (defaultValueCache.has(tag.key)) return defaultValueCache.get(tag.key);
	const value = tag.defaultValue();
	defaultValueCache.set(tag.key, value);
	return value;
};
/** @internal */
const unsafeGetReference = (self, tag) => {
	return self.unsafeMap.has(tag.key) ? self.unsafeMap.get(tag.key) : getDefaultValue(tag);
};
/** @internal */
const unsafeGet$2 = /* @__PURE__ */ dual(2, (self, tag) => {
	if (!self.unsafeMap.has(tag.key)) {
		if (ReferenceTypeId in tag) return getDefaultValue(tag);
		throw serviceNotFoundError(tag);
	}
	return self.unsafeMap.get(tag.key);
});
/** @internal */
const get$8 = unsafeGet$2;
/** @internal */
const getOrElse$4 = /* @__PURE__ */ dual(3, (self, tag, orElse$6) => {
	if (!self.unsafeMap.has(tag.key)) return isReference$1(tag) ? getDefaultValue(tag) : orElse$6();
	return self.unsafeMap.get(tag.key);
});
/** @internal */
const getOption$1 = /* @__PURE__ */ dual(2, (self, tag) => {
	if (!self.unsafeMap.has(tag.key)) return isReference$1(tag) ? some$5(getDefaultValue(tag)) : none$8;
	return some$5(self.unsafeMap.get(tag.key));
});
/** @internal */
const merge$5 = /* @__PURE__ */ dual(2, (self, that) => {
	const map$17 = new Map(self.unsafeMap);
	for (const [tag, s] of that.unsafeMap) map$17.set(tag, s);
	return makeContext(map$17);
});
/** @internal */
const mergeAll$4 = (...ctxs) => {
	const map$17 = /* @__PURE__ */ new Map();
	for (const ctx of ctxs) for (const [tag, s] of ctx.unsafeMap) map$17.set(tag, s);
	return makeContext(map$17);
};
/** @internal */
const pick$2 = (...tags) => (self) => {
	const tagSet = new Set(tags.map((_) => _.key));
	const newEnv = /* @__PURE__ */ new Map();
	for (const [tag, s] of self.unsafeMap.entries()) if (tagSet.has(tag)) newEnv.set(tag, s);
	return makeContext(newEnv);
};
/** @internal */
const omit$2 = (...tags) => (self) => {
	const newEnv = new Map(self.unsafeMap);
	for (const tag of tags) newEnv.delete(tag.key);
	return makeContext(newEnv);
};

//#endregion
//#region ../../node_modules/.bun/effect@3.17.14/node_modules/effect/dist/esm/Context.js
TagTypeId;
ReferenceTypeId;
/**
* Creates a new `Tag` instance with an optional key parameter.
*
* @example
* ```ts
* import * as assert from "node:assert"
* import { Context } from "effect"
*
* assert.strictEqual(Context.GenericTag("PORT").key === Context.GenericTag("PORT").key, true)
* ```
*
* @since 2.0.0
* @category constructors
*/
const GenericTag = makeGenericTag;
TypeId$13;
/**
* @since 2.0.0
* @category constructors
*/
const unsafeMake$9 = makeContext;
/**
* Checks if the provided argument is a `Context`.
*
* @example
* ```ts
* import * as assert from "node:assert"
* import { Context } from "effect"
*
* assert.strictEqual(Context.isContext(Context.empty()), true)
* ```
*
* @since 2.0.0
* @category guards
*/
const isContext = isContext$1;
/**
* Checks if the provided argument is a `Tag`.
*
* @example
* ```ts
* import * as assert from "node:assert"
* import { Context } from "effect"
*
* assert.strictEqual(Context.isTag(Context.GenericTag("Tag")), true)
* ```
*
* @since 2.0.0
* @category guards
*/
const isTag = isTag$1;
/**
* Checks if the provided argument is a `Reference`.
*
* @since 3.11.0
* @category guards
* @experimental
*/
const isReference = isReference$1;
/**
* Returns an empty `Context`.
*
* @example
* ```ts
* import * as assert from "node:assert"
* import { Context } from "effect"
*
* assert.strictEqual(Context.isContext(Context.empty()), true)
* ```
*
* @since 2.0.0
* @category constructors
*/
const empty$25 = empty$26;
/**
* Creates a new `Context` with a single service associated to the tag.
*
* @example
* ```ts
* import * as assert from "node:assert"
* import { Context } from "effect"
*
* const Port = Context.GenericTag<{ PORT: number }>("Port")
*
* const Services = Context.make(Port, { PORT: 8080 })
*
* assert.deepStrictEqual(Context.get(Services, Port), { PORT: 8080 })
* ```
*
* @since 2.0.0
* @category constructors
*/
const make$36 = make$37;
/**
* Adds a service to a given `Context`.
*
* @example
* ```ts
* import * as assert from "node:assert"
* import { Context, pipe } from "effect"
*
* const Port = Context.GenericTag<{ PORT: number }>("Port")
* const Timeout = Context.GenericTag<{ TIMEOUT: number }>("Timeout")
*
* const someContext = Context.make(Port, { PORT: 8080 })
*
* const Services = pipe(
*   someContext,
*   Context.add(Timeout, { TIMEOUT: 5000 })
* )
*
* assert.deepStrictEqual(Context.get(Services, Port), { PORT: 8080 })
* assert.deepStrictEqual(Context.get(Services, Timeout), { TIMEOUT: 5000 })
* ```
*
* @since 2.0.0
*/
const add$1 = add$2;
/**
* Get a service from the context that corresponds to the given tag.
*
* @example
* ```ts
* import * as assert from "node:assert"
* import { pipe, Context } from "effect"
*
* const Port = Context.GenericTag<{ PORT: number }>("Port")
* const Timeout = Context.GenericTag<{ TIMEOUT: number }>("Timeout")
*
* const Services = pipe(
*   Context.make(Port, { PORT: 8080 }),
*   Context.add(Timeout, { TIMEOUT: 5000 })
* )
*
* assert.deepStrictEqual(Context.get(Services, Timeout), { TIMEOUT: 5000 })
* ```
*
* @since 2.0.0
* @category getters
*/
const get$7 = get$8;
/**
* Get a service from the context that corresponds to the given tag, or
* use the fallback value.
*
* @since 3.7.0
* @category getters
*/
const getOrElse$3 = getOrElse$4;
/**
* Get a service from the context that corresponds to the given tag.
* This function is unsafe because if the tag is not present in the context, a runtime error will be thrown.
*
* For a safer version see {@link getOption}.
*
* @example
* ```ts
* import * as assert from "node:assert"
* import { Context } from "effect"
*
* const Port = Context.GenericTag<{ PORT: number }>("Port")
* const Timeout = Context.GenericTag<{ TIMEOUT: number }>("Timeout")
*
* const Services = Context.make(Port, { PORT: 8080 })
*
* assert.deepStrictEqual(Context.unsafeGet(Services, Port), { PORT: 8080 })
* assert.throws(() => Context.unsafeGet(Services, Timeout))
* ```
*
* @since 2.0.0
* @category unsafe
*/
const unsafeGet$1 = unsafeGet$2;
/**
* Get the value associated with the specified tag from the context wrapped in an `Option` object. If the tag is not
* found, the `Option` object will be `None`.
*
* @example
* ```ts
* import * as assert from "node:assert"
* import { Context, Option } from "effect"
*
* const Port = Context.GenericTag<{ PORT: number }>("Port")
* const Timeout = Context.GenericTag<{ TIMEOUT: number }>("Timeout")
*
* const Services = Context.make(Port, { PORT: 8080 })
*
* assert.deepStrictEqual(Context.getOption(Services, Port), Option.some({ PORT: 8080 }))
* assert.deepStrictEqual(Context.getOption(Services, Timeout), Option.none())
* ```
*
* @since 2.0.0
* @category getters
*/
const getOption = getOption$1;
/**
* Merges two `Context`s, returning a new `Context` containing the services of both.
*
* @example
* ```ts
* import * as assert from "node:assert"
* import { Context } from "effect"
*
* const Port = Context.GenericTag<{ PORT: number }>("Port")
* const Timeout = Context.GenericTag<{ TIMEOUT: number }>("Timeout")
*
* const firstContext = Context.make(Port, { PORT: 8080 })
* const secondContext = Context.make(Timeout, { TIMEOUT: 5000 })
*
* const Services = Context.merge(firstContext, secondContext)
*
* assert.deepStrictEqual(Context.get(Services, Port), { PORT: 8080 })
* assert.deepStrictEqual(Context.get(Services, Timeout), { TIMEOUT: 5000 })
* ```
*
* @since 2.0.0
*/
const merge$4 = merge$5;
/**
* Merges any number of `Context`s, returning a new `Context` containing the services of all.
*
* @example
* ```ts
* import * as assert from "node:assert"
* import { Context } from "effect"
*
* const Port = Context.GenericTag<{ PORT: number }>("Port")
* const Timeout = Context.GenericTag<{ TIMEOUT: number }>("Timeout")
* const Host = Context.GenericTag<{ HOST: string }>("Host")
*
* const firstContext = Context.make(Port, { PORT: 8080 })
* const secondContext = Context.make(Timeout, { TIMEOUT: 5000 })
* const thirdContext = Context.make(Host, { HOST: "localhost" })
*
* const Services = Context.mergeAll(firstContext, secondContext, thirdContext)
*
* assert.deepStrictEqual(Context.get(Services, Port), { PORT: 8080 })
* assert.deepStrictEqual(Context.get(Services, Timeout), { TIMEOUT: 5000 })
* assert.deepStrictEqual(Context.get(Services, Host), { HOST: "localhost" })
* ```
*
* @since 3.12.0
*/
const mergeAll$3 = mergeAll$4;
/**
* Returns a new `Context` that contains only the specified services.
*
* @example
* ```ts
* import * as assert from "node:assert"
* import { pipe, Context, Option } from "effect"
*
* const Port = Context.GenericTag<{ PORT: number }>("Port")
* const Timeout = Context.GenericTag<{ TIMEOUT: number }>("Timeout")
*
* const someContext = pipe(
*   Context.make(Port, { PORT: 8080 }),
*   Context.add(Timeout, { TIMEOUT: 5000 })
* )
*
* const Services = pipe(someContext, Context.pick(Port))
*
* assert.deepStrictEqual(Context.getOption(Services, Port), Option.some({ PORT: 8080 }))
* assert.deepStrictEqual(Context.getOption(Services, Timeout), Option.none())
* ```
*
* @since 2.0.0
*/
const pick$1 = pick$2;
/**
* @since 2.0.0
*/
const omit$1 = omit$2;
/**
* @example
* ```ts
* import * as assert from "node:assert"
* import { Context, Layer } from "effect"
*
* class MyTag extends Context.Tag("MyTag")<
*  MyTag,
*  { readonly myNum: number }
* >() {
*  static Live = Layer.succeed(this, { myNum: 108 })
* }
* ```
*
* @since 2.0.0
* @category constructors
*/
const Tag = Tag$1;
/**
* Creates a context tag with a default value.
*
* **Details**
*
* `Context.Reference` allows you to create a tag that can hold a value. You can
* provide a default value for the service, which will automatically be used
* when the context is accessed, or override it with a custom implementation
* when needed.
*
* **Example** (Declaring a Tag with a default value)
*
* ```ts
* import * as assert from "node:assert"
* import { Context, Effect } from "effect"
*
* class SpecialNumber extends Context.Reference<SpecialNumber>()(
*   "SpecialNumber",
*   { defaultValue: () => 2048 }
* ) {}
*
* //      ┌─── Effect<void, never, never>
* //      ▼
* const program = Effect.gen(function* () {
*   const specialNumber = yield* SpecialNumber
*   console.log(`The special number is ${specialNumber}`)
* })
*
* // No need to provide the SpecialNumber implementation
* Effect.runPromise(program)
* // Output: The special number is 2048
* ```
*
* **Example** (Overriding the default value)
*
* ```ts
* import { Context, Effect } from "effect"
*
* class SpecialNumber extends Context.Reference<SpecialNumber>()(
*   "SpecialNumber",
*   { defaultValue: () => 2048 }
* ) {}
*
* const program = Effect.gen(function* () {
*   const specialNumber = yield* SpecialNumber
*   console.log(`The special number is ${specialNumber}`)
* })
*
* Effect.runPromise(program.pipe(Effect.provideService(SpecialNumber, -1)))
* // Output: The special number is -1
* ```
*
* @since 3.11.0
* @category constructors
* @experimental
*/
const Reference = Reference$1;

//#endregion
//#region ../../node_modules/.bun/effect@3.17.14/node_modules/effect/dist/esm/Duration.js
const TypeId$12 = /* @__PURE__ */ Symbol.for("effect/Duration");
const bigint0$2 = /* @__PURE__ */ BigInt(0);
const bigint24 = /* @__PURE__ */ BigInt(24);
const bigint60 = /* @__PURE__ */ BigInt(60);
const bigint1e3 = /* @__PURE__ */ BigInt(1e3);
const bigint1e6 = /* @__PURE__ */ BigInt(1e6);
const bigint1e9 = /* @__PURE__ */ BigInt(1e9);
const DURATION_REGEX = /^(-?\d+(?:\.\d+)?)\s+(nanos?|micros?|millis?|seconds?|minutes?|hours?|days?|weeks?)$/;
/**
* @since 2.0.0
*/
const decode$3 = (input) => {
	if (isDuration(input)) return input;
	else if (isNumber$1(input)) return millis(input);
	else if (isBigInt(input)) return nanos(input);
	else if (Array.isArray(input) && input.length === 2 && input.every(isNumber$1)) {
		if (input[0] === -Infinity || input[1] === -Infinity || Number.isNaN(input[0]) || Number.isNaN(input[1])) return zero;
		if (input[0] === Infinity || input[1] === Infinity) return infinity;
		return nanos(BigInt(Math.round(input[0] * 1e9)) + BigInt(Math.round(input[1])));
	} else if (isString(input)) {
		const match$12 = DURATION_REGEX.exec(input);
		if (match$12) {
			const [_, valueStr, unit] = match$12;
			const value = Number(valueStr);
			switch (unit) {
				case "nano":
				case "nanos": return nanos(BigInt(valueStr));
				case "micro":
				case "micros": return micros(BigInt(valueStr));
				case "milli":
				case "millis": return millis(value);
				case "second":
				case "seconds": return seconds(value);
				case "minute":
				case "minutes": return minutes(value);
				case "hour":
				case "hours": return hours(value);
				case "day":
				case "days": return days(value);
				case "week":
				case "weeks": return weeks(value);
			}
		}
	}
	throw new Error("Invalid DurationInput");
};
const zeroValue = {
	_tag: "Millis",
	millis: 0
};
const infinityValue = { _tag: "Infinity" };
const DurationProto = {
	[TypeId$12]: TypeId$12,
	[symbol$1]() {
		return cached$2(this, structure(this.value));
	},
	[symbol](that) {
		return isDuration(that) && equals$1(this, that);
	},
	toString() {
		return `Duration(${format$2(this)})`;
	},
	toJSON() {
		switch (this.value._tag) {
			case "Millis": return {
				_id: "Duration",
				_tag: "Millis",
				millis: this.value.millis
			};
			case "Nanos": return {
				_id: "Duration",
				_tag: "Nanos",
				hrtime: toHrTime(this)
			};
			case "Infinity": return {
				_id: "Duration",
				_tag: "Infinity"
			};
		}
	},
	[NodeInspectSymbol]() {
		return this.toJSON();
	},
	pipe() {
		return pipeArguments(this, arguments);
	}
};
const make$35 = (input) => {
	const duration = Object.create(DurationProto);
	if (isNumber$1(input)) if (isNaN(input) || input <= 0) duration.value = zeroValue;
	else if (!Number.isFinite(input)) duration.value = infinityValue;
	else if (!Number.isInteger(input)) duration.value = {
		_tag: "Nanos",
		nanos: BigInt(Math.round(input * 1e6))
	};
	else duration.value = {
		_tag: "Millis",
		millis: input
	};
	else if (input <= bigint0$2) duration.value = zeroValue;
	else duration.value = {
		_tag: "Nanos",
		nanos: input
	};
	return duration;
};
/**
* @since 2.0.0
* @category guards
*/
const isDuration = (u) => hasProperty(u, TypeId$12);
/**
* @since 3.5.0
* @category guards
*/
const isZero = (self) => {
	switch (self.value._tag) {
		case "Millis": return self.value.millis === 0;
		case "Nanos": return self.value.nanos === bigint0$2;
		case "Infinity": return false;
	}
};
/**
* @since 2.0.0
* @category constructors
*/
const zero = /* @__PURE__ */ make$35(0);
/**
* @since 2.0.0
* @category constructors
*/
const infinity = /* @__PURE__ */ make$35(Infinity);
/**
* @since 2.0.0
* @category constructors
*/
const nanos = (nanos$1) => make$35(nanos$1);
/**
* @since 2.0.0
* @category constructors
*/
const micros = (micros$1) => make$35(micros$1 * bigint1e3);
/**
* @since 2.0.0
* @category constructors
*/
const millis = (millis$1) => make$35(millis$1);
/**
* @since 2.0.0
* @category constructors
*/
const seconds = (seconds$1) => make$35(seconds$1 * 1e3);
/**
* @since 2.0.0
* @category constructors
*/
const minutes = (minutes$1) => make$35(minutes$1 * 6e4);
/**
* @since 2.0.0
* @category constructors
*/
const hours = (hours$1) => make$35(hours$1 * 36e5);
/**
* @since 2.0.0
* @category constructors
*/
const days = (days$1) => make$35(days$1 * 864e5);
/**
* @since 2.0.0
* @category constructors
*/
const weeks = (weeks$1) => make$35(weeks$1 * 6048e5);
/**
* @since 2.0.0
* @category getters
*/
const toMillis = (self) => match$8(self, {
	onMillis: (millis$1) => millis$1,
	onNanos: (nanos$1) => Number(nanos$1) / 1e6
});
/**
* Get the duration in nanoseconds as a bigint.
*
* If the duration is infinite, it throws an error.
*
* @since 2.0.0
* @category getters
*/
const unsafeToNanos = (self) => {
	const _self = decode$3(self);
	switch (_self.value._tag) {
		case "Infinity": throw new Error("Cannot convert infinite duration to nanos");
		case "Nanos": return _self.value.nanos;
		case "Millis": return BigInt(Math.round(_self.value.millis * 1e6));
	}
};
/**
* @since 2.0.0
* @category getters
*/
const toHrTime = (self) => {
	const _self = decode$3(self);
	switch (_self.value._tag) {
		case "Infinity": return [Infinity, 0];
		case "Nanos": return [Number(_self.value.nanos / bigint1e9), Number(_self.value.nanos % bigint1e9)];
		case "Millis": return [Math.floor(_self.value.millis / 1e3), Math.round(_self.value.millis % 1e3 * 1e6)];
	}
};
/**
* @since 2.0.0
* @category pattern matching
*/
const match$8 = /* @__PURE__ */ dual(2, (self, options) => {
	const _self = decode$3(self);
	switch (_self.value._tag) {
		case "Nanos": return options.onNanos(_self.value.nanos);
		case "Infinity": return options.onMillis(Infinity);
		case "Millis": return options.onMillis(_self.value.millis);
	}
});
/**
* @since 2.0.0
* @category pattern matching
*/
const matchWith = /* @__PURE__ */ dual(3, (self, that, options) => {
	const _self = decode$3(self);
	const _that = decode$3(that);
	if (_self.value._tag === "Infinity" || _that.value._tag === "Infinity") return options.onMillis(toMillis(_self), toMillis(_that));
	else if (_self.value._tag === "Nanos" || _that.value._tag === "Nanos") {
		const selfNanos = _self.value._tag === "Nanos" ? _self.value.nanos : BigInt(Math.round(_self.value.millis * 1e6));
		const thatNanos = _that.value._tag === "Nanos" ? _that.value.nanos : BigInt(Math.round(_that.value.millis * 1e6));
		return options.onNanos(selfNanos, thatNanos);
	}
	return options.onMillis(_self.value.millis, _that.value.millis);
});
/**
* @category instances
* @since 2.0.0
*/
const Equivalence$1 = (self, that) => matchWith(self, that, {
	onMillis: (self$1, that$1) => self$1 === that$1,
	onNanos: (self$1, that$1) => self$1 === that$1
});
/**
* @since 2.0.0
* @category predicates
*/
const lessThanOrEqualTo$1 = /* @__PURE__ */ dual(2, (self, that) => matchWith(self, that, {
	onMillis: (self$1, that$1) => self$1 <= that$1,
	onNanos: (self$1, that$1) => self$1 <= that$1
}));
/**
* @since 2.0.0
* @category predicates
*/
const greaterThanOrEqualTo$1 = /* @__PURE__ */ dual(2, (self, that) => matchWith(self, that, {
	onMillis: (self$1, that$1) => self$1 >= that$1,
	onNanos: (self$1, that$1) => self$1 >= that$1
}));
/**
* @since 2.0.0
* @category predicates
*/
const equals$1 = /* @__PURE__ */ dual(2, (self, that) => Equivalence$1(decode$3(self), decode$3(that)));
/**
* Converts a `Duration` to its parts.
*
* @since 3.8.0
* @category conversions
*/
const parts = (self) => {
	const duration = decode$3(self);
	if (duration.value._tag === "Infinity") return {
		days: Infinity,
		hours: Infinity,
		minutes: Infinity,
		seconds: Infinity,
		millis: Infinity,
		nanos: Infinity
	};
	const nanos$1 = unsafeToNanos(duration);
	const ms = nanos$1 / bigint1e6;
	const sec = ms / bigint1e3;
	const min$2 = sec / bigint60;
	const hr = min$2 / bigint60;
	const days$1 = hr / bigint24;
	return {
		days: Number(days$1),
		hours: Number(hr % bigint24),
		minutes: Number(min$2 % bigint60),
		seconds: Number(sec % bigint60),
		millis: Number(ms % bigint1e3),
		nanos: Number(nanos$1 % bigint1e6)
	};
};
/**
* Converts a `Duration` to a human readable string.
*
* @since 2.0.0
* @category conversions
* @example
* ```ts
* import { Duration } from "effect"
*
* Duration.format(Duration.millis(1000)) // "1s"
* Duration.format(Duration.millis(1001)) // "1s 1ms"
* ```
*/
const format$2 = (self) => {
	const duration = decode$3(self);
	if (duration.value._tag === "Infinity") return "Infinity";
	if (isZero(duration)) return "0";
	const fragments = parts(duration);
	const pieces = [];
	if (fragments.days !== 0) pieces.push(`${fragments.days}d`);
	if (fragments.hours !== 0) pieces.push(`${fragments.hours}h`);
	if (fragments.minutes !== 0) pieces.push(`${fragments.minutes}m`);
	if (fragments.seconds !== 0) pieces.push(`${fragments.seconds}s`);
	if (fragments.millis !== 0) pieces.push(`${fragments.millis}ms`);
	if (fragments.nanos !== 0) pieces.push(`${fragments.nanos}ns`);
	return pieces.join(" ");
};

//#endregion
//#region ../../node_modules/.bun/effect@3.17.14/node_modules/effect/dist/esm/MutableRef.js
const TypeId$11 = /* @__PURE__ */ Symbol.for("effect/MutableRef");
const MutableRefProto = {
	[TypeId$11]: TypeId$11,
	toString() {
		return format(this.toJSON());
	},
	toJSON() {
		return {
			_id: "MutableRef",
			current: toJSON(this.current)
		};
	},
	[NodeInspectSymbol]() {
		return this.toJSON();
	},
	pipe() {
		return pipeArguments(this, arguments);
	}
};
/**
* @since 2.0.0
* @category constructors
*/
const make$34 = (value) => {
	const ref = Object.create(MutableRefProto);
	ref.current = value;
	return ref;
};
/**
* @since 2.0.0
* @category general
*/
const compareAndSet = /* @__PURE__ */ dual(3, (self, oldValue, newValue) => {
	if (equals(oldValue, self.current)) {
		self.current = newValue;
		return true;
	}
	return false;
});
/**
* @since 2.0.0
* @category general
*/
const get$6 = (self) => self.current;
/**
* @since 2.0.0
* @category general
*/
const set$4 = /* @__PURE__ */ dual(2, (self, value) => {
	self.current = value;
	return self;
});

//#endregion
//#region ../../node_modules/.bun/effect@3.17.14/node_modules/effect/dist/esm/internal/fiberId.js
/** @internal */
const FiberIdSymbolKey = "effect/FiberId";
/** @internal */
const FiberIdTypeId$1 = /* @__PURE__ */ Symbol.for(FiberIdSymbolKey);
/** @internal */
const OP_NONE = "None";
/** @internal */
const OP_RUNTIME = "Runtime";
/** @internal */
const OP_COMPOSITE = "Composite";
const emptyHash = /* @__PURE__ */ string(`${FiberIdSymbolKey}-${OP_NONE}`);
/** @internal */
var None$2 = class {
	[FiberIdTypeId$1] = FiberIdTypeId$1;
	_tag = OP_NONE;
	id = -1;
	startTimeMillis = -1;
	[symbol$1]() {
		return emptyHash;
	}
	[symbol](that) {
		return isFiberId$1(that) && that._tag === OP_NONE;
	}
	toString() {
		return format(this.toJSON());
	}
	toJSON() {
		return {
			_id: "FiberId",
			_tag: this._tag
		};
	}
	[NodeInspectSymbol]() {
		return this.toJSON();
	}
};
/** @internal */
var Runtime = class {
	id;
	startTimeMillis;
	[FiberIdTypeId$1] = FiberIdTypeId$1;
	_tag = OP_RUNTIME;
	constructor(id$2, startTimeMillis) {
		this.id = id$2;
		this.startTimeMillis = startTimeMillis;
	}
	[symbol$1]() {
		return cached$2(this, string(`${FiberIdSymbolKey}-${this._tag}-${this.id}-${this.startTimeMillis}`));
	}
	[symbol](that) {
		return isFiberId$1(that) && that._tag === OP_RUNTIME && this.id === that.id && this.startTimeMillis === that.startTimeMillis;
	}
	toString() {
		return format(this.toJSON());
	}
	toJSON() {
		return {
			_id: "FiberId",
			_tag: this._tag,
			id: this.id,
			startTimeMillis: this.startTimeMillis
		};
	}
	[NodeInspectSymbol]() {
		return this.toJSON();
	}
};
/** @internal */
var Composite$1 = class {
	left;
	right;
	[FiberIdTypeId$1] = FiberIdTypeId$1;
	_tag = OP_COMPOSITE;
	constructor(left$2, right$2) {
		this.left = left$2;
		this.right = right$2;
	}
	_hash;
	[symbol$1]() {
		return pipe(string(`${FiberIdSymbolKey}-${this._tag}`), combine$11(hash(this.left)), combine$11(hash(this.right)), cached$2(this));
	}
	[symbol](that) {
		return isFiberId$1(that) && that._tag === OP_COMPOSITE && equals(this.left, that.left) && equals(this.right, that.right);
	}
	toString() {
		return format(this.toJSON());
	}
	toJSON() {
		return {
			_id: "FiberId",
			_tag: this._tag,
			left: toJSON(this.left),
			right: toJSON(this.right)
		};
	}
	[NodeInspectSymbol]() {
		return this.toJSON();
	}
};
/** @internal */
const none$1 = /* @__PURE__ */ new None$2();
/** @internal */
const runtime$3 = (id$2, startTimeMillis) => {
	return new Runtime(id$2, startTimeMillis);
};
/** @internal */
const composite$1 = (left$2, right$2) => {
	return new Composite$1(left$2, right$2);
};
/** @internal */
const isFiberId$1 = (self) => hasProperty(self, FiberIdTypeId$1);
/** @internal */
const isNone$1 = (self) => {
	return self._tag === OP_NONE || pipe(toSet$3(self), every$3((id$2) => isNone$1(id$2)));
};
/** @internal */
const isRuntime$1 = (self) => {
	return self._tag === OP_RUNTIME;
};
/** @internal */
const isComposite$2 = (self) => {
	return self._tag === OP_COMPOSITE;
};
/** @internal */
const combine$10 = /* @__PURE__ */ dual(2, (self, that) => {
	if (self._tag === OP_NONE) return that;
	if (that._tag === OP_NONE) return self;
	return new Composite$1(self, that);
});
/** @internal */
const combineAll$1 = (fiberIds) => {
	return pipe(fiberIds, reduce$7(none$1, (a, b) => combine$10(b)(a)));
};
/** @internal */
const getOrElse$2 = /* @__PURE__ */ dual(2, (self, that) => isNone$1(self) ? that : self);
/** @internal */
const ids$1 = (self) => {
	switch (self._tag) {
		case OP_NONE: return empty$28();
		case OP_RUNTIME: return make$38(self.id);
		case OP_COMPOSITE: return pipe(ids$1(self.left), union$5(ids$1(self.right)));
	}
};
const _fiberCounter = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/Fiber/Id/_fiberCounter"), () => make$34(0));
/** @internal */
const make$33 = (id$2, startTimeSeconds) => {
	return new Runtime(id$2, startTimeSeconds);
};
/** @internal */
const threadName$1 = (self) => {
	return Array.from(ids$1(self)).map((n) => `#${n}`).join(",");
};
/** @internal */
const toOption$1 = (self) => {
	const fiberIds = toSet$3(self);
	if (size$6(fiberIds) === 0) return none$7();
	let first$2 = true;
	let acc;
	for (const fiberId$2 of fiberIds) if (first$2) {
		acc = fiberId$2;
		first$2 = false;
	} else acc = pipe(acc, combine$10(fiberId$2));
	return some$4(acc);
};
/** @internal */
const toSet$3 = (self) => {
	switch (self._tag) {
		case OP_NONE: return empty$28();
		case OP_RUNTIME: return make$38(self);
		case OP_COMPOSITE: return pipe(toSet$3(self.left), union$5(toSet$3(self.right)));
	}
};
/** @internal */
const unsafeMake$8 = () => {
	const id$2 = get$6(_fiberCounter);
	pipe(_fiberCounter, set$4(id$2 + 1));
	return new Runtime(id$2, Date.now());
};

//#endregion
//#region ../../node_modules/.bun/effect@3.17.14/node_modules/effect/dist/esm/FiberId.js
/**
* @since 2.0.0
* @category symbols
*/
const FiberIdTypeId = FiberIdTypeId$1;
/**
* @since 2.0.0
* @category constructors
*/
const none$6 = none$1;
/**
* @since 2.0.0
* @category constructors
*/
const runtime$2 = runtime$3;
/**
* @since 2.0.0
* @category constructors
*/
const composite = composite$1;
/**
* Returns `true` if the specified unknown value is a `FiberId`, `false`
* otherwise.
*
* @since 2.0.0
* @category refinements
*/
const isFiberId = isFiberId$1;
/**
* Returns `true` if the `FiberId` is a `None`, `false` otherwise.
*
* @since 2.0.0
* @category refinements
*/
const isNone = isNone$1;
/**
* Returns `true` if the `FiberId` is a `Runtime`, `false` otherwise.
*
* @since 2.0.0
* @category refinements
*/
const isRuntime = isRuntime$1;
/**
* Returns `true` if the `FiberId` is a `Composite`, `false` otherwise.
*
* @since 2.0.0
* @category refinements
*/
const isComposite$1 = isComposite$2;
/**
* Combine two `FiberId`s.
*
* @since 2.0.0
* @category constructors
*/
const combine$9 = combine$10;
/**
* Combines a set of `FiberId`s into a single `FiberId`.
*
* @since 2.0.0
* @category constructors
*/
const combineAll = combineAll$1;
/**
* Returns this `FiberId` if it is not `None`, otherwise returns that `FiberId`.
*
* @since 2.0.0
* @category utils
*/
const getOrElse$1 = getOrElse$2;
/**
* Get the set of identifiers for this `FiberId`.
*
* @since 2.0.0
* @category destructors
*/
const ids = ids$1;
/**
* Creates a new `FiberId`.
*
* @since 2.0.0
* @category constructors
*/
const make$32 = make$33;
/**
* Creates a string representing the name of the current thread of execution
* represented by the specified `FiberId`.
*
* @since 2.0.0
* @category destructors
*/
const threadName = threadName$1;
/**
* Convert a `FiberId` into an `Option<FiberId>`.
*
* @since 2.0.0
* @category destructors
*/
const toOption = toOption$1;
/**
* Convert a `FiberId` into a `HashSet<FiberId>`.
*
* @since 2.0.0
* @category destructors
*/
const toSet$2 = toSet$3;
/**
* Unsafely creates a new `FiberId`.
*
* @since 2.0.0
* @category unsafe
*/
const unsafeMake$7 = unsafeMake$8;

//#endregion
//#region ../../node_modules/.bun/effect@3.17.14/node_modules/effect/dist/esm/internal/hashMap/keySet.js
/** @internal */
function keySet$1(self) {
	return makeImpl$1(self);
}

//#endregion
//#region ../../node_modules/.bun/effect@3.17.14/node_modules/effect/dist/esm/HashMap.js
HashMapTypeId;
/**
* @since 2.0.0
* @category refinements
*/
const isHashMap = isHashMap$1;
/**
* Creates a new `HashMap`.
*
* @since 2.0.0
* @category constructors
*/
const empty$24 = empty$30;
/**
* Constructs a new `HashMap` from an array of key/value pairs.
*
* @since 2.0.0
* @category constructors
*/
const make$31 = make$40;
/**
* Creates a new `HashMap` from an iterable collection of key/value pairs.
*
* @since 2.0.0
* @category constructors
*/
const fromIterable$5 = fromIterable$8;
/**
* Checks if the `HashMap` contains any entries.
*
* @since 2.0.0
* @category elements
*/
const isEmpty$5 = isEmpty$7;
/**
* Safely lookup the value for the specified key in the `HashMap` using the
* internal hashing function.
*
* @since 2.0.0
* @category elements
*/
const get$5 = get$9;
/**
* Lookup the value for the specified key in the `HashMap` using a custom hash.
*
* @since 2.0.0
* @category elements
*/
const getHash = getHash$1;
/**
* Unsafely lookup the value for the specified key in the `HashMap` using the
* internal hashing function.
*
* @since 2.0.0
* @category unsafe
*/
const unsafeGet = unsafeGet$3;
/**
* Checks if the specified key has an entry in the `HashMap`.
*
* @since 2.0.0
* @category elements
*/
const has$3 = has$6;
/**
* Checks if the specified key has an entry in the `HashMap` using a custom
* hash.
*
* @since 2.0.0
* @category elements
*/
const hasHash = hasHash$1;
/**
* Checks if an element matching the given predicate exists in the given `HashMap`.
*
* @example
* ```ts
* import { HashMap } from "effect"
*
* const hm = HashMap.make([1, 'a'])
* HashMap.hasBy(hm, (value, key) => value === 'a' && key === 1); // -> true
* HashMap.hasBy(hm, (value) => value === 'b'); // -> false
*
* ```
*
* @since 3.16.0
* @category elements
*/
const hasBy = hasBy$1;
/**
* Sets the specified key to the specified value using the internal hashing
* function.
*
* @since 2.0.0
*/
const set$3 = set$5;
/**
* Returns an `IterableIterator` of the keys within the `HashMap`.
*
* @since 2.0.0
* @category getters
*/
const keys$2 = keys$3;
/**
* Returns a `HashSet` of keys within the `HashMap`.
*
* @since 2.0.0
* @category getter
*/
const keySet = keySet$1;
/**
* Returns an `IterableIterator` of the values within the `HashMap`.
*
* @since 2.0.0
* @category getters
*/
const values$2 = values$5;
/**
* Returns an `IterableIterator` of the entries within the `HashMap`.
*
* @since 2.0.0
* @category getters
*/
const entries = entries$1;
/**
* Returns the number of entries within the `HashMap`.
*
* @since 2.0.0
* @category getters
*/
const size$5 = size$8;
/**
* Counts all the element of the given HashMap that pass the given predicate
*
* **Example**
*
* ```ts
* import { HashMap } from "effect"
*
* const map = HashMap.make([1, "a"], [2, "b"], [3, "c"])
* const result = HashMap.countBy(map, (_v, key) => key % 2 === 1)
* console.log(result) // 2
* ```
*
* @since 3.17.0
* @category folding
*/
const countBy = countBy$1;
/**
* Marks the `HashMap` as mutable.
*
* @since 2.0.0
*/
const beginMutation = beginMutation$3;
/**
* Marks the `HashMap` as immutable.
*
* @since 2.0.0
*/
const endMutation = endMutation$3;
/**
* Mutates the `HashMap` within the context of the provided function.
*
* @since 2.0.0
*/
const mutate = mutate$3;
/**
* Set or remove the specified key in the `HashMap` using the specified
* update function. The value of the specified key will be computed using the
* provided hash.
*
* The update function will be invoked with the current value of the key if it
* exists, or `None` if no such value exists.
*
* @since 2.0.0
*/
const modifyAt = modifyAt$1;
/**
* Alter the value of the specified key in the `HashMap` using the specified
* update function. The value of the specified key will be computed using the
* provided hash.
*
* The update function will be invoked with the current value of the key if it
* exists, or `None` if no such value exists.
*
* This function will always either update or insert a value into the `HashMap`.
*
* @since 2.0.0
*/
const modifyHash = modifyHash$1;
/**
* Updates the value of the specified key within the `HashMap` if it exists.
*
* @since 2.0.0
*/
const modify$2 = modify$3;
/**
* Performs a union of this `HashMap` and that `HashMap`.
*
* @since 2.0.0
*/
const union$4 = union$7;
/**
* Remove the entry for the specified key in the `HashMap` using the internal
* hashing function.
*
* @since 2.0.0
*/
const remove$3 = remove$6;
/**
* Removes all entries in the `HashMap` which have the specified keys.
*
* @since 2.0.0
*/
const removeMany = removeMany$1;
/**
* Maps over the entries of the `HashMap` using the specified function.
*
* @since 2.0.0
* @category mapping
*/
const map$9 = map$13;
/**
* Chains over the entries of the `HashMap` using the specified function.
*
* **NOTE**: the hash and equal of both maps have to be the same.
*
* @since 2.0.0
* @category sequencing
*/
const flatMap$5 = flatMap$9;
/**
* Applies the specified function to the entries of the `HashMap`.
*
* @since 2.0.0
* @category traversing
*/
const forEach$5 = forEach$8;
/**
* Reduces the specified state over the entries of the `HashMap`.
*
* @since 2.0.0
* @category folding
*/
const reduce$5 = reduce$9;
/**
* Filters entries out of a `HashMap` using the specified predicate.
*
* @since 2.0.0
* @category filtering
*/
const filter$3 = filter$6;
/**
* Filters out `None` values from a `HashMap` of `Options`s.
*
* @since 2.0.0
* @category filtering
*/
const compact = compact$1;
/**
* Maps over the entries of the `HashMap` using the specified partial function
* and filters out `None` values.
*
* @since 2.0.0
* @category filtering
*/
const filterMap$2 = filterMap$3;
/**
* Returns the first element that satisfies the specified
* predicate, or `None` if no such element exists.
*
* @category elements
* @since 2.0.0
*/
const findFirst$4 = findFirst$5;
/**
* Checks if any entry in a hashmap meets a specific condition.
*
* @since 3.13.0
* @category elements
*/
const some = some$3;
/**
* Checks if all entries in a hashmap meets a specific condition.
*
* @param self - The hashmap to check.
* @param predicate - The condition to test entries (value, key).
*
* @since 3.14.0
* @category elements
*/
const every$2 = every$5;

//#endregion
//#region ../../node_modules/.bun/effect@3.17.14/node_modules/effect/dist/esm/List.js
/**
* @since 2.0.0
* @category symbol
*/
const TypeId$10 = /* @__PURE__ */ Symbol.for("effect/List");
/**
* Converts the specified `List` to an `Array`.
*
* @category conversions
* @since 2.0.0
*/
const toArray = (self) => fromIterable$10(self);
/**
* @category equivalence
* @since 2.0.0
*/
const getEquivalence$1 = (isEquivalent) => mapInput$1(getEquivalence$3(isEquivalent), toArray);
const _equivalence = /* @__PURE__ */ getEquivalence$1(equals);
const ConsProto = {
	[TypeId$10]: TypeId$10,
	_tag: "Cons",
	toString() {
		return format(this.toJSON());
	},
	toJSON() {
		return {
			_id: "List",
			_tag: "Cons",
			values: toArray(this).map(toJSON)
		};
	},
	[NodeInspectSymbol]() {
		return this.toJSON();
	},
	[symbol](that) {
		return isList(that) && this._tag === that._tag && _equivalence(this, that);
	},
	[symbol$1]() {
		return cached$2(this, array$1(toArray(this)));
	},
	[Symbol.iterator]() {
		let done$8 = false;
		let self = this;
		return {
			next() {
				if (done$8) return this.return();
				if (self._tag === "Nil") {
					done$8 = true;
					return this.return();
				}
				const value = self.head;
				self = self.tail;
				return {
					done: done$8,
					value
				};
			},
			return(value) {
				if (!done$8) done$8 = true;
				return {
					done: true,
					value
				};
			}
		};
	},
	pipe() {
		return pipeArguments(this, arguments);
	}
};
const makeCons = (head$4, tail) => {
	const cons$1 = Object.create(ConsProto);
	cons$1.head = head$4;
	cons$1.tail = tail;
	return cons$1;
};
const NilHash = /* @__PURE__ */ string("Nil");
const NilProto = {
	[TypeId$10]: TypeId$10,
	_tag: "Nil",
	toString() {
		return format(this.toJSON());
	},
	toJSON() {
		return {
			_id: "List",
			_tag: "Nil"
		};
	},
	[NodeInspectSymbol]() {
		return this.toJSON();
	},
	[symbol$1]() {
		return NilHash;
	},
	[symbol](that) {
		return isList(that) && this._tag === that._tag;
	},
	[Symbol.iterator]() {
		return { next() {
			return {
				done: true,
				value: void 0
			};
		} };
	},
	pipe() {
		return pipeArguments(this, arguments);
	}
};
const _Nil = /* @__PURE__ */ Object.create(NilProto);
/**
* Returns `true` if the specified value is a `List`, `false` otherwise.
*
* @since 2.0.0
* @category refinements
*/
const isList = (u) => hasProperty(u, TypeId$10);
/**
* Returns `true` if the specified value is a `List.Nil<A>`, `false` otherwise.
*
* @since 2.0.0
* @category refinements
*/
const isNil = (self) => self._tag === "Nil";
/**
* Returns `true` if the specified value is a `List.Cons<A>`, `false` otherwise.
*
* @since 2.0.0
* @category refinements
*/
const isCons = (self) => self._tag === "Cons";
/**
* Constructs a new empty `List<A>`.
*
* @since 2.0.0
* @category constructors
*/
const nil = () => _Nil;
/**
* Constructs a new `List.Cons<A>` from the specified `head` and `tail` values.
*
* @since 2.0.0
* @category constructors
*/
const cons = (head$4, tail) => makeCons(head$4, tail);
/**
* Constructs a new empty `List<A>`.
*
* Alias of {@link nil}.
*
* @since 2.0.0
* @category constructors
*/
const empty$23 = nil;
/**
* Constructs a new `List<A>` from the specified value.
*
* @since 2.0.0
* @category constructors
*/
const of$2 = (value) => makeCons(value, _Nil);
/**
* Concatenates two lists, combining their elements.
* If either list is non-empty, the result is also a non-empty list.
*
* @example
* ```ts
* import * as assert from "node:assert"
* import { List } from "effect"
*
* assert.deepStrictEqual(
*   List.make(1, 2).pipe(List.appendAll(List.make("a", "b")), List.toArray),
*   [1, 2, "a", "b"]
* )
* ```
*
* @category concatenating
* @since 2.0.0
*/
const appendAll = /* @__PURE__ */ dual(2, (self, that) => prependAll(that, self));
/**
* Prepends the specified element to the beginning of the list.
*
* @category concatenating
* @since 2.0.0
*/
const prepend = /* @__PURE__ */ dual(2, (self, element) => cons(element, self));
/**
* Prepends the specified prefix list to the beginning of the specified list.
* If either list is non-empty, the result is also a non-empty list.
*
* @example
* ```ts
* import * as assert from "node:assert"
* import { List } from "effect"
*
* assert.deepStrictEqual(
*   List.make(1, 2).pipe(List.prependAll(List.make("a", "b")), List.toArray),
*   ["a", "b", 1, 2]
* )
* ```
*
* @category concatenating
* @since 2.0.0
*/
const prependAll = /* @__PURE__ */ dual(2, (self, prefix) => {
	if (isNil(self)) return prefix;
	else if (isNil(prefix)) return self;
	else {
		const result = makeCons(prefix.head, self);
		let curr = result;
		let that = prefix.tail;
		while (!isNil(that)) {
			const temp = makeCons(that.head, self);
			curr.tail = temp;
			curr = temp;
			that = that.tail;
		}
		return result;
	}
});
/**
* Folds over the elements of the list using the specified function, using the
* specified initial value.
*
* @since 2.0.0
* @category folding
*/
const reduce$4 = /* @__PURE__ */ dual(3, (self, zero$1, f) => {
	let acc = zero$1;
	let these = self;
	while (!isNil(these)) {
		acc = f(acc, these.head);
		these = these.tail;
	}
	return acc;
});
/**
* Returns a new list with the elements of the specified list in reverse order.
*
* @since 2.0.0
* @category elements
*/
const reverse = (self) => {
	let result = empty$23();
	let these = self;
	while (!isNil(these)) {
		result = prepend(result, these.head);
		these = these.tail;
	}
	return result;
};

//#endregion
//#region ../../node_modules/.bun/effect@3.17.14/node_modules/effect/dist/esm/internal/data.js
/** @internal */
const ArrayProto = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(Array.prototype), {
	[symbol$1]() {
		return cached$2(this, array$1(this));
	},
	[symbol](that) {
		if (Array.isArray(that) && this.length === that.length) return this.every((v, i) => equals(v, that[i]));
		else return false;
	}
});
/** @internal */
const Structural$1 = /* @__PURE__ */ function() {
	function Structural$2(args$1) {
		if (args$1) Object.assign(this, args$1);
	}
	Structural$2.prototype = StructuralPrototype;
	return Structural$2;
}();
/** @internal */
const struct$1 = (as$4) => Object.assign(Object.create(StructuralPrototype), as$4);

//#endregion
//#region ../../node_modules/.bun/effect@3.17.14/node_modules/effect/dist/esm/internal/differ/chunkPatch.js
/** @internal */
const ChunkPatchTypeId = /* @__PURE__ */ Symbol.for("effect/DifferChunkPatch");
function variance$6(a) {
	return a;
}
const PatchProto$5 = {
	...Structural$1.prototype,
	[ChunkPatchTypeId]: {
		_Value: variance$6,
		_Patch: variance$6
	}
};
const EmptyProto$5 = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(PatchProto$5), { _tag: "Empty" });
const _empty$5 = /* @__PURE__ */ Object.create(EmptyProto$5);
/**
* @internal
*/
const empty$22 = () => _empty$5;
const AndThenProto$5 = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(PatchProto$5), { _tag: "AndThen" });
const makeAndThen$5 = (first$2, second) => {
	const o = Object.create(AndThenProto$5);
	o.first = first$2;
	o.second = second;
	return o;
};
const AppendProto$1 = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(PatchProto$5), { _tag: "Append" });
const makeAppend$1 = (values$6) => {
	const o = Object.create(AppendProto$1);
	o.values = values$6;
	return o;
};
const SliceProto$1 = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(PatchProto$5), { _tag: "Slice" });
const makeSlice$1 = (from, until) => {
	const o = Object.create(SliceProto$1);
	o.from = from;
	o.until = until;
	return o;
};
const UpdateProto$2 = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(PatchProto$5), { _tag: "Update" });
const makeUpdate$2 = (index, patch$11) => {
	const o = Object.create(UpdateProto$2);
	o.index = index;
	o.patch = patch$11;
	return o;
};
/** @internal */
const diff$9 = (options) => {
	let i = 0;
	let patch$11 = empty$22();
	while (i < options.oldValue.length && i < options.newValue.length) {
		const oldElement = unsafeGet$4(i)(options.oldValue);
		const newElement = unsafeGet$4(i)(options.newValue);
		const valuePatch = options.differ.diff(oldElement, newElement);
		if (!equals(valuePatch, options.differ.empty)) patch$11 = pipe(patch$11, combine$8(makeUpdate$2(i, valuePatch)));
		i = i + 1;
	}
	if (i < options.oldValue.length) patch$11 = pipe(patch$11, combine$8(makeSlice$1(0, i)));
	if (i < options.newValue.length) patch$11 = pipe(patch$11, combine$8(makeAppend$1(drop(i)(options.newValue))));
	return patch$11;
};
/** @internal */
const combine$8 = /* @__PURE__ */ dual(2, (self, that) => makeAndThen$5(self, that));
/** @internal */
const patch$10 = /* @__PURE__ */ dual(3, (self, oldValue, differ$2) => {
	if (self._tag === "Empty") return oldValue;
	let chunk$2 = oldValue;
	let patches = of$3(self);
	while (isNonEmpty$5(patches)) {
		const head$4 = headNonEmpty(patches);
		const tail = tailNonEmpty(patches);
		switch (head$4._tag) {
			case "Empty":
				patches = tail;
				break;
			case "AndThen":
				patches = prepend$1(head$4.first)(prepend$1(head$4.second)(tail));
				break;
			case "Append":
				chunk$2 = appendAll$1(head$4.values)(chunk$2);
				patches = tail;
				break;
			case "Slice": {
				const array$3 = toReadonlyArray(chunk$2);
				chunk$2 = unsafeFromArray(array$3.slice(head$4.from, head$4.until));
				patches = tail;
				break;
			}
			case "Update": {
				const array$3 = toReadonlyArray(chunk$2);
				array$3[head$4.index] = differ$2.patch(head$4.patch, array$3[head$4.index]);
				chunk$2 = unsafeFromArray(array$3);
				patches = tail;
				break;
			}
		}
	}
	return chunk$2;
});

//#endregion
//#region ../../node_modules/.bun/effect@3.17.14/node_modules/effect/dist/esm/internal/differ/contextPatch.js
/** @internal */
const ContextPatchTypeId = /* @__PURE__ */ Symbol.for("effect/DifferContextPatch");
function variance$5(a) {
	return a;
}
/** @internal */
const PatchProto$4 = {
	...Structural$1.prototype,
	[ContextPatchTypeId]: {
		_Value: variance$5,
		_Patch: variance$5
	}
};
const EmptyProto$4 = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(PatchProto$4), { _tag: "Empty" });
const _empty$4 = /* @__PURE__ */ Object.create(EmptyProto$4);
/**
* @internal
*/
const empty$21 = () => _empty$4;
const AndThenProto$4 = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(PatchProto$4), { _tag: "AndThen" });
const makeAndThen$4 = (first$2, second) => {
	const o = Object.create(AndThenProto$4);
	o.first = first$2;
	o.second = second;
	return o;
};
const AddServiceProto = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(PatchProto$4), { _tag: "AddService" });
const makeAddService = (key, service) => {
	const o = Object.create(AddServiceProto);
	o.key = key;
	o.service = service;
	return o;
};
const RemoveServiceProto = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(PatchProto$4), { _tag: "RemoveService" });
const makeRemoveService = (key) => {
	const o = Object.create(RemoveServiceProto);
	o.key = key;
	return o;
};
const UpdateServiceProto = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(PatchProto$4), { _tag: "UpdateService" });
const makeUpdateService = (key, update$5) => {
	const o = Object.create(UpdateServiceProto);
	o.key = key;
	o.update = update$5;
	return o;
};
/** @internal */
const diff$8 = (oldValue, newValue) => {
	const missingServices = new Map(oldValue.unsafeMap);
	let patch$11 = empty$21();
	for (const [tag, newService] of newValue.unsafeMap.entries()) if (missingServices.has(tag)) {
		const old = missingServices.get(tag);
		missingServices.delete(tag);
		if (!equals(old, newService)) patch$11 = combine$7(makeUpdateService(tag, () => newService))(patch$11);
	} else {
		missingServices.delete(tag);
		patch$11 = combine$7(makeAddService(tag, newService))(patch$11);
	}
	for (const [tag] of missingServices.entries()) patch$11 = combine$7(makeRemoveService(tag))(patch$11);
	return patch$11;
};
/** @internal */
const combine$7 = /* @__PURE__ */ dual(2, (self, that) => makeAndThen$4(self, that));
/** @internal */
const patch$9 = /* @__PURE__ */ dual(2, (self, context$2) => {
	if (self._tag === "Empty") return context$2;
	let wasServiceUpdated = false;
	let patches = of$3(self);
	const updatedContext = new Map(context$2.unsafeMap);
	while (isNonEmpty$5(patches)) {
		const head$4 = headNonEmpty(patches);
		const tail = tailNonEmpty(patches);
		switch (head$4._tag) {
			case "Empty":
				patches = tail;
				break;
			case "AddService":
				updatedContext.set(head$4.key, head$4.service);
				patches = tail;
				break;
			case "AndThen":
				patches = prepend$1(prepend$1(tail, head$4.second), head$4.first);
				break;
			case "RemoveService":
				updatedContext.delete(head$4.key);
				patches = tail;
				break;
			case "UpdateService":
				updatedContext.set(head$4.key, head$4.update(updatedContext.get(head$4.key)));
				wasServiceUpdated = true;
				patches = tail;
				break;
		}
	}
	if (!wasServiceUpdated) return makeContext(updatedContext);
	const map$17 = /* @__PURE__ */ new Map();
	for (const [tag] of context$2.unsafeMap) if (updatedContext.has(tag)) {
		map$17.set(tag, updatedContext.get(tag));
		updatedContext.delete(tag);
	}
	for (const [tag, s] of updatedContext) map$17.set(tag, s);
	return makeContext(map$17);
});

//#endregion
//#region ../../node_modules/.bun/effect@3.17.14/node_modules/effect/dist/esm/internal/differ/hashMapPatch.js
/** @internal */
const HashMapPatchTypeId = /* @__PURE__ */ Symbol.for("effect/DifferHashMapPatch");
function variance$4(a) {
	return a;
}
/** @internal */
const PatchProto$3 = {
	...Structural$1.prototype,
	[HashMapPatchTypeId]: {
		_Value: variance$4,
		_Key: variance$4,
		_Patch: variance$4
	}
};
const EmptyProto$3 = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(PatchProto$3), { _tag: "Empty" });
const _empty$3 = /* @__PURE__ */ Object.create(EmptyProto$3);
/** @internal */
const empty$20 = () => _empty$3;
const AndThenProto$3 = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(PatchProto$3), { _tag: "AndThen" });
const makeAndThen$3 = (first$2, second) => {
	const o = Object.create(AndThenProto$3);
	o.first = first$2;
	o.second = second;
	return o;
};
const AddProto$1 = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(PatchProto$3), { _tag: "Add" });
const makeAdd$1 = (key, value) => {
	const o = Object.create(AddProto$1);
	o.key = key;
	o.value = value;
	return o;
};
const RemoveProto$1 = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(PatchProto$3), { _tag: "Remove" });
const makeRemove$1 = (key) => {
	const o = Object.create(RemoveProto$1);
	o.key = key;
	return o;
};
const UpdateProto$1 = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(PatchProto$3), { _tag: "Update" });
const makeUpdate$1 = (key, patch$11) => {
	const o = Object.create(UpdateProto$1);
	o.key = key;
	o.patch = patch$11;
	return o;
};
/** @internal */
const diff$7 = (options) => {
	const [removed, patch$11] = reduce$5([options.oldValue, empty$20()], ([map$17, patch$12], newValue, key) => {
		const option$2 = get$5(key)(map$17);
		switch (option$2._tag) {
			case "Some": {
				const valuePatch = options.differ.diff(option$2.value, newValue);
				if (equals(valuePatch, options.differ.empty)) return [remove$3(key)(map$17), patch$12];
				return [remove$3(key)(map$17), combine$6(makeUpdate$1(key, valuePatch))(patch$12)];
			}
			case "None": return [map$17, combine$6(makeAdd$1(key, newValue))(patch$12)];
		}
	})(options.newValue);
	return reduce$5(patch$11, (patch$12, _, key) => combine$6(makeRemove$1(key))(patch$12))(removed);
};
/** @internal */
const combine$6 = /* @__PURE__ */ dual(2, (self, that) => makeAndThen$3(self, that));
/** @internal */
const patch$8 = /* @__PURE__ */ dual(3, (self, oldValue, differ$2) => {
	if (self._tag === "Empty") return oldValue;
	let map$17 = oldValue;
	let patches = of$3(self);
	while (isNonEmpty$5(patches)) {
		const head$4 = headNonEmpty(patches);
		const tail = tailNonEmpty(patches);
		switch (head$4._tag) {
			case "Empty":
				patches = tail;
				break;
			case "AndThen":
				patches = prepend$1(head$4.first)(prepend$1(head$4.second)(tail));
				break;
			case "Add":
				map$17 = set$3(head$4.key, head$4.value)(map$17);
				patches = tail;
				break;
			case "Remove":
				map$17 = remove$3(head$4.key)(map$17);
				patches = tail;
				break;
			case "Update": {
				const option$2 = get$5(head$4.key)(map$17);
				if (option$2._tag === "Some") map$17 = set$3(head$4.key, differ$2.patch(head$4.patch, option$2.value))(map$17);
				patches = tail;
				break;
			}
		}
	}
	return map$17;
});

//#endregion
//#region ../../node_modules/.bun/effect@3.17.14/node_modules/effect/dist/esm/internal/differ/hashSetPatch.js
/** @internal */
const HashSetPatchTypeId = /* @__PURE__ */ Symbol.for("effect/DifferHashSetPatch");
function variance$3(a) {
	return a;
}
/** @internal */
const PatchProto$2 = {
	...Structural$1.prototype,
	[HashSetPatchTypeId]: {
		_Value: variance$3,
		_Key: variance$3,
		_Patch: variance$3
	}
};
const EmptyProto$2 = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(PatchProto$2), { _tag: "Empty" });
const _empty$2 = /* @__PURE__ */ Object.create(EmptyProto$2);
/** @internal */
const empty$19 = () => _empty$2;
const AndThenProto$2 = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(PatchProto$2), { _tag: "AndThen" });
/** @internal */
const makeAndThen$2 = (first$2, second) => {
	const o = Object.create(AndThenProto$2);
	o.first = first$2;
	o.second = second;
	return o;
};
const AddProto = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(PatchProto$2), { _tag: "Add" });
/** @internal */
const makeAdd = (value) => {
	const o = Object.create(AddProto);
	o.value = value;
	return o;
};
const RemoveProto = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(PatchProto$2), { _tag: "Remove" });
/** @internal */
const makeRemove = (value) => {
	const o = Object.create(RemoveProto);
	o.value = value;
	return o;
};
/** @internal */
const diff$6 = (oldValue, newValue) => {
	const [removed, patch$11] = reduce$7([oldValue, empty$19()], ([set$6, patch$12], value) => {
		if (has$4(value)(set$6)) return [remove$4(value)(set$6), patch$12];
		return [set$6, combine$5(makeAdd(value))(patch$12)];
	})(newValue);
	return reduce$7(patch$11, (patch$12, value) => combine$5(makeRemove(value))(patch$12))(removed);
};
/** @internal */
const combine$5 = /* @__PURE__ */ dual(2, (self, that) => makeAndThen$2(self, that));
/** @internal */
const patch$7 = /* @__PURE__ */ dual(2, (self, oldValue) => {
	if (self._tag === "Empty") return oldValue;
	let set$6 = oldValue;
	let patches = of$3(self);
	while (isNonEmpty$5(patches)) {
		const head$4 = headNonEmpty(patches);
		const tail = tailNonEmpty(patches);
		switch (head$4._tag) {
			case "Empty":
				patches = tail;
				break;
			case "AndThen":
				patches = prepend$1(head$4.first)(prepend$1(head$4.second)(tail));
				break;
			case "Add":
				set$6 = add$3(head$4.value)(set$6);
				patches = tail;
				break;
			case "Remove":
				set$6 = remove$4(head$4.value)(set$6);
				patches = tail;
		}
	}
	return set$6;
});

//#endregion
//#region ../../node_modules/.bun/effect@3.17.14/node_modules/effect/dist/esm/internal/differ/orPatch.js
/** @internal */
const OrPatchTypeId = /* @__PURE__ */ Symbol.for("effect/DifferOrPatch");
function variance$2(a) {
	return a;
}
/** @internal */
const PatchProto$1 = {
	...Structural$1.prototype,
	[OrPatchTypeId]: {
		_Value: variance$2,
		_Key: variance$2,
		_Patch: variance$2
	}
};
const EmptyProto$1 = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(PatchProto$1), { _tag: "Empty" });
const _empty$1 = /* @__PURE__ */ Object.create(EmptyProto$1);
/** @internal */
const empty$18 = () => _empty$1;
const AndThenProto$1 = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(PatchProto$1), { _tag: "AndThen" });
/** @internal */
const makeAndThen$1 = (first$2, second) => {
	const o = Object.create(AndThenProto$1);
	o.first = first$2;
	o.second = second;
	return o;
};
const SetLeftProto = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(PatchProto$1), { _tag: "SetLeft" });
/** @internal */
const makeSetLeft = (value) => {
	const o = Object.create(SetLeftProto);
	o.value = value;
	return o;
};
const SetRightProto = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(PatchProto$1), { _tag: "SetRight" });
/** @internal */
const makeSetRight = (value) => {
	const o = Object.create(SetRightProto);
	o.value = value;
	return o;
};
const UpdateLeftProto = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(PatchProto$1), { _tag: "UpdateLeft" });
/** @internal */
const makeUpdateLeft = (patch$11) => {
	const o = Object.create(UpdateLeftProto);
	o.patch = patch$11;
	return o;
};
const UpdateRightProto = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(PatchProto$1), { _tag: "UpdateRight" });
/** @internal */
const makeUpdateRight = (patch$11) => {
	const o = Object.create(UpdateRightProto);
	o.patch = patch$11;
	return o;
};
/** @internal */
const diff$5 = (options) => {
	switch (options.oldValue._tag) {
		case "Left": switch (options.newValue._tag) {
			case "Left": {
				const valuePatch = options.left.diff(options.oldValue.left, options.newValue.left);
				if (equals(valuePatch, options.left.empty)) return empty$18();
				return makeUpdateLeft(valuePatch);
			}
			case "Right": return makeSetRight(options.newValue.right);
		}
		case "Right": switch (options.newValue._tag) {
			case "Left": return makeSetLeft(options.newValue.left);
			case "Right": {
				const valuePatch = options.right.diff(options.oldValue.right, options.newValue.right);
				if (equals(valuePatch, options.right.empty)) return empty$18();
				return makeUpdateRight(valuePatch);
			}
		}
	}
};
/** @internal */
const combine$4 = /* @__PURE__ */ dual(2, (self, that) => makeAndThen$1(self, that));
/** @internal */
const patch$6 = /* @__PURE__ */ dual(2, (self, { left: left$2, oldValue, right: right$2 }) => {
	if (self._tag === "Empty") return oldValue;
	let patches = of$3(self);
	let result = oldValue;
	while (isNonEmpty$5(patches)) {
		const head$4 = headNonEmpty(patches);
		const tail = tailNonEmpty(patches);
		switch (head$4._tag) {
			case "Empty":
				patches = tail;
				break;
			case "AndThen":
				patches = prepend$1(head$4.first)(prepend$1(head$4.second)(tail));
				break;
			case "UpdateLeft":
				if (result._tag === "Left") result = left(left$2.patch(head$4.patch, result.left));
				patches = tail;
				break;
			case "UpdateRight":
				if (result._tag === "Right") result = right(right$2.patch(head$4.patch, result.right));
				patches = tail;
				break;
			case "SetLeft":
				result = left(head$4.value);
				patches = tail;
				break;
			case "SetRight":
				result = right(head$4.value);
				patches = tail;
				break;
		}
	}
	return result;
});

//#endregion
//#region ../../node_modules/.bun/effect@3.17.14/node_modules/effect/dist/esm/internal/differ/readonlyArrayPatch.js
/** @internal */
const ReadonlyArrayPatchTypeId = /* @__PURE__ */ Symbol.for("effect/DifferReadonlyArrayPatch");
function variance$1(a) {
	return a;
}
const PatchProto = {
	...Structural$1.prototype,
	[ReadonlyArrayPatchTypeId]: {
		_Value: variance$1,
		_Patch: variance$1
	}
};
const EmptyProto = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(PatchProto), { _tag: "Empty" });
const _empty = /* @__PURE__ */ Object.create(EmptyProto);
/**
* @internal
*/
const empty$17 = () => _empty;
const AndThenProto = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(PatchProto), { _tag: "AndThen" });
const makeAndThen = (first$2, second) => {
	const o = Object.create(AndThenProto);
	o.first = first$2;
	o.second = second;
	return o;
};
const AppendProto = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(PatchProto), { _tag: "Append" });
const makeAppend = (values$6) => {
	const o = Object.create(AppendProto);
	o.values = values$6;
	return o;
};
const SliceProto = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(PatchProto), { _tag: "Slice" });
const makeSlice = (from, until) => {
	const o = Object.create(SliceProto);
	o.from = from;
	o.until = until;
	return o;
};
const UpdateProto = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(PatchProto), { _tag: "Update" });
const makeUpdate = (index, patch$11) => {
	const o = Object.create(UpdateProto);
	o.index = index;
	o.patch = patch$11;
	return o;
};
/** @internal */
const diff$4 = (options) => {
	let i = 0;
	let patch$11 = empty$17();
	while (i < options.oldValue.length && i < options.newValue.length) {
		const oldElement = options.oldValue[i];
		const newElement = options.newValue[i];
		const valuePatch = options.differ.diff(oldElement, newElement);
		if (!equals(valuePatch, options.differ.empty)) patch$11 = combine$3(patch$11, makeUpdate(i, valuePatch));
		i = i + 1;
	}
	if (i < options.oldValue.length) patch$11 = combine$3(patch$11, makeSlice(0, i));
	if (i < options.newValue.length) patch$11 = combine$3(patch$11, makeAppend(drop$1(i)(options.newValue)));
	return patch$11;
};
/** @internal */
const combine$3 = /* @__PURE__ */ dual(2, (self, that) => makeAndThen(self, that));
/** @internal */
const patch$5 = /* @__PURE__ */ dual(3, (self, oldValue, differ$2) => {
	if (self._tag === "Empty") return oldValue;
	let readonlyArray$2 = oldValue.slice();
	let patches = of$4(self);
	while (isNonEmptyArray(patches)) {
		const head$4 = headNonEmpty$1(patches);
		const tail = tailNonEmpty$1(patches);
		switch (head$4._tag) {
			case "Empty":
				patches = tail;
				break;
			case "AndThen":
				tail.unshift(head$4.first, head$4.second);
				patches = tail;
				break;
			case "Append":
				for (const value of head$4.values) readonlyArray$2.push(value);
				patches = tail;
				break;
			case "Slice":
				readonlyArray$2 = readonlyArray$2.slice(head$4.from, head$4.until);
				patches = tail;
				break;
			case "Update":
				readonlyArray$2[head$4.index] = differ$2.patch(head$4.patch, readonlyArray$2[head$4.index]);
				patches = tail;
				break;
		}
	}
	return readonlyArray$2;
});

//#endregion
//#region ../../node_modules/.bun/effect@3.17.14/node_modules/effect/dist/esm/internal/differ.js
/** @internal */
const DifferTypeId = /* @__PURE__ */ Symbol.for("effect/Differ");
/** @internal */
const DifferProto = {
	[DifferTypeId]: {
		_P: identity,
		_V: identity
	},
	pipe() {
		return pipeArguments(this, arguments);
	}
};
/** @internal */
const make$30 = (params) => {
	const differ$2 = Object.create(DifferProto);
	differ$2.empty = params.empty;
	differ$2.diff = params.diff;
	differ$2.combine = params.combine;
	differ$2.patch = params.patch;
	return differ$2;
};
/** @internal */
const environment$1 = () => make$30({
	empty: empty$21(),
	combine: (first$2, second) => combine$7(second)(first$2),
	diff: (oldValue, newValue) => diff$8(oldValue, newValue),
	patch: (patch$11, oldValue) => patch$9(oldValue)(patch$11)
});
/** @internal */
const chunk$1 = (differ$2) => make$30({
	empty: empty$22(),
	combine: (first$2, second) => combine$8(second)(first$2),
	diff: (oldValue, newValue) => diff$9({
		oldValue,
		newValue,
		differ: differ$2
	}),
	patch: (patch$11, oldValue) => patch$10(oldValue, differ$2)(patch$11)
});
/** @internal */
const hashMap$1 = (differ$2) => make$30({
	empty: empty$20(),
	combine: (first$2, second) => combine$6(second)(first$2),
	diff: (oldValue, newValue) => diff$7({
		oldValue,
		newValue,
		differ: differ$2
	}),
	patch: (patch$11, oldValue) => patch$8(oldValue, differ$2)(patch$11)
});
/** @internal */
const hashSet$1 = () => make$30({
	empty: empty$19(),
	combine: (first$2, second) => combine$5(second)(first$2),
	diff: (oldValue, newValue) => diff$6(oldValue, newValue),
	patch: (patch$11, oldValue) => patch$7(oldValue)(patch$11)
});
/** @internal */
const orElseEither$3 = /* @__PURE__ */ dual(2, (self, that) => make$30({
	empty: empty$18(),
	combine: (first$2, second) => combine$4(first$2, second),
	diff: (oldValue, newValue) => diff$5({
		oldValue,
		newValue,
		left: self,
		right: that
	}),
	patch: (patch$11, oldValue) => patch$6(patch$11, {
		oldValue,
		left: self,
		right: that
	})
}));
/** @internal */
const readonlyArray$1 = (differ$2) => make$30({
	empty: empty$17(),
	combine: (first$2, second) => combine$3(first$2, second),
	diff: (oldValue, newValue) => diff$4({
		oldValue,
		newValue,
		differ: differ$2
	}),
	patch: (patch$11, oldValue) => patch$5(patch$11, oldValue, differ$2)
});
/** @internal */
const transform$2 = /* @__PURE__ */ dual(2, (self, { toNew, toOld }) => make$30({
	empty: self.empty,
	combine: (first$2, second) => self.combine(first$2, second),
	diff: (oldValue, newValue) => self.diff(toOld(oldValue), toOld(newValue)),
	patch: (patch$11, oldValue) => toNew(self.patch(patch$11, toOld(oldValue)))
}));
/** @internal */
const update$4 = () => updateWith$1((_, a) => a);
/** @internal */
const updateWith$1 = (f) => make$30({
	empty: identity,
	combine: (first$2, second) => {
		if (first$2 === identity) return second;
		if (second === identity) return first$2;
		return (a) => second(first$2(a));
	},
	diff: (oldValue, newValue) => {
		if (equals(oldValue, newValue)) return identity;
		return constant(newValue);
	},
	patch: (patch$11, oldValue) => f(oldValue, patch$11(oldValue))
});
/** @internal */
const zip$5 = /* @__PURE__ */ dual(2, (self, that) => make$30({
	empty: [self.empty, that.empty],
	combine: (first$2, second) => [self.combine(first$2[0], second[0]), that.combine(first$2[1], second[1])],
	diff: (oldValue, newValue) => [self.diff(oldValue[0], newValue[0]), that.diff(oldValue[1], newValue[1])],
	patch: (patch$11, oldValue) => [self.patch(patch$11[0], oldValue[0]), that.patch(patch$11[1], oldValue[1])]
}));

//#endregion
//#region ../../node_modules/.bun/effect@3.17.14/node_modules/effect/dist/esm/internal/runtimeFlagsPatch.js
/** @internal */
const BIT_MASK = 255;
/** @internal */
const BIT_SHIFT = 8;
/** @internal */
const active = (patch$11) => patch$11 & BIT_MASK;
/** @internal */
const enabled = (patch$11) => patch$11 >> BIT_SHIFT & BIT_MASK;
/** @internal */
const make$29 = (active$1, enabled$1) => (active$1 & BIT_MASK) + ((enabled$1 & active$1 & BIT_MASK) << BIT_SHIFT);
/** @internal */
const empty$16 = /* @__PURE__ */ make$29(0, 0);
/** @internal */
const enable$2 = (flag) => make$29(flag, flag);
/** @internal */
const disable$2 = (flag) => make$29(flag, 0);
/** @internal */
const isEmpty$4 = (patch$11) => patch$11 === 0;
/** @internal */
const isActive$1 = /* @__PURE__ */ dual(2, (self, flag) => (active(self) & flag) !== 0);
/** @internal */
const isEnabled$2 = /* @__PURE__ */ dual(2, (self, flag) => (enabled(self) & flag) !== 0);
/** @internal */
const isDisabled$1 = /* @__PURE__ */ dual(2, (self, flag) => (active(self) & flag) !== 0 && (enabled(self) & flag) === 0);
/** @internal */
const exclude$1 = /* @__PURE__ */ dual(2, (self, flag) => make$29(active(self) & ~flag, enabled(self)));
/** @internal */
const both$1 = /* @__PURE__ */ dual(2, (self, that) => make$29(active(self) | active(that), enabled(self) & enabled(that)));
/** @internal */
const either$3 = /* @__PURE__ */ dual(2, (self, that) => make$29(active(self) | active(that), enabled(self) | enabled(that)));
/** @internal */
const andThen$3 = /* @__PURE__ */ dual(2, (self, that) => self | that);
/** @internal */
const inverse$1 = (patch$11) => make$29(enabled(patch$11), invert(active(patch$11)));
/** @internal */
const invert = (n) => ~n >>> 0 & BIT_MASK;

//#endregion
//#region ../../node_modules/.bun/effect@3.17.14/node_modules/effect/dist/esm/internal/runtimeFlags.js
/** @internal */
const None$1 = 0;
/** @internal */
const Interruption = 1;
/** @internal */
const OpSupervision = 2;
/** @internal */
const RuntimeMetrics = 4;
/** @internal */
const WindDown = 16;
/** @internal */
const CooperativeYielding = 32;
/** @internal */
const allFlags = [
	None$1,
	Interruption,
	OpSupervision,
	RuntimeMetrics,
	WindDown,
	CooperativeYielding
];
const print = (flag) => {
	switch (flag) {
		case CooperativeYielding: return "CooperativeYielding";
		case WindDown: return "WindDown";
		case RuntimeMetrics: return "RuntimeMetrics";
		case OpSupervision: return "OpSupervision";
		case Interruption: return "Interruption";
		case None$1: return "None";
	}
};
/** @internal */
const cooperativeYielding = (self) => isEnabled$1(self, CooperativeYielding);
/** @internal */
const disable$1 = /* @__PURE__ */ dual(2, (self, flag) => self & ~flag);
/** @internal */
const enable$1 = /* @__PURE__ */ dual(2, (self, flag) => self | flag);
/** @internal */
const interruptible$3 = (self) => interruption(self) && !windDown(self);
/** @internal */
const interruption = (self) => isEnabled$1(self, Interruption);
/** @internal */
const isEnabled$1 = /* @__PURE__ */ dual(2, (self, flag) => (self & flag) !== 0);
/** @internal */
const make$28 = (...flags) => flags.reduce((a, b) => a | b, 0);
/** @internal */
const none$5 = /* @__PURE__ */ make$28(None$1);
/** @internal */
const runtimeMetrics = (self) => isEnabled$1(self, RuntimeMetrics);
/** @internal */
const toSet$1 = (self) => new Set(allFlags.filter((flag) => isEnabled$1(self, flag)));
const windDown = (self) => isEnabled$1(self, WindDown);
/** @internal */
const enabledSet$1 = (self) => toSet$1(active(self) & enabled(self));
/** @internal */
const disabledSet$1 = (self) => toSet$1(active(self) & ~enabled(self));
/** @internal */
const diff$3 = /* @__PURE__ */ dual(2, (self, that) => make$29(self ^ that, that));
/** @internal */
const patch$4 = /* @__PURE__ */ dual(2, (self, patch$11) => self & (invert(active(patch$11)) | enabled(patch$11)) | active(patch$11) & enabled(patch$11));
/** @internal */
const renderPatch = (self) => {
	const enabled$1 = Array.from(enabledSet$1(self)).map((flag) => print(flag)).join(", ");
	const disabled = Array.from(disabledSet$1(self)).map((flag) => print(flag)).join(", ");
	return `RuntimeFlagsPatch(enabled = (${enabled$1}), disabled = (${disabled}))`;
};
/** @internal */
const differ$1 = /* @__PURE__ */ make$30({
	empty: empty$16,
	diff: (oldValue, newValue) => diff$3(oldValue, newValue),
	combine: (first$2, second) => andThen$3(second)(first$2),
	patch: (_patch, oldValue) => patch$4(oldValue, _patch)
});

//#endregion
//#region ../../node_modules/.bun/effect@3.17.14/node_modules/effect/dist/esm/RuntimeFlagsPatch.js
/**
* The empty `RuntimeFlagsPatch`.
*
* @since 2.0.0
* @category constructors
*/
const empty$15 = empty$16;
/**
* @since 2.0.0
* @category constructors
*/
const make$27 = make$29;
/**
* Creates a `RuntimeFlagsPatch` describing enabling the provided `RuntimeFlag`.
*
* @since 2.0.0
* @category constructors
*/
const enable = enable$2;
/**
* Creates a `RuntimeFlagsPatch` describing disabling the provided `RuntimeFlag`.
*
* @since 2.0.0
* @category constructors
*/
const disable = disable$2;
/**
* Returns `true` if the specified `RuntimeFlagsPatch` is empty.
*
* @since 2.0.0
* @category getters
*/
const isEmpty$3 = isEmpty$4;
/**
* Returns `true` if the `RuntimeFlagsPatch` describes the specified
* `RuntimeFlag` as active.
*
* @since 2.0.0
* @category elements
*/
const isActive = isActive$1;
/**
* Returns `true` if the `RuntimeFlagsPatch` describes the specified
* `RuntimeFlag` as enabled.
*
* @since 2.0.0
* @category elements
*/
const isEnabled = isEnabled$2;
/**
* Returns `true` if the `RuntimeFlagsPatch` describes the specified
* `RuntimeFlag` as disabled.
*
* @since 2.0.0
* @category elements
*/
const isDisabled = isDisabled$1;
/**
* Returns `true` if the `RuntimeFlagsPatch` includes the specified
* `RuntimeFlag`, `false` otherwise.
*
* @since 2.0.0
* @category elements
*/
const includes = isActive$1;
/**
* Creates a `RuntimeFlagsPatch` describing the application of the `self` patch,
* followed by `that` patch.
*
* @since 2.0.0
* @category utils
*/
const andThen$2 = andThen$3;
/**
* Creates a `RuntimeFlagsPatch` describing application of both the `self` patch
* and `that` patch.
*
* @since 2.0.0
* @category utils
*/
const both = both$1;
/**
* Creates a `RuntimeFlagsPatch` describing application of either the `self`
* patch or `that` patch.
*
* @since 2.0.0
* @category utils
*/
const either$2 = either$3;
/**
* Creates a `RuntimeFlagsPatch` which describes exclusion of the specified
* `RuntimeFlag` from the set of `RuntimeFlags`.
*
* @category utils
* @since 2.0.0
*/
const exclude = exclude$1;
/**
* Creates a `RuntimeFlagsPatch` which describes the inverse of the patch
* specified by the provided `RuntimeFlagsPatch`.
*
* @since 2.0.0
* @category utils
*/
const inverse = inverse$1;
/**
* Returns a `ReadonlySet<number>` containing the `RuntimeFlags` described as
* enabled by the specified `RuntimeFlagsPatch`.
*
* @since 2.0.0
* @category destructors
*/
const enabledSet = enabledSet$1;
/**
* Returns a `ReadonlySet<number>` containing the `RuntimeFlags` described as
* disabled by the specified `RuntimeFlagsPatch`.
*
* @since 2.0.0
* @category destructors
*/
const disabledSet = disabledSet$1;
/**
* Renders the provided `RuntimeFlagsPatch` to a string.
*
* @since 2.0.0
* @category destructors
*/
const render$2 = renderPatch;

//#endregion
//#region ../../node_modules/.bun/effect@3.17.14/node_modules/effect/dist/esm/internal/blockedRequests.js
/** @internal */
const empty$14 = { _tag: "Empty" };
/**
* Combines this collection of blocked requests with the specified collection
* of blocked requests, in parallel.
*
* @internal
*/
const par = (self, that) => ({
	_tag: "Par",
	left: self,
	right: that
});
/**
* Combines this collection of blocked requests with the specified collection
* of blocked requests, in sequence.
*
* @internal
*/
const seq = (self, that) => ({
	_tag: "Seq",
	left: self,
	right: that
});
/**
* Constructs a collection of blocked requests from the specified blocked
* request and data source.
*
* @internal
*/
const single = (dataSource, blockedRequest) => ({
	_tag: "Single",
	dataSource,
	blockedRequest
});
/**
* Flattens a collection of blocked requests into a collection of pipelined
* and batched requests that can be submitted for execution.
*
* @internal
*/
const flatten$4 = (self) => {
	let current = of$2(self);
	let updated = empty$23();
	while (1) {
		const [parallel$3, sequential$3] = reduce$4(current, [parallelCollectionEmpty(), empty$23()], ([parallel$4, sequential$4], blockedRequest) => {
			const [par$1, seq$1] = step$2(blockedRequest);
			return [parallelCollectionCombine(parallel$4, par$1), appendAll(sequential$4, seq$1)];
		});
		updated = merge$3(updated, parallel$3);
		if (isNil(sequential$3)) return reverse(updated);
		current = sequential$3;
	}
	throw new Error("BUG: BlockedRequests.flatten - please report an issue at https://github.com/Effect-TS/effect/issues");
};
/**
* Takes one step in evaluating a collection of blocked requests, returning a
* collection of blocked requests that can be performed in parallel and a list
* of blocked requests that must be performed sequentially after those
* requests.
*/
const step$2 = (requests) => {
	let current = requests;
	let parallel$3 = parallelCollectionEmpty();
	let stack = empty$23();
	let sequential$3 = empty$23();
	while (1) switch (current._tag) {
		case "Empty":
			if (isNil(stack)) return [parallel$3, sequential$3];
			current = stack.head;
			stack = stack.tail;
			break;
		case "Par":
			stack = cons(current.right, stack);
			current = current.left;
			break;
		case "Seq": {
			const left$2 = current.left;
			const right$2 = current.right;
			switch (left$2._tag) {
				case "Empty":
					current = right$2;
					break;
				case "Par": {
					const l = left$2.left;
					const r = left$2.right;
					current = par(seq(l, right$2), seq(r, right$2));
					break;
				}
				case "Seq": {
					const l = left$2.left;
					const r = left$2.right;
					current = seq(l, seq(r, right$2));
					break;
				}
				case "Single":
					current = left$2;
					sequential$3 = cons(right$2, sequential$3);
					break;
			}
			break;
		}
		case "Single":
			parallel$3 = parallelCollectionAdd(parallel$3, current);
			if (isNil(stack)) return [parallel$3, sequential$3];
			current = stack.head;
			stack = stack.tail;
			break;
	}
	throw new Error("BUG: BlockedRequests.step - please report an issue at https://github.com/Effect-TS/effect/issues");
};
/**
* Merges a collection of requests that must be executed sequentially with a
* collection of requests that can be executed in parallel. If the collections
* are both from the same single data source then the requests can be
* pipelined while preserving ordering guarantees.
*/
const merge$3 = (sequential$3, parallel$3) => {
	if (isNil(sequential$3)) return of$2(parallelCollectionToSequentialCollection(parallel$3));
	if (parallelCollectionIsEmpty(parallel$3)) return sequential$3;
	const seqHeadKeys = sequentialCollectionKeys(sequential$3.head);
	const parKeys = parallelCollectionKeys(parallel$3);
	if (seqHeadKeys.length === 1 && parKeys.length === 1 && equals(seqHeadKeys[0], parKeys[0])) return cons(sequentialCollectionCombine(sequential$3.head, parallelCollectionToSequentialCollection(parallel$3)), sequential$3.tail);
	return cons(parallelCollectionToSequentialCollection(parallel$3), sequential$3);
};
/** @internal */
const EntryTypeId = /* @__PURE__ */ Symbol.for("effect/RequestBlock/Entry");
/** @internal */
var EntryImpl = class {
	request;
	result;
	listeners;
	ownerId;
	state;
	[EntryTypeId] = blockedRequestVariance;
	constructor(request$1, result, listeners, ownerId, state) {
		this.request = request$1;
		this.result = result;
		this.listeners = listeners;
		this.ownerId = ownerId;
		this.state = state;
	}
};
const blockedRequestVariance = { _R: (_) => _ };
/** @internal */
const isEntry$1 = (u) => hasProperty(u, EntryTypeId);
/** @internal */
const makeEntry$1 = (options) => new EntryImpl(options.request, options.result, options.listeners, options.ownerId, options.state);
/** @internal */
const RequestBlockParallelTypeId = /* @__PURE__ */ Symbol.for("effect/RequestBlock/RequestBlockParallel");
const parallelVariance = { _R: (_) => _ };
var ParallelImpl = class {
	map;
	[RequestBlockParallelTypeId] = parallelVariance;
	constructor(map$17) {
		this.map = map$17;
	}
};
/** @internal */
const parallelCollectionEmpty = () => new ParallelImpl(empty$24());
/** @internal */
const parallelCollectionAdd = (self, blockedRequest) => new ParallelImpl(modifyAt(self.map, blockedRequest.dataSource, (_) => orElseSome(map$15(_, append$1(blockedRequest.blockedRequest)), () => of$3(blockedRequest.blockedRequest))));
/** @internal */
const parallelCollectionCombine = (self, that) => new ParallelImpl(reduce$5(self.map, that.map, (map$17, value, key) => set$3(map$17, key, match$10(get$5(map$17, key), {
	onNone: () => value,
	onSome: (other) => appendAll$1(value, other)
}))));
/** @internal */
const parallelCollectionIsEmpty = (self) => isEmpty$5(self.map);
/** @internal */
const parallelCollectionKeys = (self) => Array.from(keys$2(self.map));
/** @internal */
const parallelCollectionToSequentialCollection = (self) => sequentialCollectionMake(map$9(self.map, (x) => of$3(x)));
/** @internal */
const SequentialCollectionTypeId = /* @__PURE__ */ Symbol.for("effect/RequestBlock/RequestBlockSequential");
const sequentialVariance = { _R: (_) => _ };
var SequentialImpl = class {
	map;
	[SequentialCollectionTypeId] = sequentialVariance;
	constructor(map$17) {
		this.map = map$17;
	}
};
/** @internal */
const sequentialCollectionMake = (map$17) => new SequentialImpl(map$17);
/** @internal */
const sequentialCollectionCombine = (self, that) => new SequentialImpl(reduce$5(that.map, self.map, (map$17, value, key) => set$3(map$17, key, match$10(get$5(map$17, key), {
	onNone: () => empty$31(),
	onSome: (a) => appendAll$1(a, value)
}))));
/** @internal */
const sequentialCollectionKeys = (self) => Array.from(keys$2(self.map));
/** @internal */
const sequentialCollectionToChunk = (self) => Array.from(self.map);

//#endregion
//#region ../../node_modules/.bun/effect@3.17.14/node_modules/effect/dist/esm/internal/opCodes/deferred.js
/** @internal */
const OP_STATE_PENDING = "Pending";
/** @internal */
const OP_STATE_DONE = "Done";

//#endregion
//#region ../../node_modules/.bun/effect@3.17.14/node_modules/effect/dist/esm/internal/deferred.js
/** @internal */
const DeferredSymbolKey = "effect/Deferred";
/** @internal */
const DeferredTypeId$1 = /* @__PURE__ */ Symbol.for(DeferredSymbolKey);
/** @internal */
const deferredVariance = {
	_E: (_) => _,
	_A: (_) => _
};
/** @internal */
const pending$1 = (joiners) => {
	return {
		_tag: OP_STATE_PENDING,
		joiners
	};
};
/** @internal */
const done$7 = (effect) => {
	return {
		_tag: OP_STATE_DONE,
		effect
	};
};

//#endregion
//#region ../../node_modules/.bun/effect@3.17.14/node_modules/effect/dist/esm/internal/singleShotGen.js
/** @internal */
var SingleShotGen$1 = class SingleShotGen$1 {
	self;
	called = false;
	constructor(self) {
		this.self = self;
	}
	next(a) {
		return this.called ? {
			value: a,
			done: true
		} : (this.called = true, {
			value: this.self,
			done: false
		});
	}
	return(a) {
		return {
			value: a,
			done: true
		};
	}
	throw(e) {
		throw e;
	}
	[Symbol.iterator]() {
		return new SingleShotGen$1(this.self);
	}
};

//#endregion
//#region ../../node_modules/.bun/effect@3.17.14/node_modules/effect/dist/esm/internal/core.js
/**
* @internal
*/
const blocked$1 = (blockedRequests, _continue$2) => {
	const effect = new EffectPrimitive("Blocked");
	effect.effect_instruction_i0 = blockedRequests;
	effect.effect_instruction_i1 = _continue$2;
	return effect;
};
/**
* @internal
*/
const runRequestBlock$1 = (blockedRequests) => {
	const effect = new EffectPrimitive("RunBlocked");
	effect.effect_instruction_i0 = blockedRequests;
	return effect;
};
/** @internal */
const EffectTypeId$2 = /* @__PURE__ */ Symbol.for("effect/Effect");
/** @internal */
var RevertFlags = class {
	patch;
	op;
	_op = OP_REVERT_FLAGS;
	constructor(patch$11, op) {
		this.patch = patch$11;
		this.op = op;
	}
};
var EffectPrimitive = class {
	_op;
	effect_instruction_i0 = void 0;
	effect_instruction_i1 = void 0;
	effect_instruction_i2 = void 0;
	trace = void 0;
	[EffectTypeId$2] = effectVariance;
	constructor(_op) {
		this._op = _op;
	}
	[symbol](that) {
		return this === that;
	}
	[symbol$1]() {
		return cached$2(this, random$2(this));
	}
	pipe() {
		return pipeArguments(this, arguments);
	}
	toJSON() {
		return {
			_id: "Effect",
			_op: this._op,
			effect_instruction_i0: toJSON(this.effect_instruction_i0),
			effect_instruction_i1: toJSON(this.effect_instruction_i1),
			effect_instruction_i2: toJSON(this.effect_instruction_i2)
		};
	}
	toString() {
		return format(this.toJSON());
	}
	[NodeInspectSymbol]() {
		return this.toJSON();
	}
	[Symbol.iterator]() {
		return new SingleShotGen$1(new YieldWrap(this));
	}
};
/** @internal */
var EffectPrimitiveFailure = class {
	_op;
	effect_instruction_i0 = void 0;
	effect_instruction_i1 = void 0;
	effect_instruction_i2 = void 0;
	trace = void 0;
	[EffectTypeId$2] = effectVariance;
	constructor(_op) {
		this._op = _op;
		this._tag = _op;
	}
	[symbol](that) {
		return exitIsExit(that) && that._op === "Failure" && equals(this.effect_instruction_i0, that.effect_instruction_i0);
	}
	[symbol$1]() {
		return pipe(string(this._tag), combine$11(hash(this.effect_instruction_i0)), cached$2(this));
	}
	get cause() {
		return this.effect_instruction_i0;
	}
	pipe() {
		return pipeArguments(this, arguments);
	}
	toJSON() {
		return {
			_id: "Exit",
			_tag: this._op,
			cause: this.cause.toJSON()
		};
	}
	toString() {
		return format(this.toJSON());
	}
	[NodeInspectSymbol]() {
		return this.toJSON();
	}
	[Symbol.iterator]() {
		return new SingleShotGen$1(new YieldWrap(this));
	}
};
/** @internal */
var EffectPrimitiveSuccess = class {
	_op;
	effect_instruction_i0 = void 0;
	effect_instruction_i1 = void 0;
	effect_instruction_i2 = void 0;
	trace = void 0;
	[EffectTypeId$2] = effectVariance;
	constructor(_op) {
		this._op = _op;
		this._tag = _op;
	}
	[symbol](that) {
		return exitIsExit(that) && that._op === "Success" && equals(this.effect_instruction_i0, that.effect_instruction_i0);
	}
	[symbol$1]() {
		return pipe(string(this._tag), combine$11(hash(this.effect_instruction_i0)), cached$2(this));
	}
	get value() {
		return this.effect_instruction_i0;
	}
	pipe() {
		return pipeArguments(this, arguments);
	}
	toJSON() {
		return {
			_id: "Exit",
			_tag: this._op,
			value: toJSON(this.value)
		};
	}
	toString() {
		return format(this.toJSON());
	}
	[NodeInspectSymbol]() {
		return this.toJSON();
	}
	[Symbol.iterator]() {
		return new SingleShotGen$1(new YieldWrap(this));
	}
};
/** @internal */
const isEffect$1 = (u) => hasProperty(u, EffectTypeId$2);
const withFiberRuntime$1 = (withRuntime) => {
	const effect = new EffectPrimitive(OP_WITH_RUNTIME);
	effect.effect_instruction_i0 = withRuntime;
	return effect;
};
const acquireUseRelease$1 = /* @__PURE__ */ dual(3, (acquire, use$1, release) => uninterruptibleMask$2((restore) => flatMap$4(acquire, (a) => flatMap$4(exit$2(suspend$3(() => restore(use$1(a)))), (exit$3) => {
	return suspend$3(() => release(a, exit$3)).pipe(matchCauseEffect$2({
		onFailure: (cause$2) => {
			switch (exit$3._tag) {
				case OP_FAILURE: return failCause$8(sequential$2(exit$3.effect_instruction_i0, cause$2));
				case OP_SUCCESS: return failCause$8(cause$2);
			}
		},
		onSuccess: () => exit$3
	}));
}))));
const as$3 = /* @__PURE__ */ dual(2, (self, value) => flatMap$4(self, () => succeed$9(value)));
const asVoid$3 = (self) => as$3(self, void 0);
const custom$1 = function() {
	const wrapper = new EffectPrimitive(OP_COMMIT);
	switch (arguments.length) {
		case 2:
			wrapper.effect_instruction_i0 = arguments[0];
			wrapper.commit = arguments[1];
			break;
		case 3:
			wrapper.effect_instruction_i0 = arguments[0];
			wrapper.effect_instruction_i1 = arguments[1];
			wrapper.commit = arguments[2];
			break;
		case 4:
			wrapper.effect_instruction_i0 = arguments[0];
			wrapper.effect_instruction_i1 = arguments[1];
			wrapper.effect_instruction_i2 = arguments[2];
			wrapper.commit = arguments[3];
			break;
		default: throw new Error(getBugErrorMessage("you're not supposed to end up here"));
	}
	return wrapper;
};
const unsafeAsync = (register, blockingOn = none$6) => {
	const effect = new EffectPrimitive(OP_ASYNC);
	let cancelerRef = void 0;
	effect.effect_instruction_i0 = (resume$1) => {
		cancelerRef = register(resume$1);
	};
	effect.effect_instruction_i1 = blockingOn;
	return onInterrupt$1(effect, (_) => isEffect$1(cancelerRef) ? cancelerRef : void_$4);
};
const asyncInterrupt = (register, blockingOn = none$6) => suspend$3(() => unsafeAsync(register, blockingOn));
const async_ = (resume$1, blockingOn = none$6) => {
	return custom$1(resume$1, function() {
		let backingResume = void 0;
		let pendingEffect = void 0;
		function proxyResume(effect$1) {
			if (backingResume) backingResume(effect$1);
			else if (pendingEffect === void 0) pendingEffect = effect$1;
		}
		const effect = new EffectPrimitive(OP_ASYNC);
		effect.effect_instruction_i0 = (resume$2) => {
			backingResume = resume$2;
			if (pendingEffect) resume$2(pendingEffect);
		};
		effect.effect_instruction_i1 = blockingOn;
		let cancelerRef = void 0;
		let controllerRef = void 0;
		if (this.effect_instruction_i0.length !== 1) {
			controllerRef = new AbortController();
			cancelerRef = internalCall(() => this.effect_instruction_i0(proxyResume, controllerRef.signal));
		} else cancelerRef = internalCall(() => this.effect_instruction_i0(proxyResume));
		return cancelerRef || controllerRef ? onInterrupt$1(effect, (_) => {
			if (controllerRef) controllerRef.abort();
			return cancelerRef ?? void_$4;
		}) : effect;
	});
};
const catchAllCause$1 = /* @__PURE__ */ dual(2, (self, f) => {
	const effect = new EffectPrimitive(OP_ON_FAILURE);
	effect.effect_instruction_i0 = self;
	effect.effect_instruction_i1 = f;
	return effect;
});
const catchAll$1 = /* @__PURE__ */ dual(2, (self, f) => matchEffect$2(self, {
	onFailure: f,
	onSuccess: succeed$9
}));
const catchIf$1 = /* @__PURE__ */ dual(3, (self, predicate, f) => catchAllCause$1(self, (cause$2) => {
	const either$4 = failureOrCause(cause$2);
	switch (either$4._tag) {
		case "Left": return predicate(either$4.left) ? f(either$4.left) : failCause$8(cause$2);
		case "Right": return failCause$8(either$4.right);
	}
}));
const catchSome$1 = /* @__PURE__ */ dual(2, (self, pf) => catchAllCause$1(self, (cause$2) => {
	const either$4 = failureOrCause(cause$2);
	switch (either$4._tag) {
		case "Left": return pipe(pf(either$4.left), getOrElse$5(() => failCause$8(cause$2)));
		case "Right": return failCause$8(either$4.right);
	}
}));
const checkInterruptible$1 = (f) => withFiberRuntime$1((_, status$2) => f(interruption(status$2.runtimeFlags)));
const originalSymbol = /* @__PURE__ */ Symbol.for("effect/OriginalAnnotation");
const capture = (obj, span$1) => {
	if (isSome(span$1)) return new Proxy(obj, {
		has(target, p) {
			return p === spanSymbol || p === originalSymbol || p in target;
		},
		get(target, p) {
			if (p === spanSymbol) return span$1.value;
			if (p === originalSymbol) return obj;
			return target[p];
		}
	});
	return obj;
};
const die$3 = (defect) => isObject$1(defect) && !(spanSymbol in defect) ? withFiberRuntime$1((fiber) => failCause$8(die$4(capture(defect, currentSpanFromFiber(fiber))))) : failCause$8(die$4(defect));
const dieMessage$1 = (message) => failCauseSync$2(() => die$4(new RuntimeException(message)));
const dieSync$2 = (evaluate$1) => flatMap$4(sync$3(evaluate$1), die$3);
const either$1 = (self) => matchEffect$2(self, {
	onFailure: (e) => succeed$9(left(e)),
	onSuccess: (a) => succeed$9(right(a))
});
const exit$2 = (self) => matchCause$2(self, {
	onFailure: exitFailCause$1,
	onSuccess: exitSucceed$1
});
const fail$8 = (error) => isObject$1(error) && !(spanSymbol in error) ? withFiberRuntime$1((fiber) => failCause$8(fail$9(capture(error, currentSpanFromFiber(fiber))))) : failCause$8(fail$9(error));
const failSync$2 = (evaluate$1) => flatMap$4(sync$3(evaluate$1), fail$8);
const failCause$8 = (cause$2) => {
	const effect = new EffectPrimitiveFailure(OP_FAILURE);
	effect.effect_instruction_i0 = cause$2;
	return effect;
};
const failCauseSync$2 = (evaluate$1) => flatMap$4(sync$3(evaluate$1), failCause$8);
const fiberId$1 = /* @__PURE__ */ withFiberRuntime$1((state) => succeed$9(state.id()));
const fiberIdWith$1 = (f) => withFiberRuntime$1((state) => f(state.id()));
const flatMap$4 = /* @__PURE__ */ dual(2, (self, f) => {
	const effect = new EffectPrimitive(OP_ON_SUCCESS);
	effect.effect_instruction_i0 = self;
	effect.effect_instruction_i1 = f;
	return effect;
});
const andThen$1 = /* @__PURE__ */ dual(2, (self, f) => flatMap$4(self, (a) => {
	const b = typeof f === "function" ? f(a) : f;
	if (isEffect$1(b)) return b;
	else if (isPromiseLike(b)) return unsafeAsync((resume$1) => {
		b.then((a$1) => resume$1(succeed$9(a$1)), (e) => resume$1(fail$8(new UnknownException(e, "An unknown error occurred in Effect.andThen"))));
	});
	return succeed$9(b);
}));
const step$1 = (self) => {
	const effect = new EffectPrimitive("OnStep");
	effect.effect_instruction_i0 = self;
	return effect;
};
const flatten$3 = (self) => flatMap$4(self, identity);
const flip$1 = (self) => matchEffect$2(self, {
	onFailure: succeed$9,
	onSuccess: fail$8
});
const matchCause$2 = /* @__PURE__ */ dual(2, (self, options) => matchCauseEffect$2(self, {
	onFailure: (cause$2) => succeed$9(options.onFailure(cause$2)),
	onSuccess: (a) => succeed$9(options.onSuccess(a))
}));
const matchCauseEffect$2 = /* @__PURE__ */ dual(2, (self, options) => {
	const effect = new EffectPrimitive(OP_ON_SUCCESS_AND_FAILURE);
	effect.effect_instruction_i0 = self;
	effect.effect_instruction_i1 = options.onFailure;
	effect.effect_instruction_i2 = options.onSuccess;
	return effect;
});
const matchEffect$2 = /* @__PURE__ */ dual(2, (self, options) => matchCauseEffect$2(self, {
	onFailure: (cause$2) => {
		if (defects(cause$2).length > 0) return failCause$8(electFailures(cause$2));
		const failures$1 = failures(cause$2);
		if (failures$1.length > 0) return options.onFailure(unsafeHead(failures$1));
		return failCause$8(cause$2);
	},
	onSuccess: options.onSuccess
}));
const forEachSequential = /* @__PURE__ */ dual(2, (self, f) => suspend$3(() => {
	const arr = fromIterable$10(self);
	const ret = allocate(arr.length);
	let i = 0;
	return as$3(whileLoop$2({
		while: () => i < arr.length,
		body: () => f(arr[i], i),
		step: (b) => {
			ret[i++] = b;
		}
	}), ret);
}));
const forEachSequentialDiscard = /* @__PURE__ */ dual(2, (self, f) => suspend$3(() => {
	const arr = fromIterable$10(self);
	let i = 0;
	return whileLoop$2({
		while: () => i < arr.length,
		body: () => f(arr[i], i),
		step: () => {
			i++;
		}
	});
}));
const if_$1 = /* @__PURE__ */ dual((args$1) => typeof args$1[0] === "boolean" || isEffect$1(args$1[0]), (self, options) => isEffect$1(self) ? flatMap$4(self, (b) => b ? options.onTrue() : options.onFalse()) : self ? options.onTrue() : options.onFalse());
const interrupt$4 = /* @__PURE__ */ flatMap$4(fiberId$1, (fiberId$2) => interruptWith$2(fiberId$2));
const interruptWith$2 = (fiberId$2) => failCause$8(interrupt$5(fiberId$2));
const interruptible$2 = (self) => {
	const effect = new EffectPrimitive(OP_UPDATE_RUNTIME_FLAGS);
	effect.effect_instruction_i0 = enable(Interruption);
	effect.effect_instruction_i1 = () => self;
	return effect;
};
const interruptibleMask$1 = (f) => custom$1(f, function() {
	const effect = new EffectPrimitive(OP_UPDATE_RUNTIME_FLAGS);
	effect.effect_instruction_i0 = enable(Interruption);
	effect.effect_instruction_i1 = (oldFlags) => interruption(oldFlags) ? internalCall(() => this.effect_instruction_i0(interruptible$2)) : internalCall(() => this.effect_instruction_i0(uninterruptible$1));
	return effect;
});
const intoDeferred$1 = /* @__PURE__ */ dual(2, (self, deferred) => uninterruptibleMask$2((restore) => flatMap$4(exit$2(restore(self)), (exit$3) => deferredDone(deferred, exit$3))));
const map$8 = /* @__PURE__ */ dual(2, (self, f) => flatMap$4(self, (a) => sync$3(() => f(a))));
const mapBoth$2 = /* @__PURE__ */ dual(2, (self, options) => matchEffect$2(self, {
	onFailure: (e) => failSync$2(() => options.onFailure(e)),
	onSuccess: (a) => sync$3(() => options.onSuccess(a))
}));
const mapError$3 = /* @__PURE__ */ dual(2, (self, f) => matchCauseEffect$2(self, {
	onFailure: (cause$2) => {
		const either$4 = failureOrCause(cause$2);
		switch (either$4._tag) {
			case "Left": return failSync$2(() => f(either$4.left));
			case "Right": return failCause$8(either$4.right);
		}
	},
	onSuccess: succeed$9
}));
const onError$1 = /* @__PURE__ */ dual(2, (self, cleanup) => onExit$2(self, (exit$3) => exitIsSuccess(exit$3) ? void_$4 : cleanup(exit$3.effect_instruction_i0)));
const onExit$2 = /* @__PURE__ */ dual(2, (self, cleanup) => uninterruptibleMask$2((restore) => matchCauseEffect$2(restore(self), {
	onFailure: (cause1) => {
		const result = exitFailCause$1(cause1);
		return matchCauseEffect$2(cleanup(result), {
			onFailure: (cause2) => exitFailCause$1(sequential$2(cause1, cause2)),
			onSuccess: () => result
		});
	},
	onSuccess: (success) => {
		const result = exitSucceed$1(success);
		return zipRight$3(cleanup(result), result);
	}
})));
const onInterrupt$1 = /* @__PURE__ */ dual(2, (self, cleanup) => onExit$2(self, exitMatch({
	onFailure: (cause$2) => isInterruptedOnly(cause$2) ? asVoid$3(cleanup(interruptors(cause$2))) : void_$4,
	onSuccess: () => void_$4
})));
const orElse$4 = /* @__PURE__ */ dual(2, (self, that) => attemptOrElse(self, that, succeed$9));
const orDie$1 = (self) => orDieWith$1(self, identity);
const orDieWith$1 = /* @__PURE__ */ dual(2, (self, f) => matchEffect$2(self, {
	onFailure: (e) => die$3(f(e)),
	onSuccess: succeed$9
}));
const partitionMap = partitionMap$1;
const runtimeFlags = /* @__PURE__ */ withFiberRuntime$1((_, status$2) => succeed$9(status$2.runtimeFlags));
const succeed$9 = (value) => {
	const effect = new EffectPrimitiveSuccess(OP_SUCCESS);
	effect.effect_instruction_i0 = value;
	return effect;
};
const suspend$3 = (evaluate$1) => {
	const effect = new EffectPrimitive(OP_COMMIT);
	effect.commit = evaluate$1;
	return effect;
};
const sync$3 = (thunk) => {
	const effect = new EffectPrimitive(OP_SYNC);
	effect.effect_instruction_i0 = thunk;
	return effect;
};
const tap$1 = /* @__PURE__ */ dual((args$1) => args$1.length === 3 || args$1.length === 2 && !(isObject$1(args$1[1]) && "onlyEffect" in args$1[1]), (self, f) => flatMap$4(self, (a) => {
	const b = typeof f === "function" ? f(a) : f;
	if (isEffect$1(b)) return as$3(b, a);
	else if (isPromiseLike(b)) return unsafeAsync((resume$1) => {
		b.then((_) => resume$1(succeed$9(a)), (e) => resume$1(fail$8(new UnknownException(e, "An unknown error occurred in Effect.tap"))));
	});
	return succeed$9(a);
}));
const transplant$1 = (f) => withFiberRuntime$1((state) => {
	const scopeOverride = state.getFiberRef(currentForkScopeOverride);
	const scope$2 = pipe(scopeOverride, getOrElse$5(() => state.scope()));
	return f(fiberRefLocally(currentForkScopeOverride, some$4(scope$2)));
});
const attemptOrElse = /* @__PURE__ */ dual(3, (self, that, onSuccess) => matchCauseEffect$2(self, {
	onFailure: (cause$2) => {
		if (defects(cause$2).length > 0) return failCause$8(getOrThrow(keepDefectsAndElectFailures(cause$2)));
		return that();
	},
	onSuccess
}));
const uninterruptible$1 = (self) => {
	const effect = new EffectPrimitive(OP_UPDATE_RUNTIME_FLAGS);
	effect.effect_instruction_i0 = disable(Interruption);
	effect.effect_instruction_i1 = () => self;
	return effect;
};
const uninterruptibleMask$2 = (f) => custom$1(f, function() {
	const effect = new EffectPrimitive(OP_UPDATE_RUNTIME_FLAGS);
	effect.effect_instruction_i0 = disable(Interruption);
	effect.effect_instruction_i1 = (oldFlags) => interruption(oldFlags) ? internalCall(() => this.effect_instruction_i0(interruptible$2)) : internalCall(() => this.effect_instruction_i0(uninterruptible$1));
	return effect;
});
const void_$4 = /* @__PURE__ */ succeed$9(void 0);
const updateRuntimeFlags = (patch$11) => {
	const effect = new EffectPrimitive(OP_UPDATE_RUNTIME_FLAGS);
	effect.effect_instruction_i0 = patch$11;
	effect.effect_instruction_i1 = void 0;
	return effect;
};
const whenEffect$1 = /* @__PURE__ */ dual(2, (self, condition) => flatMap$4(condition, (b) => {
	if (b) return pipe(self, map$8(some$4));
	return succeed$9(none$7());
}));
const whileLoop$2 = (options) => {
	const effect = new EffectPrimitive(OP_WHILE);
	effect.effect_instruction_i0 = options.while;
	effect.effect_instruction_i1 = options.body;
	effect.effect_instruction_i2 = options.step;
	return effect;
};
const fromIterator = (iterator) => suspend$3(() => {
	const effect = new EffectPrimitive(OP_ITERATOR);
	effect.effect_instruction_i0 = iterator();
	return effect;
});
const gen$1 = function() {
	const f = arguments.length === 1 ? arguments[0] : arguments[1].bind(arguments[0]);
	return fromIterator(() => f(pipe));
};
/** @internal */
const fnUntraced$1 = (body, ...pipeables) => Object.defineProperty(pipeables.length === 0 ? function(...args$1) {
	return fromIterator(() => body.apply(this, args$1));
} : function(...args$1) {
	let effect = fromIterator(() => body.apply(this, args$1));
	for (const x of pipeables) effect = x(effect, ...args$1);
	return effect;
}, "length", {
	value: body.length,
	configurable: true
});
const withConcurrency$1 = /* @__PURE__ */ dual(2, (self, concurrency) => fiberRefLocally(self, currentConcurrency, concurrency));
const withRequestBatching$1 = /* @__PURE__ */ dual(2, (self, requestBatching) => fiberRefLocally(self, currentRequestBatching, requestBatching));
const withRuntimeFlags = /* @__PURE__ */ dual(2, (self, update$5) => {
	const effect = new EffectPrimitive(OP_UPDATE_RUNTIME_FLAGS);
	effect.effect_instruction_i0 = update$5;
	effect.effect_instruction_i1 = () => self;
	return effect;
});
/** @internal */
const withTracerEnabled$1 = /* @__PURE__ */ dual(2, (effect, enabled$1) => fiberRefLocally(effect, currentTracerEnabled, enabled$1));
/** @internal */
const withTracerTiming$1 = /* @__PURE__ */ dual(2, (effect, enabled$1) => fiberRefLocally(effect, currentTracerTimingEnabled, enabled$1));
const yieldNow$3 = (options) => {
	const effect = new EffectPrimitive(OP_YIELD);
	return typeof options?.priority !== "undefined" ? withSchedulingPriority$1(effect, options.priority) : effect;
};
const zip$4 = /* @__PURE__ */ dual(2, (self, that) => flatMap$4(self, (a) => map$8(that, (b) => [a, b])));
const zipLeft$3 = /* @__PURE__ */ dual(2, (self, that) => flatMap$4(self, (a) => as$3(that, a)));
const zipRight$3 = /* @__PURE__ */ dual(2, (self, that) => flatMap$4(self, () => that));
const zipWith$4 = /* @__PURE__ */ dual(3, (self, that, f) => flatMap$4(self, (a) => map$8(that, (b) => f(a, b))));
const never$3 = /* @__PURE__ */ asyncInterrupt(() => {
	const interval = setInterval(() => {}, 2 ** 31 - 1);
	return sync$3(() => clearInterval(interval));
});
const interruptFiber = (self) => flatMap$4(fiberId$1, (fiberId$2) => pipe(self, interruptAsFiber(fiberId$2)));
const interruptAsFiber = /* @__PURE__ */ dual(2, (self, fiberId$2) => flatMap$4(self.interruptAsFork(fiberId$2), () => self.await));
/** @internal */
const logLevelAll = {
	_tag: "All",
	syslog: 0,
	label: "ALL",
	ordinal: Number.MIN_SAFE_INTEGER,
	pipe() {
		return pipeArguments(this, arguments);
	}
};
/** @internal */
const logLevelFatal = {
	_tag: "Fatal",
	syslog: 2,
	label: "FATAL",
	ordinal: 5e4,
	pipe() {
		return pipeArguments(this, arguments);
	}
};
/** @internal */
const logLevelError = {
	_tag: "Error",
	syslog: 3,
	label: "ERROR",
	ordinal: 4e4,
	pipe() {
		return pipeArguments(this, arguments);
	}
};
/** @internal */
const logLevelWarning = {
	_tag: "Warning",
	syslog: 4,
	label: "WARN",
	ordinal: 3e4,
	pipe() {
		return pipeArguments(this, arguments);
	}
};
/** @internal */
const logLevelInfo = {
	_tag: "Info",
	syslog: 6,
	label: "INFO",
	ordinal: 2e4,
	pipe() {
		return pipeArguments(this, arguments);
	}
};
/** @internal */
const logLevelDebug = {
	_tag: "Debug",
	syslog: 7,
	label: "DEBUG",
	ordinal: 1e4,
	pipe() {
		return pipeArguments(this, arguments);
	}
};
/** @internal */
const logLevelTrace = {
	_tag: "Trace",
	syslog: 7,
	label: "TRACE",
	ordinal: 0,
	pipe() {
		return pipeArguments(this, arguments);
	}
};
/** @internal */
const logLevelNone = {
	_tag: "None",
	syslog: 7,
	label: "OFF",
	ordinal: Number.MAX_SAFE_INTEGER,
	pipe() {
		return pipeArguments(this, arguments);
	}
};
/** @internal */
const allLogLevels = [
	logLevelAll,
	logLevelTrace,
	logLevelDebug,
	logLevelInfo,
	logLevelWarning,
	logLevelError,
	logLevelFatal,
	logLevelNone
];
/** @internal */
const FiberRefSymbolKey = "effect/FiberRef";
/** @internal */
const FiberRefTypeId = /* @__PURE__ */ Symbol.for(FiberRefSymbolKey);
const fiberRefVariance = { _A: (_) => _ };
const fiberRefGet = (self) => withFiberRuntime$1((fiber) => exitSucceed$1(fiber.getFiberRef(self)));
const fiberRefGetWith = /* @__PURE__ */ dual(2, (self, f) => flatMap$4(fiberRefGet(self), f));
const fiberRefSet = /* @__PURE__ */ dual(2, (self, value) => fiberRefModify(self, () => [void 0, value]));
const fiberRefModify = /* @__PURE__ */ dual(2, (self, f) => withFiberRuntime$1((state) => {
	const [b, a] = f(state.getFiberRef(self));
	state.setFiberRef(self, a);
	return succeed$9(b);
}));
/** @internal */
const RequestResolverSymbolKey = "effect/RequestResolver";
/** @internal */
const RequestResolverTypeId = /* @__PURE__ */ Symbol.for(RequestResolverSymbolKey);
const requestResolverVariance = {
	_A: (_) => _,
	_R: (_) => _
};
/** @internal */
var RequestResolverImpl = class RequestResolverImpl {
	runAll;
	target;
	[RequestResolverTypeId] = requestResolverVariance;
	constructor(runAll, target) {
		this.runAll = runAll;
		this.target = target;
	}
	[symbol$1]() {
		return cached$2(this, this.target ? hash(this.target) : random$2(this));
	}
	[symbol](that) {
		return this.target ? isRequestResolver(that) && equals(this.target, that.target) : this === that;
	}
	identified(...ids$2) {
		return new RequestResolverImpl(this.runAll, fromIterable$9(ids$2));
	}
	pipe() {
		return pipeArguments(this, arguments);
	}
};
/** @internal */
const isRequestResolver = (u) => hasProperty(u, RequestResolverTypeId);
const fiberRefLocally = /* @__PURE__ */ dual(3, (use$1, self, value) => acquireUseRelease$1(zipLeft$3(fiberRefGet(self), fiberRefSet(self, value)), () => use$1, (oldValue) => fiberRefSet(self, oldValue)));
const fiberRefLocallyWith = /* @__PURE__ */ dual(3, (use$1, self, f) => fiberRefGetWith(self, (a) => fiberRefLocally(use$1, self, f(a))));
/** @internal */
const fiberRefUnsafeMake = (initial, options) => fiberRefUnsafeMakePatch(initial, {
	differ: update$4(),
	fork: options?.fork ?? identity,
	join: options?.join
});
/** @internal */
const fiberRefUnsafeMakeHashSet = (initial) => {
	const differ$2 = hashSet$1();
	return fiberRefUnsafeMakePatch(initial, {
		differ: differ$2,
		fork: differ$2.empty
	});
};
/** @internal */
const fiberRefUnsafeMakeReadonlyArray = (initial) => {
	const differ$2 = readonlyArray$1(update$4());
	return fiberRefUnsafeMakePatch(initial, {
		differ: differ$2,
		fork: differ$2.empty
	});
};
/** @internal */
const fiberRefUnsafeMakeContext = (initial) => {
	const differ$2 = environment$1();
	return fiberRefUnsafeMakePatch(initial, {
		differ: differ$2,
		fork: differ$2.empty
	});
};
/** @internal */
const fiberRefUnsafeMakePatch = (initial, options) => {
	return {
		...CommitPrototype$1,
		[FiberRefTypeId]: fiberRefVariance,
		initial,
		commit() {
			return fiberRefGet(this);
		},
		diff: (oldValue, newValue) => options.differ.diff(oldValue, newValue),
		combine: (first$2, second) => options.differ.combine(first$2, second),
		patch: (patch$11) => (oldValue) => options.differ.patch(patch$11, oldValue),
		fork: options.fork,
		join: options.join ?? ((_, n) => n)
	};
};
/** @internal */
const fiberRefUnsafeMakeRuntimeFlags = (initial) => fiberRefUnsafeMakePatch(initial, {
	differ: differ$1,
	fork: differ$1.empty
});
/** @internal */
const currentContext = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentContext"), () => fiberRefUnsafeMakeContext(empty$25()));
/** @internal */
const currentSchedulingPriority = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentSchedulingPriority"), () => fiberRefUnsafeMake(0));
/** @internal */
const currentMaxOpsBeforeYield = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentMaxOpsBeforeYield"), () => fiberRefUnsafeMake(2048));
/** @internal */
const currentLogAnnotations = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentLogAnnotation"), () => fiberRefUnsafeMake(empty$24()));
/** @internal */
const currentLogLevel = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentLogLevel"), () => fiberRefUnsafeMake(logLevelInfo));
/** @internal */
const currentLogSpan = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentLogSpan"), () => fiberRefUnsafeMake(empty$23()));
/** @internal */
const withSchedulingPriority$1 = /* @__PURE__ */ dual(2, (self, scheduler) => fiberRefLocally(self, currentSchedulingPriority, scheduler));
/** @internal */
const withMaxOpsBeforeYield$1 = /* @__PURE__ */ dual(2, (self, scheduler) => fiberRefLocally(self, currentMaxOpsBeforeYield, scheduler));
/** @internal */
const currentConcurrency = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentConcurrency"), () => fiberRefUnsafeMake("unbounded"));
/**
* @internal
*/
const currentRequestBatching = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentRequestBatching"), () => fiberRefUnsafeMake(true));
/** @internal */
const currentUnhandledErrorLogLevel = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentUnhandledErrorLogLevel"), () => fiberRefUnsafeMake(some$4(logLevelDebug)));
/** @internal */
const currentVersionMismatchErrorLogLevel = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/versionMismatchErrorLogLevel"), () => fiberRefUnsafeMake(some$4(logLevelWarning)));
/** @internal */
const withUnhandledErrorLogLevel$1 = /* @__PURE__ */ dual(2, (self, level) => fiberRefLocally(self, currentUnhandledErrorLogLevel, level));
/** @internal */
const currentMetricLabels = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentMetricLabels"), () => fiberRefUnsafeMakeReadonlyArray(empty$32()));
const metricLabels$1 = /* @__PURE__ */ fiberRefGet(currentMetricLabels);
/** @internal */
const currentForkScopeOverride = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentForkScopeOverride"), () => fiberRefUnsafeMake(none$7(), {
	fork: () => none$7(),
	join: (parent, _) => parent
}));
/** @internal */
const currentInterruptedCause = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentInterruptedCause"), () => fiberRefUnsafeMake(empty$27, {
	fork: () => empty$27,
	join: (parent, _) => parent
}));
/** @internal */
const currentTracerEnabled = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentTracerEnabled"), () => fiberRefUnsafeMake(true));
/** @internal */
const currentTracerTimingEnabled = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentTracerTiming"), () => fiberRefUnsafeMake(true));
/** @internal */
const currentTracerSpanAnnotations = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentTracerSpanAnnotations"), () => fiberRefUnsafeMake(empty$24()));
/** @internal */
const currentTracerSpanLinks = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentTracerSpanLinks"), () => fiberRefUnsafeMake(empty$31()));
/** @internal */
const ScopeTypeId$1 = /* @__PURE__ */ Symbol.for("effect/Scope");
/** @internal */
const CloseableScopeTypeId$1 = /* @__PURE__ */ Symbol.for("effect/CloseableScope");
const scopeAddFinalizer = (self, finalizer) => self.addFinalizer(() => asVoid$3(finalizer));
const scopeAddFinalizerExit = (self, finalizer) => self.addFinalizer(finalizer);
const scopeClose = (self, exit$3) => self.close(exit$3);
const scopeFork = (self, strategy) => self.fork(strategy);
/** @internal */
const YieldableError = /* @__PURE__ */ function() {
	class YieldableError$1 extends globalThis.Error {
		commit() {
			return fail$8(this);
		}
		toJSON() {
			const obj = { ...this };
			if (this.message) obj.message = this.message;
			if (this.cause) obj.cause = this.cause;
			return obj;
		}
		[NodeInspectSymbol]() {
			if (this.toString !== globalThis.Error.prototype.toString) return this.stack ? `${this.toString()}\n${this.stack.split("\n").slice(1).join("\n")}` : this.toString();
			else if ("Bun" in globalThis) return pretty$2(fail$9(this), { renderErrorCause: true });
			return this;
		}
	}
	Object.assign(YieldableError$1.prototype, StructuralCommitPrototype$1);
	return YieldableError$1;
}();
const makeException = (proto$3, tag) => {
	class Base$2 extends YieldableError {
		_tag = tag;
	}
	Object.assign(Base$2.prototype, proto$3);
	Base$2.prototype.name = tag;
	return Base$2;
};
/** @internal */
const RuntimeExceptionTypeId = /* @__PURE__ */ Symbol.for("effect/Cause/errors/RuntimeException");
/** @internal */
const RuntimeException = /* @__PURE__ */ makeException({ [RuntimeExceptionTypeId]: RuntimeExceptionTypeId }, "RuntimeException");
/** @internal */
const InterruptedExceptionTypeId = /* @__PURE__ */ Symbol.for("effect/Cause/errors/InterruptedException");
/** @internal */
const InterruptedException = /* @__PURE__ */ makeException({ [InterruptedExceptionTypeId]: InterruptedExceptionTypeId }, "InterruptedException");
/** @internal */
const isInterruptedException = (u) => hasProperty(u, InterruptedExceptionTypeId);
/** @internal */
const IllegalArgumentExceptionTypeId = /* @__PURE__ */ Symbol.for("effect/Cause/errors/IllegalArgument");
/** @internal */
const IllegalArgumentException = /* @__PURE__ */ makeException({ [IllegalArgumentExceptionTypeId]: IllegalArgumentExceptionTypeId }, "IllegalArgumentException");
/** @internal */
const NoSuchElementExceptionTypeId = /* @__PURE__ */ Symbol.for("effect/Cause/errors/NoSuchElement");
/** @internal */
const NoSuchElementException = /* @__PURE__ */ makeException({ [NoSuchElementExceptionTypeId]: NoSuchElementExceptionTypeId }, "NoSuchElementException");
/** @internal */
const isNoSuchElementException = (u) => hasProperty(u, NoSuchElementExceptionTypeId);
/** @internal */
const InvalidPubSubCapacityExceptionTypeId = /* @__PURE__ */ Symbol.for("effect/Cause/errors/InvalidPubSubCapacityException");
/** @internal */
const InvalidPubSubCapacityException = /* @__PURE__ */ makeException({ [InvalidPubSubCapacityExceptionTypeId]: InvalidPubSubCapacityExceptionTypeId }, "InvalidPubSubCapacityException");
/** @internal */
const ExceededCapacityExceptionTypeId = /* @__PURE__ */ Symbol.for("effect/Cause/errors/ExceededCapacityException");
/** @internal */
const ExceededCapacityException = /* @__PURE__ */ makeException({ [ExceededCapacityExceptionTypeId]: ExceededCapacityExceptionTypeId }, "ExceededCapacityException");
/** @internal */
const TimeoutExceptionTypeId = /* @__PURE__ */ Symbol.for("effect/Cause/errors/Timeout");
/** @internal */
const TimeoutException = /* @__PURE__ */ makeException({ [TimeoutExceptionTypeId]: TimeoutExceptionTypeId }, "TimeoutException");
/** @internal */
const timeoutExceptionFromDuration = (duration) => new TimeoutException(`Operation timed out after '${format$2(duration)}'`);
/** @internal */
const UnknownExceptionTypeId = /* @__PURE__ */ Symbol.for("effect/Cause/errors/UnknownException");
/** @internal */
const UnknownException = /* @__PURE__ */ function() {
	class UnknownException$1 extends YieldableError {
		_tag = "UnknownException";
		error;
		constructor(cause$2, message) {
			super(message ?? "An unknown error occurred", { cause: cause$2 });
			this.error = cause$2;
		}
	}
	Object.assign(UnknownException$1.prototype, {
		[UnknownExceptionTypeId]: UnknownExceptionTypeId,
		name: "UnknownException"
	});
	return UnknownException$1;
}();
/** @internal */
const exitIsExit = (u) => isEffect$1(u) && "_tag" in u && (u._tag === "Success" || u._tag === "Failure");
/** @internal */
const exitIsFailure = (self) => self._tag === "Failure";
/** @internal */
const exitIsSuccess = (self) => self._tag === "Success";
/** @internal */
const exitIsInterrupted = (self) => {
	switch (self._tag) {
		case OP_FAILURE: return isInterrupted$1(self.effect_instruction_i0);
		case OP_SUCCESS: return false;
	}
};
/** @internal */
const exitAs = /* @__PURE__ */ dual(2, (self, value) => {
	switch (self._tag) {
		case OP_FAILURE: return exitFailCause$1(self.effect_instruction_i0);
		case OP_SUCCESS: return exitSucceed$1(value);
	}
});
/** @internal */
const exitAsVoid = (self) => exitAs(self, void 0);
/** @internal */
const exitCauseOption = (self) => {
	switch (self._tag) {
		case OP_FAILURE: return some$4(self.effect_instruction_i0);
		case OP_SUCCESS: return none$7();
	}
};
/** @internal */
const exitCollectAll = (exits, options) => exitCollectAllInternal(exits, options?.parallel ? parallel$2 : sequential$2);
/** @internal */
const exitDie$1 = (defect) => exitFailCause$1(die$4(defect));
/** @internal */
const exitExists = /* @__PURE__ */ dual(2, (self, refinement) => {
	switch (self._tag) {
		case OP_FAILURE: return false;
		case OP_SUCCESS: return refinement(self.effect_instruction_i0);
	}
});
/** @internal */
const exitFail = (error) => exitFailCause$1(fail$9(error));
/** @internal */
const exitFailCause$1 = (cause$2) => {
	const effect = new EffectPrimitiveFailure(OP_FAILURE);
	effect.effect_instruction_i0 = cause$2;
	return effect;
};
/** @internal */
const exitFlatMap = /* @__PURE__ */ dual(2, (self, f) => {
	switch (self._tag) {
		case OP_FAILURE: return exitFailCause$1(self.effect_instruction_i0);
		case OP_SUCCESS: return f(self.effect_instruction_i0);
	}
});
/** @internal */
const exitFlatMapEffect = /* @__PURE__ */ dual(2, (self, f) => {
	switch (self._tag) {
		case OP_FAILURE: return succeed$9(exitFailCause$1(self.effect_instruction_i0));
		case OP_SUCCESS: return f(self.effect_instruction_i0);
	}
});
/** @internal */
const exitFlatten = (self) => pipe(self, exitFlatMap(identity));
/** @internal */
const exitForEachEffect = /* @__PURE__ */ dual(2, (self, f) => {
	switch (self._tag) {
		case OP_FAILURE: return succeed$9(exitFailCause$1(self.effect_instruction_i0));
		case OP_SUCCESS: return exit$2(f(self.effect_instruction_i0));
	}
});
/** @internal */
const exitFromEither = (either$4) => {
	switch (either$4._tag) {
		case "Left": return exitFail(either$4.left);
		case "Right": return exitSucceed$1(either$4.right);
	}
};
/** @internal */
const exitFromOption = (option$2) => {
	switch (option$2._tag) {
		case "None": return exitFail(void 0);
		case "Some": return exitSucceed$1(option$2.value);
	}
};
/** @internal */
const exitGetOrElse = /* @__PURE__ */ dual(2, (self, orElse$6) => {
	switch (self._tag) {
		case OP_FAILURE: return orElse$6(self.effect_instruction_i0);
		case OP_SUCCESS: return self.effect_instruction_i0;
	}
});
/** @internal */
const exitInterrupt$1 = (fiberId$2) => exitFailCause$1(interrupt$5(fiberId$2));
/** @internal */
const exitMap = /* @__PURE__ */ dual(2, (self, f) => {
	switch (self._tag) {
		case OP_FAILURE: return exitFailCause$1(self.effect_instruction_i0);
		case OP_SUCCESS: return exitSucceed$1(f(self.effect_instruction_i0));
	}
});
/** @internal */
const exitMapBoth = /* @__PURE__ */ dual(2, (self, { onFailure, onSuccess }) => {
	switch (self._tag) {
		case OP_FAILURE: return exitFailCause$1(pipe(self.effect_instruction_i0, map$10(onFailure)));
		case OP_SUCCESS: return exitSucceed$1(onSuccess(self.effect_instruction_i0));
	}
});
/** @internal */
const exitMapError = /* @__PURE__ */ dual(2, (self, f) => {
	switch (self._tag) {
		case OP_FAILURE: return exitFailCause$1(pipe(self.effect_instruction_i0, map$10(f)));
		case OP_SUCCESS: return exitSucceed$1(self.effect_instruction_i0);
	}
});
/** @internal */
const exitMapErrorCause = /* @__PURE__ */ dual(2, (self, f) => {
	switch (self._tag) {
		case OP_FAILURE: return exitFailCause$1(f(self.effect_instruction_i0));
		case OP_SUCCESS: return exitSucceed$1(self.effect_instruction_i0);
	}
});
/** @internal */
const exitMatch = /* @__PURE__ */ dual(2, (self, { onFailure, onSuccess }) => {
	switch (self._tag) {
		case OP_FAILURE: return onFailure(self.effect_instruction_i0);
		case OP_SUCCESS: return onSuccess(self.effect_instruction_i0);
	}
});
/** @internal */
const exitMatchEffect = /* @__PURE__ */ dual(2, (self, { onFailure, onSuccess }) => {
	switch (self._tag) {
		case OP_FAILURE: return onFailure(self.effect_instruction_i0);
		case OP_SUCCESS: return onSuccess(self.effect_instruction_i0);
	}
});
/** @internal */
const exitSucceed$1 = (value) => {
	const effect = new EffectPrimitiveSuccess(OP_SUCCESS);
	effect.effect_instruction_i0 = value;
	return effect;
};
/** @internal */
const exitVoid$1 = /* @__PURE__ */ exitSucceed$1(void 0);
/** @internal */
const exitZip = /* @__PURE__ */ dual(2, (self, that) => exitZipWith(self, that, {
	onSuccess: (a, a2) => [a, a2],
	onFailure: sequential$2
}));
/** @internal */
const exitZipLeft = /* @__PURE__ */ dual(2, (self, that) => exitZipWith(self, that, {
	onSuccess: (a, _) => a,
	onFailure: sequential$2
}));
/** @internal */
const exitZipRight = /* @__PURE__ */ dual(2, (self, that) => exitZipWith(self, that, {
	onSuccess: (_, a2) => a2,
	onFailure: sequential$2
}));
/** @internal */
const exitZipPar = /* @__PURE__ */ dual(2, (self, that) => exitZipWith(self, that, {
	onSuccess: (a, a2) => [a, a2],
	onFailure: parallel$2
}));
/** @internal */
const exitZipParLeft = /* @__PURE__ */ dual(2, (self, that) => exitZipWith(self, that, {
	onSuccess: (a, _) => a,
	onFailure: parallel$2
}));
/** @internal */
const exitZipParRight = /* @__PURE__ */ dual(2, (self, that) => exitZipWith(self, that, {
	onSuccess: (_, a2) => a2,
	onFailure: parallel$2
}));
/** @internal */
const exitZipWith = /* @__PURE__ */ dual(3, (self, that, { onFailure, onSuccess }) => {
	switch (self._tag) {
		case OP_FAILURE: switch (that._tag) {
			case OP_SUCCESS: return exitFailCause$1(self.effect_instruction_i0);
			case OP_FAILURE: return exitFailCause$1(onFailure(self.effect_instruction_i0, that.effect_instruction_i0));
		}
		case OP_SUCCESS: switch (that._tag) {
			case OP_SUCCESS: return exitSucceed$1(onSuccess(self.effect_instruction_i0, that.effect_instruction_i0));
			case OP_FAILURE: return exitFailCause$1(that.effect_instruction_i0);
		}
	}
});
const exitCollectAllInternal = (exits, combineCauses) => {
	const list = fromIterable$9(exits);
	if (!isNonEmpty$5(list)) return none$7();
	return pipe(tailNonEmpty(list), reduce$11(pipe(headNonEmpty(list), exitMap(of$3)), (accumulator, current) => pipe(accumulator, exitZipWith(current, {
		onSuccess: (list$1, value) => pipe(list$1, prepend$1(value)),
		onFailure: combineCauses
	}))), exitMap(reverse$1), exitMap((chunk$2) => toReadonlyArray(chunk$2)), some$4);
};
/** @internal */
const deferredUnsafeMake = (fiberId$2) => {
	return {
		...CommitPrototype$1,
		[DeferredTypeId$1]: deferredVariance,
		state: make$34(pending$1([])),
		commit() {
			return deferredAwait(this);
		},
		blockingOn: fiberId$2
	};
};
const deferredMake = () => flatMap$4(fiberId$1, (id$2) => deferredMakeAs(id$2));
const deferredMakeAs = (fiberId$2) => sync$3(() => deferredUnsafeMake(fiberId$2));
const deferredAwait = (self) => asyncInterrupt((resume$1) => {
	const state = get$6(self.state);
	switch (state._tag) {
		case OP_STATE_DONE: return resume$1(state.effect);
		case OP_STATE_PENDING:
			state.joiners.push(resume$1);
			return deferredInterruptJoiner(self, resume$1);
	}
}, self.blockingOn);
const deferredComplete = /* @__PURE__ */ dual(2, (self, effect) => intoDeferred$1(effect, self));
const deferredCompleteWith = /* @__PURE__ */ dual(2, (self, effect) => sync$3(() => {
	const state = get$6(self.state);
	switch (state._tag) {
		case OP_STATE_DONE: return false;
		case OP_STATE_PENDING:
			set$4(self.state, done$7(effect));
			for (let i = 0, len = state.joiners.length; i < len; i++) state.joiners[i](effect);
			return true;
	}
}));
const deferredDone = /* @__PURE__ */ dual(2, (self, exit$3) => deferredCompleteWith(self, exit$3));
const deferredFail = /* @__PURE__ */ dual(2, (self, error) => deferredCompleteWith(self, fail$8(error)));
const deferredFailSync = /* @__PURE__ */ dual(2, (self, evaluate$1) => deferredCompleteWith(self, failSync$2(evaluate$1)));
const deferredFailCause = /* @__PURE__ */ dual(2, (self, cause$2) => deferredCompleteWith(self, failCause$8(cause$2)));
const deferredFailCauseSync = /* @__PURE__ */ dual(2, (self, evaluate$1) => deferredCompleteWith(self, failCauseSync$2(evaluate$1)));
const deferredDie = /* @__PURE__ */ dual(2, (self, defect) => deferredCompleteWith(self, die$3(defect)));
const deferredDieSync = /* @__PURE__ */ dual(2, (self, evaluate$1) => deferredCompleteWith(self, dieSync$2(evaluate$1)));
const deferredInterrupt = (self) => flatMap$4(fiberId$1, (fiberId$2) => deferredCompleteWith(self, interruptWith$2(fiberId$2)));
const deferredInterruptWith = /* @__PURE__ */ dual(2, (self, fiberId$2) => deferredCompleteWith(self, interruptWith$2(fiberId$2)));
const deferredIsDone = (self) => sync$3(() => get$6(self.state)._tag === OP_STATE_DONE);
const deferredPoll = (self) => sync$3(() => {
	const state = get$6(self.state);
	switch (state._tag) {
		case OP_STATE_DONE: return some$4(state.effect);
		case OP_STATE_PENDING: return none$7();
	}
});
const deferredSucceed = /* @__PURE__ */ dual(2, (self, value) => deferredCompleteWith(self, succeed$9(value)));
const deferredSync = /* @__PURE__ */ dual(2, (self, evaluate$1) => deferredCompleteWith(self, sync$3(evaluate$1)));
/** @internal */
const deferredUnsafeDone = (self, effect) => {
	const state = get$6(self.state);
	if (state._tag === OP_STATE_PENDING) {
		set$4(self.state, done$7(effect));
		for (let i = 0, len = state.joiners.length; i < len; i++) state.joiners[i](effect);
	}
};
const deferredInterruptJoiner = (self, joiner) => sync$3(() => {
	const state = get$6(self.state);
	if (state._tag === OP_STATE_PENDING) {
		const index = state.joiners.indexOf(joiner);
		if (index >= 0) state.joiners.splice(index, 1);
	}
});
const constContext = /* @__PURE__ */ withFiberRuntime$1((fiber) => exitSucceed$1(fiber.currentContext));
const context$1 = () => constContext;
const contextWithEffect$1 = (f) => flatMap$4(context$1(), f);
const provideContext$1 = /* @__PURE__ */ dual(2, (self, context$2) => fiberRefLocally(currentContext, context$2)(self));
const provideSomeContext = /* @__PURE__ */ dual(2, (self, context$2) => fiberRefLocallyWith(currentContext, (parent) => merge$4(parent, context$2))(self));
const mapInputContext$1 = /* @__PURE__ */ dual(2, (self, f) => contextWithEffect$1((context$2) => provideContext$1(self, f(context$2))));
/** @internal */
const filterEffectOrElse$1 = /* @__PURE__ */ dual(2, (self, options) => flatMap$4(self, (a) => flatMap$4(options.predicate(a), (pass) => pass ? succeed$9(a) : options.orElse(a))));
/** @internal */
const filterEffectOrFail$1 = /* @__PURE__ */ dual(2, (self, options) => filterEffectOrElse$1(self, {
	predicate: options.predicate,
	orElse: (a) => fail$8(options.orFailWith(a))
}));
/** @internal */
const currentSpanFromFiber = (fiber) => {
	const span$1 = fiber.currentSpan;
	return span$1 !== void 0 && span$1._tag === "Span" ? some$4(span$1) : none$7();
};
const NoopSpanProto = {
	_tag: "Span",
	spanId: "noop",
	traceId: "noop",
	sampled: false,
	status: {
		_tag: "Ended",
		startTime: /* @__PURE__ */ BigInt(0),
		endTime: /* @__PURE__ */ BigInt(0),
		exit: exitVoid$1
	},
	attributes: /* @__PURE__ */ new Map(),
	links: [],
	kind: "internal",
	attribute() {},
	event() {},
	end() {},
	addLinks() {}
};
/** @internal */
const noopSpan = (options) => Object.assign(Object.create(NoopSpanProto), options);

//#endregion
//#region ../../node_modules/.bun/effect@3.17.14/node_modules/effect/dist/esm/internal/opCodes/configError.js
/** @internal */
const OP_AND = "And";
/** @internal */
const OP_OR = "Or";
/** @internal */
const OP_INVALID_DATA = "InvalidData";
/** @internal */
const OP_MISSING_DATA = "MissingData";
/** @internal */
const OP_SOURCE_UNAVAILABLE = "SourceUnavailable";
/** @internal */
const OP_UNSUPPORTED = "Unsupported";

//#endregion
//#region ../../node_modules/.bun/effect@3.17.14/node_modules/effect/dist/esm/internal/configError.js
/** @internal */
const ConfigErrorSymbolKey = "effect/ConfigError";
/** @internal */
const ConfigErrorTypeId = /* @__PURE__ */ Symbol.for(ConfigErrorSymbolKey);
/** @internal */
const proto$1 = {
	_tag: "ConfigError",
	[ConfigErrorTypeId]: ConfigErrorTypeId
};
/** @internal */
const And = (self, that) => {
	const error = Object.create(proto$1);
	error._op = OP_AND;
	error.left = self;
	error.right = that;
	Object.defineProperty(error, "toString", {
		enumerable: false,
		value() {
			return `${this.left} and ${this.right}`;
		}
	});
	Object.defineProperty(error, "message", {
		enumerable: false,
		get() {
			return this.toString();
		}
	});
	return error;
};
/** @internal */
const Or = (self, that) => {
	const error = Object.create(proto$1);
	error._op = OP_OR;
	error.left = self;
	error.right = that;
	Object.defineProperty(error, "toString", {
		enumerable: false,
		value() {
			return `${this.left} or ${this.right}`;
		}
	});
	Object.defineProperty(error, "message", {
		enumerable: false,
		get() {
			return this.toString();
		}
	});
	return error;
};
/** @internal */
const InvalidData = (path, message, options = { pathDelim: "." }) => {
	const error = Object.create(proto$1);
	error._op = OP_INVALID_DATA;
	error.path = path;
	error.message = message;
	Object.defineProperty(error, "toString", {
		enumerable: false,
		value() {
			return `(Invalid data at ${pipe(this.path, join$3(options.pathDelim))}: "${this.message}")`;
		}
	});
	return error;
};
/** @internal */
const MissingData = (path, message, options = { pathDelim: "." }) => {
	const error = Object.create(proto$1);
	error._op = OP_MISSING_DATA;
	error.path = path;
	error.message = message;
	Object.defineProperty(error, "toString", {
		enumerable: false,
		value() {
			return `(Missing data at ${pipe(this.path, join$3(options.pathDelim))}: "${this.message}")`;
		}
	});
	return error;
};
/** @internal */
const SourceUnavailable = (path, message, cause$2, options = { pathDelim: "." }) => {
	const error = Object.create(proto$1);
	error._op = OP_SOURCE_UNAVAILABLE;
	error.path = path;
	error.message = message;
	error.cause = cause$2;
	Object.defineProperty(error, "toString", {
		enumerable: false,
		value() {
			return `(Source unavailable at ${pipe(this.path, join$3(options.pathDelim))}: "${this.message}")`;
		}
	});
	return error;
};
/** @internal */
const Unsupported = (path, message, options = { pathDelim: "." }) => {
	const error = Object.create(proto$1);
	error._op = OP_UNSUPPORTED;
	error.path = path;
	error.message = message;
	Object.defineProperty(error, "toString", {
		enumerable: false,
		value() {
			return `(Unsupported operation at ${pipe(this.path, join$3(options.pathDelim))}: "${this.message}")`;
		}
	});
	return error;
};
/** @internal */
const prefixed = /* @__PURE__ */ dual(2, (self, prefix) => {
	switch (self._op) {
		case OP_AND: return And(prefixed(self.left, prefix), prefixed(self.right, prefix));
		case OP_OR: return Or(prefixed(self.left, prefix), prefixed(self.right, prefix));
		case OP_INVALID_DATA: return InvalidData([...prefix, ...self.path], self.message);
		case OP_MISSING_DATA: return MissingData([...prefix, ...self.path], self.message);
		case OP_SOURCE_UNAVAILABLE: return SourceUnavailable([...prefix, ...self.path], self.message, self.cause);
		case OP_UNSUPPORTED: return Unsupported([...prefix, ...self.path], self.message);
	}
});

//#endregion
//#region ../../node_modules/.bun/effect@3.17.14/node_modules/effect/dist/esm/internal/clock.js
/** @internal */
const ClockSymbolKey = "effect/Clock";
/** @internal */
const ClockTypeId$1 = /* @__PURE__ */ Symbol.for(ClockSymbolKey);
/** @internal */
const clockTag = /* @__PURE__ */ GenericTag("effect/Clock");
/** @internal */
const MAX_TIMER_MILLIS = 2 ** 31 - 1;
/** @internal */
const globalClockScheduler = { unsafeSchedule(task, duration) {
	const millis$1 = toMillis(duration);
	if (millis$1 > MAX_TIMER_MILLIS) return constFalse;
	let completed = false;
	const handle = setTimeout(() => {
		completed = true;
		task();
	}, millis$1);
	return () => {
		clearTimeout(handle);
		return !completed;
	};
} };
const performanceNowNanos = /* @__PURE__ */ function() {
	const bigint1e6$1 = /* @__PURE__ */ BigInt(1e6);
	if (typeof performance === "undefined") return () => BigInt(Date.now()) * bigint1e6$1;
	let origin;
	return () => {
		if (origin === void 0) origin = BigInt(Date.now()) * bigint1e6$1 - BigInt(Math.round(performance.now() * 1e6));
		return origin + BigInt(Math.round(performance.now() * 1e6));
	};
}();
const processOrPerformanceNow = /* @__PURE__ */ function() {
	const processHrtime = typeof process === "object" && "hrtime" in process && typeof process.hrtime.bigint === "function" ? process.hrtime : void 0;
	if (!processHrtime) return performanceNowNanos;
	const origin = /* @__PURE__ */ performanceNowNanos() - /* @__PURE__ */ processHrtime.bigint();
	return () => origin + processHrtime.bigint();
}();
/** @internal */
var ClockImpl = class {
	[ClockTypeId$1] = ClockTypeId$1;
	unsafeCurrentTimeMillis() {
		return Date.now();
	}
	unsafeCurrentTimeNanos() {
		return processOrPerformanceNow();
	}
	currentTimeMillis = /* @__PURE__ */ sync$3(() => this.unsafeCurrentTimeMillis());
	currentTimeNanos = /* @__PURE__ */ sync$3(() => this.unsafeCurrentTimeNanos());
	scheduler() {
		return succeed$9(globalClockScheduler);
	}
	sleep(duration) {
		return async_((resume$1) => {
			const canceler = globalClockScheduler.unsafeSchedule(() => resume$1(void_$4), duration);
			return asVoid$3(sync$3(canceler));
		});
	}
};
/** @internal */
const make$26 = () => new ClockImpl();

//#endregion
//#region ../../node_modules/.bun/effect@3.17.14/node_modules/effect/dist/esm/Number.js
/**
* Type guard that tests if a value is a member of the set of JavaScript
* numbers.
*
* @memberof Number
* @since 2.0.0
* @category guards
* @example
*
* ```ts
* import * as assert from "node:assert/strict"
* import * as Number from "effect/Number"
*
* // Regular numbers
* assert.equal(Number.isNumber(2), true)
* assert.equal(Number.isNumber(-3.14), true)
* assert.equal(Number.isNumber(0), true)
*
* // Special numeric values
* assert.equal(Number.isNumber(Infinity), true)
* assert.equal(Number.isNumber(NaN), true)
*
* // Non-number values
* assert.equal(Number.isNumber("2"), false)
* assert.equal(Number.isNumber(true), false)
* assert.equal(Number.isNumber(null), false)
* assert.equal(Number.isNumber(undefined), false)
* assert.equal(Number.isNumber({}), false)
* assert.equal(Number.isNumber([]), false)
*
* // Using as a type guard in conditionals
* function processValue(value: unknown): string {
*   if (Number.isNumber(value)) {
*     // TypeScript now knows 'value' is a number
*     return `Numeric value: ${value.toFixed(2)}`
*   }
*   return "Not a number"
* }
*
* assert.strictEqual(processValue(42), "Numeric value: 42.00")
* assert.strictEqual(processValue("hello"), "Not a number")
*
* // Filtering for numbers in an array
* const mixed = [1, "two", 3, false, 5]
* const onlyNumbers = mixed.filter(Number.isNumber)
* assert.equal(onlyNumbers, [1, 3, 5])
* ```
*
* @param input - The value to test for membership in the set of JavaScript
*   numbers
*
* @returns `true` if the input is a JavaScript number, `false` otherwise
*/
const isNumber = isNumber$1;
/**
* @memberof Number
* @since 2.0.0
* @category instances
*/
const Equivalence = number$2;
/**
* @memberof Number
* @since 2.0.0
* @category instances
*/
const Order$3 = number;

//#endregion
//#region ../../node_modules/.bun/effect@3.17.14/node_modules/effect/dist/esm/RegExp.js
/**
* Tests if a value is a `RegExp`.
*
* @example
* ```ts
* import * as assert from "node:assert"
* import { RegExp } from "effect"
*
* assert.deepStrictEqual(RegExp.isRegExp(/a/), true)
* assert.deepStrictEqual(RegExp.isRegExp("a"), false)
* ```
*
* @category guards
* @since 3.9.0
*/
const isRegExp = isRegExp$1;
/**
* Escapes special characters in a regular expression pattern.
*
* @example
* ```ts
* import * as assert from "node:assert"
* import { RegExp } from "effect"
*
* assert.deepStrictEqual(RegExp.escape("a*b"), "a\\*b")
* ```
*
* @since 2.0.0
*/
const escape = (string$1) => string$1.replace(/[/\\^$*+?.()|[\]{}]/g, "\\$&");

//#endregion
//#region ../../node_modules/.bun/effect@3.17.14/node_modules/effect/dist/esm/internal/configProvider/pathPatch.js
/** @internal */
const empty$13 = { _tag: "Empty" };
/** @internal */
const patch$3 = /* @__PURE__ */ dual(2, (path, patch$11) => {
	let input = of$2(patch$11);
	let output = path;
	while (isCons(input)) {
		const patch$12 = input.head;
		switch (patch$12._tag) {
			case "Empty":
				input = input.tail;
				break;
			case "AndThen":
				input = cons(patch$12.first, cons(patch$12.second, input.tail));
				break;
			case "MapName":
				output = map$14(output, patch$12.f);
				input = input.tail;
				break;
			case "Nested":
				output = prepend$2(output, patch$12.name);
				input = input.tail;
				break;
			case "Unnested":
				if (pipe(head$3(output), contains$2(patch$12.name))) {
					output = tailNonEmpty$1(output);
					input = input.tail;
				} else return left(MissingData(output, `Expected ${patch$12.name} to be in path in ConfigProvider#unnested`));
				break;
		}
	}
	return right(output);
});

//#endregion
//#region ../../node_modules/.bun/effect@3.17.14/node_modules/effect/dist/esm/internal/opCodes/config.js
/** @internal */
const OP_CONSTANT = "Constant";
/** @internal */
const OP_FAIL = "Fail";
/** @internal */
const OP_FALLBACK = "Fallback";
/** @internal */
const OP_DESCRIBED = "Described";
/** @internal */
const OP_LAZY = "Lazy";
/** @internal */
const OP_MAP_OR_FAIL = "MapOrFail";
/** @internal */
const OP_NESTED = "Nested";
/** @internal */
const OP_PRIMITIVE = "Primitive";
/** @internal */
const OP_SEQUENCE = "Sequence";
/** @internal */
const OP_HASHMAP = "HashMap";
/** @internal */
const OP_ZIP_WITH$1 = "ZipWith";

//#endregion
//#region ../../node_modules/.bun/effect@3.17.14/node_modules/effect/dist/esm/internal/configProvider.js
const concat = (l, r) => [...l, ...r];
/** @internal */
const ConfigProviderSymbolKey = "effect/ConfigProvider";
/** @internal */
const ConfigProviderTypeId = /* @__PURE__ */ Symbol.for(ConfigProviderSymbolKey);
/** @internal */
const configProviderTag = /* @__PURE__ */ GenericTag("effect/ConfigProvider");
/** @internal */
const FlatConfigProviderSymbolKey = "effect/ConfigProviderFlat";
/** @internal */
const FlatConfigProviderTypeId = /* @__PURE__ */ Symbol.for(FlatConfigProviderSymbolKey);
/** @internal */
const make$25 = (options) => ({
	[ConfigProviderTypeId]: ConfigProviderTypeId,
	pipe() {
		return pipeArguments(this, arguments);
	},
	...options
});
/** @internal */
const makeFlat = (options) => ({
	[FlatConfigProviderTypeId]: FlatConfigProviderTypeId,
	patch: options.patch,
	load: (path, config, split = true) => options.load(path, config, split),
	enumerateChildren: options.enumerateChildren
});
/** @internal */
const fromFlat = (flat) => make$25({
	load: (config) => flatMap$4(fromFlatLoop(flat, empty$32(), config, false), (chunk$2) => match$10(head$3(chunk$2), {
		onNone: () => fail$8(MissingData(empty$32(), `Expected a single value having structure: ${config}`)),
		onSome: succeed$9
	})),
	flattened: flat
});
/** @internal */
const fromEnv = (options) => {
	const { pathDelim, seqDelim } = Object.assign({}, {
		pathDelim: "_",
		seqDelim: ","
	}, options);
	const makePathString = (path) => pipe(path, join$3(pathDelim));
	const unmakePathString = (pathString) => pathString.split(pathDelim);
	const getEnv = () => typeof process !== "undefined" && "env" in process && typeof process.env === "object" ? process.env : {};
	const load = (path, primitive, split = true) => {
		const pathString = makePathString(path);
		const current = getEnv();
		const valueOpt = pathString in current ? some$4(current[pathString]) : none$7();
		return pipe(valueOpt, mapError$3(() => MissingData(path, `Expected ${pathString} to exist in the process context`)), flatMap$4((value) => parsePrimitive(value, path, primitive, seqDelim, split)));
	};
	const enumerateChildren = (path) => sync$3(() => {
		const current = getEnv();
		const filteredKeyPaths = Object.keys(current).map((value) => unmakePathString(value.toUpperCase())).filter((keyPath) => {
			for (let i = 0; i < path.length; i++) {
				const pathComponent = pipe(path, unsafeGet$5(i));
				const currentElement = keyPath[i];
				if (currentElement === void 0 || pathComponent !== currentElement) return false;
			}
			return true;
		}).flatMap((keyPath) => keyPath.slice(path.length, path.length + 1));
		return fromIterable$6(filteredKeyPaths);
	});
	return fromFlat(makeFlat({
		load,
		enumerateChildren,
		patch: empty$13
	}));
};
const extend$1 = (leftDef, rightDef, left$2, right$2) => {
	const leftPad = unfold$1(left$2.length, (index) => index >= right$2.length ? none$7() : some$4([leftDef(index), index + 1]));
	const rightPad = unfold$1(right$2.length, (index) => index >= left$2.length ? none$7() : some$4([rightDef(index), index + 1]));
	const leftExtension = concat(left$2, leftPad);
	const rightExtension = concat(right$2, rightPad);
	return [leftExtension, rightExtension];
};
const appendConfigPath = (path, config) => {
	let op = config;
	if (op._tag === "Nested") {
		const out = path.slice();
		while (op._tag === "Nested") {
			out.push(op.name);
			op = op.config;
		}
		return out;
	}
	return path;
};
const fromFlatLoop = (flat, prefix, config, split) => {
	const op = config;
	switch (op._tag) {
		case OP_CONSTANT: return succeed$9(of$4(op.value));
		case OP_DESCRIBED: return suspend$3(() => fromFlatLoop(flat, prefix, op.config, split));
		case OP_FAIL: return fail$8(MissingData(prefix, op.message));
		case OP_FALLBACK: return pipe(suspend$3(() => fromFlatLoop(flat, prefix, op.first, split)), catchAll$1((error1) => {
			if (op.condition(error1)) return pipe(fromFlatLoop(flat, prefix, op.second, split), catchAll$1((error2) => fail$8(Or(error1, error2))));
			return fail$8(error1);
		}));
		case OP_LAZY: return suspend$3(() => fromFlatLoop(flat, prefix, op.config(), split));
		case OP_MAP_OR_FAIL: return suspend$3(() => pipe(fromFlatLoop(flat, prefix, op.original, split), flatMap$4(forEachSequential((a) => pipe(op.mapOrFail(a), mapError$3(prefixed(appendConfigPath(prefix, op.original))))))));
		case OP_NESTED: return suspend$3(() => fromFlatLoop(flat, concat(prefix, of$4(op.name)), op.config, split));
		case OP_PRIMITIVE: return pipe(patch$3(prefix, flat.patch), flatMap$4((prefix$1) => pipe(flat.load(prefix$1, op, split), flatMap$4((values$6) => {
			if (values$6.length === 0) {
				const name = pipe(last$2(prefix$1), getOrElse$5(() => "<n/a>"));
				return fail$8(MissingData([], `Expected ${op.description} with name ${name}`));
			}
			return succeed$9(values$6);
		}))));
		case OP_SEQUENCE: return pipe(patch$3(prefix, flat.patch), flatMap$4((patchedPrefix) => pipe(flat.enumerateChildren(patchedPrefix), flatMap$4(indicesFrom), flatMap$4((indices) => {
			if (indices.length === 0) return suspend$3(() => map$8(fromFlatLoop(flat, prefix, op.config, true), of$4));
			return pipe(forEachSequential(indices, (index) => fromFlatLoop(flat, append$2(prefix, `[${index}]`), op.config, true)), map$8((chunkChunk) => {
				const flattened = flatten$6(chunkChunk);
				if (flattened.length === 0) return of$4(empty$32());
				return of$4(flattened);
			}));
		}))));
		case OP_HASHMAP: return suspend$3(() => pipe(patch$3(prefix, flat.patch), flatMap$4((prefix$1) => pipe(flat.enumerateChildren(prefix$1), flatMap$4((keys$5) => {
			return pipe(keys$5, forEachSequential((key) => fromFlatLoop(flat, concat(prefix$1, of$4(key)), op.valueConfig, split)), map$8((matrix) => {
				if (matrix.length === 0) return of$4(empty$24());
				return pipe(transpose(matrix), map$14((values$6) => fromIterable$5(zip$6(fromIterable$10(keys$5), values$6))));
			}));
		})))));
		case OP_ZIP_WITH$1: return suspend$3(() => pipe(fromFlatLoop(flat, prefix, op.left, split), either$1, flatMap$4((left$2) => pipe(fromFlatLoop(flat, prefix, op.right, split), either$1, flatMap$4((right$2) => {
			if (isLeft(left$2) && isLeft(right$2)) return fail$8(And(left$2.left, right$2.left));
			if (isLeft(left$2) && isRight(right$2)) return fail$8(left$2.left);
			if (isRight(left$2) && isLeft(right$2)) return fail$8(right$2.left);
			if (isRight(left$2) && isRight(right$2)) {
				const path = pipe(prefix, join$3("."));
				const fail$10 = fromFlatLoopFail(prefix, path);
				const [lefts, rights] = extend$1(fail$10, fail$10, pipe(left$2.right, map$14(right)), pipe(right$2.right, map$14(right)));
				return pipe(lefts, zip$6(rights), forEachSequential(([left$3, right$3]) => pipe(zip$4(left$3, right$3), map$8(([left$4, right$4]) => op.zip(left$4, right$4)))));
			}
			throw new Error("BUG: ConfigProvider.fromFlatLoop - please report an issue at https://github.com/Effect-TS/effect/issues");
		})))));
	}
};
const fromFlatLoopFail = (prefix, path) => (index) => left(MissingData(prefix, `The element at index ${index} in a sequence at path "${path}" was missing`));
const splitPathString = (text, delim) => {
	return text.split(/* @__PURE__ */ new RegExp(`\\s*${escape(delim)}\\s*`));
};
const parsePrimitive = (text, path, primitive, delimiter, split) => {
	if (!split) return pipe(primitive.parse(text), mapBoth$2({
		onFailure: prefixed(path),
		onSuccess: of$4
	}));
	return pipe(splitPathString(text, delimiter), forEachSequential((char) => primitive.parse(char.trim())), mapError$3(prefixed(path)));
};
const transpose = (array$3) => {
	return Object.keys(array$3[0]).map((column) => array$3.map((row) => row[column]));
};
const indicesFrom = (quotedIndices) => pipe(forEachSequential(quotedIndices, parseQuotedIndex), mapBoth$2({
	onFailure: () => empty$32(),
	onSuccess: sort(Order$3)
}), either$1, map$8(merge$6));
const QUOTED_INDEX_REGEX = /^(\[(\d+)\])$/;
const parseQuotedIndex = (str) => {
	const match$12 = str.match(QUOTED_INDEX_REGEX);
	if (match$12 !== null) {
		const matchedIndex = match$12[2];
		return pipe(matchedIndex !== void 0 && matchedIndex.length > 0 ? some$4(matchedIndex) : none$7(), flatMap$11(parseInteger));
	}
	return none$7();
};
const parseInteger = (str) => {
	const parsedIndex = Number.parseInt(str);
	return Number.isNaN(parsedIndex) ? none$7() : some$4(parsedIndex);
};

//#endregion
//#region ../../node_modules/.bun/effect@3.17.14/node_modules/effect/dist/esm/internal/defaultServices/console.js
/** @internal */
const TypeId$9 = /* @__PURE__ */ Symbol.for("effect/Console");
/** @internal */
const consoleTag = /* @__PURE__ */ GenericTag("effect/Console");
/** @internal */
const defaultConsole = {
	[TypeId$9]: TypeId$9,
	assert(condition, ...args$1) {
		return sync$3(() => {
			console.assert(condition, ...args$1);
		});
	},
	clear: /* @__PURE__ */ sync$3(() => {
		console.clear();
	}),
	count(label) {
		return sync$3(() => {
			console.count(label);
		});
	},
	countReset(label) {
		return sync$3(() => {
			console.countReset(label);
		});
	},
	debug(...args$1) {
		return sync$3(() => {
			console.debug(...args$1);
		});
	},
	dir(item, options) {
		return sync$3(() => {
			console.dir(item, options);
		});
	},
	dirxml(...args$1) {
		return sync$3(() => {
			console.dirxml(...args$1);
		});
	},
	error(...args$1) {
		return sync$3(() => {
			console.error(...args$1);
		});
	},
	group(options) {
		return options?.collapsed ? sync$3(() => console.groupCollapsed(options?.label)) : sync$3(() => console.group(options?.label));
	},
	groupEnd: /* @__PURE__ */ sync$3(() => {
		console.groupEnd();
	}),
	info(...args$1) {
		return sync$3(() => {
			console.info(...args$1);
		});
	},
	log(...args$1) {
		return sync$3(() => {
			console.log(...args$1);
		});
	},
	table(tabularData, properties) {
		return sync$3(() => {
			console.table(tabularData, properties);
		});
	},
	time(label) {
		return sync$3(() => console.time(label));
	},
	timeEnd(label) {
		return sync$3(() => console.timeEnd(label));
	},
	timeLog(label, ...args$1) {
		return sync$3(() => {
			console.timeLog(label, ...args$1);
		});
	},
	trace(...args$1) {
		return sync$3(() => {
			console.trace(...args$1);
		});
	},
	warn(...args$1) {
		return sync$3(() => {
			console.warn(...args$1);
		});
	},
	unsafe: console
};

//#endregion
//#region ../../node_modules/.bun/effect@3.17.14/node_modules/effect/dist/esm/internal/random.js
/** @internal */
const RandomSymbolKey = "effect/Random";
/** @internal */
const RandomTypeId = /* @__PURE__ */ Symbol.for(RandomSymbolKey);
/** @internal */
const randomTag = /* @__PURE__ */ GenericTag("effect/Random");
/** @internal */
var RandomImpl = class {
	seed;
	[RandomTypeId] = RandomTypeId;
	PRNG;
	constructor(seed) {
		this.seed = seed;
		this.PRNG = new PCGRandom(seed);
	}
	get next() {
		return sync$3(() => this.PRNG.number());
	}
	get nextBoolean() {
		return map$8(this.next, (n) => n > .5);
	}
	get nextInt() {
		return sync$3(() => this.PRNG.integer(Number.MAX_SAFE_INTEGER));
	}
	nextRange(min$2, max$4) {
		return map$8(this.next, (n) => (max$4 - min$2) * n + min$2);
	}
	nextIntBetween(min$2, max$4) {
		return sync$3(() => this.PRNG.integer(max$4 - min$2) + min$2);
	}
	shuffle(elements) {
		return shuffleWith(elements, (n) => this.nextIntBetween(0, n));
	}
};
const shuffleWith = (elements, nextIntBounded) => {
	return suspend$3(() => pipe(sync$3(() => Array.from(elements)), flatMap$4((buffer) => {
		const numbers = [];
		for (let i = buffer.length; i >= 2; i = i - 1) numbers.push(i);
		return pipe(numbers, forEachSequentialDiscard((n) => pipe(nextIntBounded(n), map$8((k) => swap$1(buffer, n - 1, k)))), as$3(fromIterable$9(buffer)));
	})));
};
const swap$1 = (buffer, index1, index2) => {
	const tmp = buffer[index1];
	buffer[index1] = buffer[index2];
	buffer[index2] = tmp;
	return buffer;
};
const make$24 = (seed) => new RandomImpl(hash(seed));
/** @internal */
var FixedRandomImpl = class {
	values;
	[RandomTypeId] = RandomTypeId;
	index = 0;
	constructor(values$6) {
		this.values = values$6;
		if (values$6.length === 0) throw new Error("Requires at least one value");
	}
	getNextValue() {
		const value = this.values[this.index];
		this.index = (this.index + 1) % this.values.length;
		return value;
	}
	get next() {
		return sync$3(() => {
			const value = this.getNextValue();
			if (typeof value === "number") return Math.max(0, Math.min(1, value));
			return hash(value) / 2147483647;
		});
	}
	get nextBoolean() {
		return sync$3(() => {
			const value = this.getNextValue();
			if (typeof value === "boolean") return value;
			return hash(value) % 2 === 0;
		});
	}
	get nextInt() {
		return sync$3(() => {
			const value = this.getNextValue();
			if (typeof value === "number" && Number.isFinite(value)) return Math.round(value);
			return Math.abs(hash(value));
		});
	}
	nextRange(min$2, max$4) {
		return map$8(this.next, (n) => (max$4 - min$2) * n + min$2);
	}
	nextIntBetween(min$2, max$4) {
		return sync$3(() => {
			const value = this.getNextValue();
			if (typeof value === "number" && Number.isFinite(value)) return Math.max(min$2, Math.min(max$4 - 1, Math.round(value)));
			const hash$1 = Math.abs(hash(value));
			return min$2 + hash$1 % (max$4 - min$2);
		});
	}
	shuffle(elements) {
		return shuffleWith(elements, (n) => this.nextIntBetween(0, n));
	}
};

//#endregion
//#region ../../node_modules/.bun/effect@3.17.14/node_modules/effect/dist/esm/internal/tracer.js
/** @internal */
const TracerTypeId$1 = /* @__PURE__ */ Symbol.for("effect/Tracer");
/** @internal */
const make$23 = (options) => ({
	[TracerTypeId$1]: TracerTypeId$1,
	...options
});
/** @internal */
const tracerTag = /* @__PURE__ */ GenericTag("effect/Tracer");
/** @internal */
const spanTag = /* @__PURE__ */ GenericTag("effect/ParentSpan");
const randomHexString = /* @__PURE__ */ function() {
	const characters = "abcdef0123456789";
	const charactersLength = 16;
	return function(length$1) {
		let result = "";
		for (let i = 0; i < length$1; i++) result += characters.charAt(Math.floor(Math.random() * charactersLength));
		return result;
	};
}();
/** @internal */
var NativeSpan = class {
	name;
	parent;
	context;
	startTime;
	kind;
	_tag = "Span";
	spanId;
	traceId = "native";
	sampled = true;
	status;
	attributes;
	events = [];
	links;
	constructor(name, parent, context$2, links, startTime, kind) {
		this.name = name;
		this.parent = parent;
		this.context = context$2;
		this.startTime = startTime;
		this.kind = kind;
		this.status = {
			_tag: "Started",
			startTime
		};
		this.attributes = /* @__PURE__ */ new Map();
		this.traceId = parent._tag === "Some" ? parent.value.traceId : randomHexString(32);
		this.spanId = randomHexString(16);
		this.links = Array.from(links);
	}
	end(endTime, exit$3) {
		this.status = {
			_tag: "Ended",
			endTime,
			exit: exit$3,
			startTime: this.status.startTime
		};
	}
	attribute(key, value) {
		this.attributes.set(key, value);
	}
	event(name, startTime, attributes) {
		this.events.push([
			name,
			startTime,
			attributes ?? {}
		]);
	}
	addLinks(links) {
		this.links.push(...links);
	}
};
/** @internal */
const nativeTracer = /* @__PURE__ */ make$23({
	span: (name, parent, context$2, links, startTime, kind) => new NativeSpan(name, parent, context$2, links, startTime, kind),
	context: (f) => f()
});
/** @internal */
const externalSpan$1 = (options) => ({
	_tag: "ExternalSpan",
	spanId: options.spanId,
	traceId: options.traceId,
	sampled: options.sampled ?? true,
	context: options.context ?? empty$25()
});
/** @internal */
const addSpanStackTrace = (options) => {
	if (options?.captureStackTrace === false) return options;
	else if (options?.captureStackTrace !== void 0 && typeof options.captureStackTrace !== "boolean") return options;
	const limit = Error.stackTraceLimit;
	Error.stackTraceLimit = 3;
	const traceError = /* @__PURE__ */ new Error();
	Error.stackTraceLimit = limit;
	let cache = false;
	return {
		...options,
		captureStackTrace: () => {
			if (cache !== false) return cache;
			if (traceError.stack !== void 0) {
				const stack = traceError.stack.split("\n");
				if (stack[3] !== void 0) {
					cache = stack[3].trim();
					return cache;
				}
			}
		}
	};
};
/** @internal */
const DisablePropagation$1 = /* @__PURE__ */ Reference()("effect/Tracer/DisablePropagation", { defaultValue: constFalse });

//#endregion
//#region ../../node_modules/.bun/effect@3.17.14/node_modules/effect/dist/esm/internal/defaultServices.js
/** @internal */
const liveServices = /* @__PURE__ */ pipe(/* @__PURE__ */ empty$25(), /* @__PURE__ */ add$1(clockTag, /* @__PURE__ */ make$26()), /* @__PURE__ */ add$1(consoleTag, defaultConsole), /* @__PURE__ */ add$1(randomTag, /* @__PURE__ */ make$24(/* @__PURE__ */ Math.random())), /* @__PURE__ */ add$1(configProviderTag, /* @__PURE__ */ fromEnv()), /* @__PURE__ */ add$1(tracerTag, nativeTracer));
/**
* The `FiberRef` holding the default `Effect` services.
*
* @since 2.0.0
* @category fiberRefs
*/
const currentServices = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/DefaultServices/currentServices"), () => fiberRefUnsafeMakeContext(liveServices));
/** @internal */
const sleep$3 = (duration) => {
	const decodedDuration = decode$3(duration);
	return clockWith$3((clock$2) => clock$2.sleep(decodedDuration));
};
/** @internal */
const defaultServicesWith = (f) => withFiberRuntime$1((fiber) => f(fiber.currentDefaultServices));
/** @internal */
const clockWith$3 = (f) => defaultServicesWith((services) => f(services.unsafeMap.get(clockTag.key)));
/** @internal */
const currentTimeMillis$1 = /* @__PURE__ */ clockWith$3((clock$2) => clock$2.currentTimeMillis);
/** @internal */
const currentTimeNanos$1 = /* @__PURE__ */ clockWith$3((clock$2) => clock$2.currentTimeNanos);
/** @internal */
const withClock$1 = /* @__PURE__ */ dual(2, (effect, c) => fiberRefLocallyWith(currentServices, add$1(clockTag, c))(effect));
/** @internal */
const withConfigProvider$1 = /* @__PURE__ */ dual(2, (self, provider) => fiberRefLocallyWith(currentServices, add$1(configProviderTag, provider))(self));
/** @internal */
const configProviderWith$1 = (f) => defaultServicesWith((services) => f(services.unsafeMap.get(configProviderTag.key)));
/** @internal */
const randomWith$1 = (f) => defaultServicesWith((services) => f(services.unsafeMap.get(randomTag.key)));
/** @internal */
const withRandom$1 = /* @__PURE__ */ dual(2, (effect, value) => fiberRefLocallyWith(currentServices, add$1(randomTag, value))(effect));
/** @internal */
const tracerWith$3 = (f) => defaultServicesWith((services) => f(services.unsafeMap.get(tracerTag.key)));
/** @internal */
const withTracer$1 = /* @__PURE__ */ dual(2, (effect, value) => fiberRefLocallyWith(currentServices, add$1(tracerTag, value))(effect));

//#endregion
//#region ../../node_modules/.bun/effect@3.17.14/node_modules/effect/dist/esm/Data.js
/**
* @example
* ```ts
* import * as assert from "node:assert"
* import { Data, Equal } from "effect"
*
* const alice = Data.struct({ name: "Alice", age: 30 })
*
* const bob = Data.struct({ name: "Bob", age: 40 })
*
* assert.deepStrictEqual(Equal.equals(alice, alice), true)
* assert.deepStrictEqual(Equal.equals(alice, Data.struct({ name: "Alice", age: 30 })), true)
*
* assert.deepStrictEqual(Equal.equals(alice, { name: "Alice", age: 30 }), false)
* assert.deepStrictEqual(Equal.equals(alice, bob), false)
* ```
*
* @category constructors
* @since 2.0.0
*/
const struct = struct$1;
/**
* Provides a constructor for a Case Class.
*
* @example
* ```ts
* import * as assert from "node:assert"
* import { Data, Equal } from "effect"
*
* class Person extends Data.Class<{ readonly name: string }> {}
*
* // Creating instances of Person
* const mike1 = new Person({ name: "Mike" })
* const mike2 = new Person({ name: "Mike" })
* const john = new Person({ name: "John" })
*
* // Checking equality
* assert.deepStrictEqual(Equal.equals(mike1, mike2), true)
* assert.deepStrictEqual(Equal.equals(mike1, john), false)
* ```
*
* @since 2.0.0
* @category constructors
*/
const Class$3 = Structural$1;
/**
* @since 2.0.0
* @category constructors
*/
const Structural = Structural$1;
/**
* Provides a constructor for a Case Class.
*
* @since 2.0.0
* @category constructors
*/
const Error$2 = /* @__PURE__ */ function() {
	const plainArgsSymbol = /* @__PURE__ */ Symbol.for("effect/Data/Error/plainArgs");
	return { BaseEffectError: class extends YieldableError {
		constructor(args$1) {
			super(args$1?.message, args$1?.cause ? { cause: args$1.cause } : void 0);
			if (args$1) {
				Object.assign(this, args$1);
				Object.defineProperty(this, plainArgsSymbol, {
					value: args$1,
					enumerable: false
				});
			}
		}
		toJSON() {
			return {
				...this[plainArgsSymbol],
				...this
			};
		}
	} }.BaseEffectError;
}();
/**
* @since 2.0.0
* @category constructors
*/
const TaggedError = (tag) => {
	const O = { BaseEffectError: class extends Error$2 {
		_tag = tag;
	} };
	O.BaseEffectError.prototype.name = tag;
	return O.BaseEffectError;
};

//#endregion
//#region ../../node_modules/.bun/effect@3.17.14/node_modules/effect/dist/esm/Effectable.js
/**
* @since 2.0.0
* @category type ids
*/
const EffectTypeId$1 = EffectTypeId$3;
/**
* @since 2.0.0
* @category type ids
*/
const StreamTypeId = StreamTypeId$1;
/**
* @since 2.0.0
* @category type ids
*/
const SinkTypeId = SinkTypeId$1;
/**
* @since 2.0.0
* @category type ids
*/
const ChannelTypeId = ChannelTypeId$1;
/**
* @since 2.0.0
* @category prototypes
*/
const EffectPrototype = EffectPrototype$1;
/**
* @since 2.0.0
* @category prototypes
*/
const CommitPrototype = CommitPrototype$1;
/**
* @since 2.0.0
* @category prototypes
*/
const StructuralCommitPrototype = StructuralCommitPrototype$1;
const Base = Base$1;
const StructuralBase = StructuralBase$1;
/**
* @since 2.0.0
* @category constructors
*/
var Class$2 = class extends Base {};

//#endregion
//#region ../../node_modules/.bun/effect@3.17.14/node_modules/effect/dist/esm/internal/executionStrategy.js
/** @internal */
const OP_SEQUENTIAL = "Sequential";
/** @internal */
const OP_PARALLEL = "Parallel";
/** @internal */
const OP_PARALLEL_N = "ParallelN";
/** @internal */
const sequential$1 = { _tag: OP_SEQUENTIAL };
/** @internal */
const parallel$1 = { _tag: OP_PARALLEL };
/** @internal */
const parallelN$1 = (parallelism) => ({
	_tag: OP_PARALLEL_N,
	parallelism
});
/** @internal */
const isSequential$1 = (self) => self._tag === OP_SEQUENTIAL;
/** @internal */
const isParallel$1 = (self) => self._tag === OP_PARALLEL;
/** @internal */
const isParallelN$1 = (self) => self._tag === OP_PARALLEL_N;
/** @internal */
const match$7 = /* @__PURE__ */ dual(2, (self, options) => {
	switch (self._tag) {
		case OP_SEQUENTIAL: return options.onSequential();
		case OP_PARALLEL: return options.onParallel();
		case OP_PARALLEL_N: return options.onParallelN(self.parallelism);
	}
});

//#endregion
//#region ../../node_modules/.bun/effect@3.17.14/node_modules/effect/dist/esm/ExecutionStrategy.js
/**
* Execute effects sequentially.
*
* @since 2.0.0
* @category constructors
*/
const sequential = sequential$1;
/**
* Execute effects in parallel.
*
* @since 2.0.0
* @category constructors
*/
const parallel = parallel$1;
/**
* Execute effects in parallel, up to the specified number of concurrent fibers.
*
* @since 2.0.0
* @category constructors
*/
const parallelN = parallelN$1;
/**
* Returns `true` if the specified `ExecutionStrategy` is an instance of
* `Sequential`, `false` otherwise.
*
* @since 2.0.0
* @category refinements
*/
const isSequential = isSequential$1;
/**
* Returns `true` if the specified `ExecutionStrategy` is an instance of
* `Sequential`, `false` otherwise.
*
* @since 2.0.0
* @category refinements
*/
const isParallel = isParallel$1;
/**
* Returns `true` if the specified `ExecutionStrategy` is an instance of
* `Sequential`, `false` otherwise.
*
* @since 2.0.0
* @category refinements
*/
const isParallelN = isParallelN$1;
/**
* Folds over the specified `ExecutionStrategy` using the provided case
* functions.
*
* @since 2.0.0
* @category folding
*/
const match$6 = match$7;

//#endregion
//#region ../../node_modules/.bun/effect@3.17.14/node_modules/effect/dist/esm/internal/fiberRefs.js
/** @internal */
function unsafeMake$6(fiberRefLocals) {
	return new FiberRefsImpl(fiberRefLocals);
}
/** @internal */
function empty$12() {
	return unsafeMake$6(/* @__PURE__ */ new Map());
}
/** @internal */
const FiberRefsSym$1 = /* @__PURE__ */ Symbol.for("effect/FiberRefs");
/** @internal */
var FiberRefsImpl = class {
	locals;
	[FiberRefsSym$1] = FiberRefsSym$1;
	constructor(locals) {
		this.locals = locals;
	}
	pipe() {
		return pipeArguments(this, arguments);
	}
};
/** @internal */
const findAncestor = (_ref, _parentStack, _childStack, _childModified = false) => {
	const ref = _ref;
	let parentStack = _parentStack;
	let childStack = _childStack;
	let childModified = _childModified;
	let ret = void 0;
	while (ret === void 0) if (isNonEmptyReadonlyArray(parentStack) && isNonEmptyReadonlyArray(childStack)) {
		const parentFiberId = headNonEmpty$1(parentStack)[0];
		const parentAncestors = tailNonEmpty$1(parentStack);
		const childFiberId = headNonEmpty$1(childStack)[0];
		const childRefValue = headNonEmpty$1(childStack)[1];
		const childAncestors = tailNonEmpty$1(childStack);
		if (parentFiberId.startTimeMillis < childFiberId.startTimeMillis) {
			childStack = childAncestors;
			childModified = true;
		} else if (parentFiberId.startTimeMillis > childFiberId.startTimeMillis) parentStack = parentAncestors;
		else if (parentFiberId.id < childFiberId.id) {
			childStack = childAncestors;
			childModified = true;
		} else if (parentFiberId.id > childFiberId.id) parentStack = parentAncestors;
		else ret = [childRefValue, childModified];
	} else ret = [ref.initial, true];
	return ret;
};
/** @internal */
const joinAs$1 = /* @__PURE__ */ dual(3, (self, fiberId$2, that) => {
	const parentFiberRefs = new Map(self.locals);
	that.locals.forEach((childStack, fiberRef) => {
		const childValue = childStack[0][1];
		if (!childStack[0][0][symbol](fiberId$2)) {
			if (!parentFiberRefs.has(fiberRef)) {
				if (equals(childValue, fiberRef.initial)) return;
				parentFiberRefs.set(fiberRef, [[fiberId$2, fiberRef.join(fiberRef.initial, childValue)]]);
				return;
			}
			const parentStack = parentFiberRefs.get(fiberRef);
			const [ancestor, wasModified] = findAncestor(fiberRef, parentStack, childStack);
			if (wasModified) {
				const patch$11 = fiberRef.diff(ancestor, childValue);
				const oldValue = parentStack[0][1];
				const newValue = fiberRef.join(oldValue, fiberRef.patch(patch$11)(oldValue));
				if (!equals(oldValue, newValue)) {
					let newStack;
					const parentFiberId = parentStack[0][0];
					if (parentFiberId[symbol](fiberId$2)) newStack = [[parentFiberId, newValue], ...parentStack.slice(1)];
					else newStack = [[fiberId$2, newValue], ...parentStack];
					parentFiberRefs.set(fiberRef, newStack);
				}
			}
		}
	});
	return new FiberRefsImpl(parentFiberRefs);
});
/** @internal */
const forkAs$1 = /* @__PURE__ */ dual(2, (self, childId) => {
	const map$17 = /* @__PURE__ */ new Map();
	unsafeForkAs(self, map$17, childId);
	return new FiberRefsImpl(map$17);
});
const unsafeForkAs = (self, map$17, fiberId$2) => {
	self.locals.forEach((stack, fiberRef) => {
		const oldValue = stack[0][1];
		const newValue = fiberRef.patch(fiberRef.fork)(oldValue);
		if (equals(oldValue, newValue)) map$17.set(fiberRef, stack);
		else map$17.set(fiberRef, [[fiberId$2, newValue], ...stack]);
	});
};
/** @internal */
const fiberRefs$2 = (self) => fromIterable$6(self.locals.keys());
/** @internal */
const setAll$1 = (self) => forEachSequentialDiscard(fiberRefs$2(self), (fiberRef) => fiberRefSet(fiberRef, getOrDefault$1(self, fiberRef)));
/** @internal */
const delete_$1 = /* @__PURE__ */ dual(2, (self, fiberRef) => {
	const locals = new Map(self.locals);
	locals.delete(fiberRef);
	return new FiberRefsImpl(locals);
});
/** @internal */
const get$4 = /* @__PURE__ */ dual(2, (self, fiberRef) => {
	if (!self.locals.has(fiberRef)) return none$7();
	return some$4(headNonEmpty$1(self.locals.get(fiberRef))[1]);
});
/** @internal */
const getOrDefault$1 = /* @__PURE__ */ dual(2, (self, fiberRef) => pipe(get$4(self, fiberRef), getOrElse$5(() => fiberRef.initial)));
/** @internal */
const updateAs$1 = /* @__PURE__ */ dual(2, (self, { fiberId: fiberId$2, fiberRef, value }) => {
	if (self.locals.size === 0) return new FiberRefsImpl(new Map([[fiberRef, [[fiberId$2, value]]]]));
	const locals = new Map(self.locals);
	unsafeUpdateAs(locals, fiberId$2, fiberRef, value);
	return new FiberRefsImpl(locals);
});
const unsafeUpdateAs = (locals, fiberId$2, fiberRef, value) => {
	const oldStack = locals.get(fiberRef) ?? [];
	let newStack;
	if (isNonEmptyReadonlyArray(oldStack)) {
		const [currentId, currentValue] = headNonEmpty$1(oldStack);
		if (currentId[symbol](fiberId$2)) if (equals(currentValue, value)) return;
		else newStack = [[fiberId$2, value], ...oldStack.slice(1)];
		else newStack = [[fiberId$2, value], ...oldStack];
	} else newStack = [[fiberId$2, value]];
	locals.set(fiberRef, newStack);
};
/** @internal */
const updateManyAs$1 = /* @__PURE__ */ dual(2, (self, { entries: entries$2, forkAs: forkAs$2 }) => {
	if (self.locals.size === 0) return new FiberRefsImpl(new Map(entries$2));
	const locals = new Map(self.locals);
	if (forkAs$2 !== void 0) unsafeForkAs(self, locals, forkAs$2);
	entries$2.forEach(([fiberRef, values$6]) => {
		if (values$6.length === 1) unsafeUpdateAs(locals, values$6[0][0], fiberRef, values$6[0][1]);
		else values$6.forEach(([fiberId$2, value]) => {
			unsafeUpdateAs(locals, fiberId$2, fiberRef, value);
		});
	});
	return new FiberRefsImpl(locals);
});

//#endregion
//#region ../../node_modules/.bun/effect@3.17.14/node_modules/effect/dist/esm/FiberRefs.js
/**
* @since 2.0.0
* @category symbols
*/
const FiberRefsSym = FiberRefsSym$1;
const delete_ = delete_$1;
/**
* Returns a set of each `FiberRef` in this collection.
*
* @since 2.0.0
* @category getters
*/
const fiberRefs$1 = fiberRefs$2;
/**
* Forks this collection of fiber refs as the specified child fiber id. This
* will potentially modify the value of the fiber refs, as determined by the
* individual fiber refs that make up the collection.
*
* @since 2.0.0
* @category utils
*/
const forkAs = forkAs$1;
/**
* Gets the value of the specified `FiberRef` in this collection of `FiberRef`
* values if it exists or `None` otherwise.
*
* @since 2.0.0
* @category getters
*/
const get$3 = get$4;
/**
* Gets the value of the specified `FiberRef` in this collection of `FiberRef`
* values if it exists or the `initial` value of the `FiberRef` otherwise.
*
* @since 2.0.0
* @category getters
*/
const getOrDefault = getOrDefault$1;
/**
* Joins this collection of fiber refs to the specified collection, as the
* specified fiber id. This will perform diffing and merging to ensure
* preservation of maximum information from both child and parent refs.
*
* @since 2.0.0
* @category utils
*/
const joinAs = joinAs$1;
/**
* Set each ref to either its value or its default.
*
* @since 2.0.0
* @category utils
*/
const setAll = setAll$1;
/**
* Updates the value of the specified `FiberRef` using the provided `FiberId`
*
* @since 2.0.0
* @category utils
*/
const updateAs = updateAs$1;
/**
* Updates the values of the specified `FiberRef` & value pairs using the provided `FiberId`
*
* @since 2.0.0
* @category utils
*/
const updateManyAs = updateManyAs$1;
/**
* Note: it will not copy the provided Map, make sure to provide a fresh one.
*
* @since 2.0.0
* @category unsafe
*/
const unsafeMake$5 = unsafeMake$6;
/**
* The empty collection of `FiberRef` values.
*
* @category constructors
* @since 2.0.0
*/
const empty$11 = empty$12;

//#endregion
//#region ../../node_modules/.bun/effect@3.17.14/node_modules/effect/dist/esm/internal/fiberRefs/patch.js
/** @internal */
const OP_EMPTY$1 = "Empty";
/** @internal */
const OP_ADD = "Add";
/** @internal */
const OP_REMOVE = "Remove";
/** @internal */
const OP_UPDATE = "Update";
/** @internal */
const OP_AND_THEN$1 = "AndThen";
/** @internal */
const empty$10 = { _tag: OP_EMPTY$1 };
/** @internal */
const diff$2 = (oldValue, newValue) => {
	const missingLocals = new Map(oldValue.locals);
	let patch$11 = empty$10;
	for (const [fiberRef, pairs] of newValue.locals.entries()) {
		const newValue$1 = headNonEmpty$1(pairs)[1];
		const old = missingLocals.get(fiberRef);
		if (old !== void 0) {
			const oldValue$1 = headNonEmpty$1(old)[1];
			if (!equals(oldValue$1, newValue$1)) patch$11 = combine$2({
				_tag: OP_UPDATE,
				fiberRef,
				patch: fiberRef.diff(oldValue$1, newValue$1)
			})(patch$11);
		} else patch$11 = combine$2({
			_tag: OP_ADD,
			fiberRef,
			value: newValue$1
		})(patch$11);
		missingLocals.delete(fiberRef);
	}
	for (const [fiberRef] of missingLocals.entries()) patch$11 = combine$2({
		_tag: OP_REMOVE,
		fiberRef
	})(patch$11);
	return patch$11;
};
/** @internal */
const combine$2 = /* @__PURE__ */ dual(2, (self, that) => ({
	_tag: OP_AND_THEN$1,
	first: self,
	second: that
}));
/** @internal */
const patch$2 = /* @__PURE__ */ dual(3, (self, fiberId$2, oldValue) => {
	let fiberRefs$3 = oldValue;
	let patches = of$4(self);
	while (isNonEmptyReadonlyArray(patches)) {
		const head$4 = headNonEmpty$1(patches);
		const tail = tailNonEmpty$1(patches);
		switch (head$4._tag) {
			case OP_EMPTY$1:
				patches = tail;
				break;
			case OP_ADD:
				fiberRefs$3 = updateAs$1(fiberRefs$3, {
					fiberId: fiberId$2,
					fiberRef: head$4.fiberRef,
					value: head$4.value
				});
				patches = tail;
				break;
			case OP_REMOVE:
				fiberRefs$3 = delete_$1(fiberRefs$3, head$4.fiberRef);
				patches = tail;
				break;
			case OP_UPDATE: {
				const value = getOrDefault$1(fiberRefs$3, head$4.fiberRef);
				fiberRefs$3 = updateAs$1(fiberRefs$3, {
					fiberId: fiberId$2,
					fiberRef: head$4.fiberRef,
					value: head$4.fiberRef.patch(head$4.patch)(value)
				});
				patches = tail;
				break;
			}
			case OP_AND_THEN$1:
				patches = prepend$2(head$4.first)(prepend$2(head$4.second)(tail));
				break;
		}
	}
	return fiberRefs$3;
});

//#endregion
//#region ../../node_modules/.bun/effect@3.17.14/node_modules/effect/dist/esm/FiberRefsPatch.js
/**
* @since 2.0.0
* @category constructors
*/
const empty$9 = empty$10;
/**
* Constructs a patch that describes the changes between the specified
* collections of `FiberRef`
*
* @since 2.0.0
* @category constructors
*/
const diff$1 = diff$2;
/**
* Combines this patch and the specified patch to create a new patch that
* describes applying the changes from this patch and the specified patch
* sequentially.
*
* @since 2.0.0
* @category constructors
*/
const combine$1 = combine$2;
/**
* Applies the changes described by this patch to the specified collection
* of `FiberRef` values.
*
* @since 2.0.0
* @category destructors
*/
const patch$1 = patch$2;

//#endregion
//#region ../../node_modules/.bun/effect@3.17.14/node_modules/effect/dist/esm/internal/fiberStatus.js
const FiberStatusSymbolKey = "effect/FiberStatus";
/** @internal */
const FiberStatusTypeId$1 = /* @__PURE__ */ Symbol.for(FiberStatusSymbolKey);
/** @internal */
const OP_DONE$1 = "Done";
/** @internal */
const OP_RUNNING = "Running";
/** @internal */
const OP_SUSPENDED = "Suspended";
const DoneHash = /* @__PURE__ */ string(`${FiberStatusSymbolKey}-${OP_DONE$1}`);
/** @internal */
var Done = class {
	[FiberStatusTypeId$1] = FiberStatusTypeId$1;
	_tag = OP_DONE$1;
	[symbol$1]() {
		return DoneHash;
	}
	[symbol](that) {
		return isFiberStatus$1(that) && that._tag === OP_DONE$1;
	}
};
/** @internal */
var Running = class {
	runtimeFlags;
	[FiberStatusTypeId$1] = FiberStatusTypeId$1;
	_tag = OP_RUNNING;
	constructor(runtimeFlags$1) {
		this.runtimeFlags = runtimeFlags$1;
	}
	[symbol$1]() {
		return pipe(hash(FiberStatusSymbolKey), combine$11(hash(this._tag)), combine$11(hash(this.runtimeFlags)), cached$2(this));
	}
	[symbol](that) {
		return isFiberStatus$1(that) && that._tag === OP_RUNNING && this.runtimeFlags === that.runtimeFlags;
	}
};
/** @internal */
var Suspended = class {
	runtimeFlags;
	blockingOn;
	[FiberStatusTypeId$1] = FiberStatusTypeId$1;
	_tag = OP_SUSPENDED;
	constructor(runtimeFlags$1, blockingOn) {
		this.runtimeFlags = runtimeFlags$1;
		this.blockingOn = blockingOn;
	}
	[symbol$1]() {
		return pipe(hash(FiberStatusSymbolKey), combine$11(hash(this._tag)), combine$11(hash(this.runtimeFlags)), combine$11(hash(this.blockingOn)), cached$2(this));
	}
	[symbol](that) {
		return isFiberStatus$1(that) && that._tag === OP_SUSPENDED && this.runtimeFlags === that.runtimeFlags && equals(this.blockingOn, that.blockingOn);
	}
};
/** @internal */
const done$6 = /* @__PURE__ */ new Done();
/** @internal */
const running$1 = (runtimeFlags$1) => new Running(runtimeFlags$1);
/** @internal */
const suspended$1 = (runtimeFlags$1, blockingOn) => new Suspended(runtimeFlags$1, blockingOn);
/** @internal */
const isFiberStatus$1 = (u) => hasProperty(u, FiberStatusTypeId$1);
/** @internal */
const isDone$4 = (self) => self._tag === OP_DONE$1;
/** @internal */
const isRunning$1 = (self) => self._tag === OP_RUNNING;
/** @internal */
const isSuspended$1 = (self) => self._tag === OP_SUSPENDED;

//#endregion
//#region ../../node_modules/.bun/effect@3.17.14/node_modules/effect/dist/esm/FiberStatus.js
/**
* @since 2.0.0
* @category symbols
*/
const FiberStatusTypeId = FiberStatusTypeId$1;
/**
* @since 2.0.0
* @category constructors
*/
const done$5 = done$6;
/**
* @since 2.0.0
* @category constructors
*/
const running = running$1;
/**
* @since 2.0.0
* @category constructors
*/
const suspended = suspended$1;
/**
* Returns `true` if the specified value is a `FiberStatus`, `false` otherwise.
*
* @since 2.0.0
* @category refinements
*/
const isFiberStatus = isFiberStatus$1;
/**
* Returns `true` if the specified `FiberStatus` is `Done`, `false` otherwise.
*
* @since 2.0.0
* @category refinements
*/
const isDone$3 = isDone$4;
/**
* Returns `true` if the specified `FiberStatus` is `Running`, `false`
* otherwise.
*
* @since 2.0.0
* @category refinements
*/
const isRunning = isRunning$1;
/**
* Returns `true` if the specified `FiberStatus` is `Suspended`, `false`
* otherwise.
*
* @since 2.0.0
* @category refinements
*/
const isSuspended = isSuspended$1;

//#endregion
//#region ../../node_modules/.bun/effect@3.17.14/node_modules/effect/dist/esm/LogLevel.js
/**
* @since 2.0.0
* @category constructors
*/
const All = logLevelAll;
/**
* @since 2.0.0
* @category constructors
*/
const Fatal = logLevelFatal;
/**
* @since 2.0.0
* @category constructors
*/
const Error$1 = logLevelError;
/**
* @since 2.0.0
* @category constructors
*/
const Warning = logLevelWarning;
/**
* @since 2.0.0
* @category constructors
*/
const Info = logLevelInfo;
/**
* @since 2.0.0
* @category constructors
*/
const Debug = logLevelDebug;
/**
* @since 2.0.0
* @category constructors
*/
const Trace = logLevelTrace;
/**
* @since 2.0.0
* @category constructors
*/
const None = logLevelNone;
/**
* @since 2.0.0
* @category constructors
*/
const allLevels = allLogLevels;
/**
* @since 2.0.0
* @category instances
*/
const Order$2 = /* @__PURE__ */ pipe(Order$3, /* @__PURE__ */ mapInput((level) => level.ordinal));
/**
* @since 2.0.0
* @category ordering
*/
const greaterThan$2 = /* @__PURE__ */ greaterThan$3(Order$2);
/**
* @since 2.0.0
* @category conversions
*/
const fromLiteral = (literal) => {
	switch (literal) {
		case "All": return All;
		case "Debug": return Debug;
		case "Error": return Error$1;
		case "Fatal": return Fatal;
		case "Info": return Info;
		case "Trace": return Trace;
		case "None": return None;
		case "Warning": return Warning;
	}
};

//#endregion
//#region ../../node_modules/.bun/effect@3.17.14/node_modules/effect/dist/esm/Micro.js
/**
* @since 3.4.0
* @experimental
* @category type ids
*/
const TypeId$8 = /* @__PURE__ */ Symbol.for("effect/Micro");
/**
* @since 3.4.0
* @experimental
* @category MicroExit
*/
const MicroExitTypeId = /* @__PURE__ */ Symbol.for("effect/Micro/MicroExit");
/**
* @since 3.4.6
* @experimental
* @category MicroCause
*/
const MicroCauseTypeId = /* @__PURE__ */ Symbol.for("effect/Micro/MicroCause");
const microCauseVariance = { _E: identity };
var MicroCauseImpl = class extends globalThis.Error {
	_tag;
	traces;
	[MicroCauseTypeId];
	constructor(_tag, originalError, traces) {
		const causeName = `MicroCause.${_tag}`;
		let name;
		let message;
		let stack;
		if (originalError instanceof globalThis.Error) {
			name = `(${causeName}) ${originalError.name}`;
			message = originalError.message;
			const messageLines = message.split("\n").length;
			stack = originalError.stack ? `(${causeName}) ${originalError.stack.split("\n").slice(0, messageLines + 3).join("\n")}` : `${name}: ${message}`;
		} else {
			name = causeName;
			message = toStringUnknown(originalError, 0);
			stack = `${name}: ${message}`;
		}
		if (traces.length > 0) stack += `\n    ${traces.join("\n    ")}`;
		super(message);
		this._tag = _tag;
		this.traces = traces;
		this[MicroCauseTypeId] = microCauseVariance;
		this.name = name;
		this.stack = stack;
	}
	pipe() {
		return pipeArguments(this, arguments);
	}
	toString() {
		return this.stack;
	}
	[NodeInspectSymbol]() {
		return this.stack;
	}
};
var Die = class extends MicroCauseImpl {
	defect;
	constructor(defect, traces = []) {
		super("Die", defect, traces);
		this.defect = defect;
	}
};
/**
* @since 3.4.6
* @experimental
* @category MicroCause
*/
const causeDie = (defect, traces = []) => new Die(defect, traces);
var Interrupt = class extends MicroCauseImpl {
	constructor(traces = []) {
		super("Interrupt", "interrupted", traces);
	}
};
/**
* @since 3.4.6
* @experimental
* @category MicroCause
*/
const causeInterrupt = (traces = []) => new Interrupt(traces);
/**
* @since 3.4.6
* @experimental
* @category MicroCause
*/
const causeIsInterrupt = (self) => self._tag === "Interrupt";
/**
* @since 3.11.0
* @experimental
* @category MicroFiber
*/
const MicroFiberTypeId = /* @__PURE__ */ Symbol.for("effect/Micro/MicroFiber");
const fiberVariance$1 = {
	_A: identity,
	_E: identity
};
var MicroFiberImpl = class {
	context;
	interruptible;
	[MicroFiberTypeId];
	_stack = [];
	_observers = [];
	_exit;
	_children;
	currentOpCount = 0;
	constructor(context$2, interruptible$4 = true) {
		this.context = context$2;
		this.interruptible = interruptible$4;
		this[MicroFiberTypeId] = fiberVariance$1;
	}
	getRef(ref) {
		return unsafeGetReference(this.context, ref);
	}
	addObserver(cb) {
		if (this._exit) {
			cb(this._exit);
			return constVoid;
		}
		this._observers.push(cb);
		return () => {
			const index = this._observers.indexOf(cb);
			if (index >= 0) this._observers.splice(index, 1);
		};
	}
	_interrupted = false;
	unsafeInterrupt() {
		if (this._exit) return;
		this._interrupted = true;
		if (this.interruptible) this.evaluate(exitInterrupt);
	}
	unsafePoll() {
		return this._exit;
	}
	evaluate(effect) {
		if (this._exit) return;
		else if (this._yielded !== void 0) {
			const yielded = this._yielded;
			this._yielded = void 0;
			yielded();
		}
		const exit$3 = this.runLoop(effect);
		if (exit$3 === Yield) return;
		const interruptChildren = fiberMiddleware.interruptChildren && fiberMiddleware.interruptChildren(this);
		if (interruptChildren !== void 0) return this.evaluate(flatMap$3(interruptChildren, () => exit$3));
		this._exit = exit$3;
		for (let i = 0; i < this._observers.length; i++) this._observers[i](exit$3);
		this._observers.length = 0;
	}
	runLoop(effect) {
		let yielding = false;
		let current = effect;
		this.currentOpCount = 0;
		try {
			while (true) {
				this.currentOpCount++;
				if (!yielding && this.getRef(CurrentScheduler).shouldYield(this)) {
					yielding = true;
					const prev = current;
					current = flatMap$3(yieldNow$2, () => prev);
				}
				current = current[evaluate](this);
				if (current === Yield) {
					const yielded = this._yielded;
					if (MicroExitTypeId in yielded) {
						this._yielded = void 0;
						return yielded;
					}
					return Yield;
				}
			}
		} catch (error) {
			if (!hasProperty(current, evaluate)) return exitDie(`MicroFiber.runLoop: Not a valid effect: ${String(current)}`);
			return exitDie(error);
		}
	}
	getCont(symbol$2) {
		while (true) {
			const op = this._stack.pop();
			if (!op) return void 0;
			const cont = op[ensureCont] && op[ensureCont](this);
			if (cont) return { [symbol$2]: cont };
			if (op[symbol$2]) return op;
		}
	}
	_yielded = void 0;
	yieldWith(value) {
		this._yielded = value;
		return Yield;
	}
	children() {
		return this._children ??= /* @__PURE__ */ new Set();
	}
};
const fiberMiddleware = /* @__PURE__ */ globalValue("effect/Micro/fiberMiddleware", () => ({ interruptChildren: void 0 }));
/**
* @since 3.11.0
* @experimental
* @category MicroFiber
*/
const fiberInterruptAll = (fibers) => suspend$2(() => {
	for (const fiber of fibers) fiber.unsafeInterrupt();
	const iter = fibers[Symbol.iterator]();
	const wait = suspend$2(() => {
		let result = iter.next();
		while (!result.done) {
			if (result.value.unsafePoll()) {
				result = iter.next();
				continue;
			}
			const fiber = result.value;
			return async$1((resume$1) => {
				fiber.addObserver((_) => {
					resume$1(wait);
				});
			});
		}
		return exitVoid;
	});
	return wait;
});
const identifier = /* @__PURE__ */ Symbol.for("effect/Micro/identifier");
const args = /* @__PURE__ */ Symbol.for("effect/Micro/args");
const evaluate = /* @__PURE__ */ Symbol.for("effect/Micro/evaluate");
const successCont = /* @__PURE__ */ Symbol.for("effect/Micro/successCont");
const failureCont = /* @__PURE__ */ Symbol.for("effect/Micro/failureCont");
const ensureCont = /* @__PURE__ */ Symbol.for("effect/Micro/ensureCont");
const Yield = /* @__PURE__ */ Symbol.for("effect/Micro/Yield");
const microVariance = {
	_A: identity,
	_E: identity,
	_R: identity
};
const MicroProto = {
	...EffectPrototype,
	_op: "Micro",
	[TypeId$8]: microVariance,
	pipe() {
		return pipeArguments(this, arguments);
	},
	[Symbol.iterator]() {
		return new SingleShotGen(new YieldWrap(this));
	},
	toJSON() {
		return {
			_id: "Micro",
			op: this[identifier],
			...args in this ? { args: this[args] } : void 0
		};
	},
	toString() {
		return format(this);
	},
	[NodeInspectSymbol]() {
		return format(this);
	}
};
function defaultEvaluate(_fiber) {
	return exitDie(`Micro.evaluate: Not implemented`);
}
const makePrimitiveProto = (options) => ({
	...MicroProto,
	[identifier]: options.op,
	[evaluate]: options.eval ?? defaultEvaluate,
	[successCont]: options.contA,
	[failureCont]: options.contE,
	[ensureCont]: options.ensure
});
const makePrimitive = (options) => {
	const Proto$1 = makePrimitiveProto(options);
	return function() {
		const self = Object.create(Proto$1);
		self[args] = options.single === false ? arguments : arguments[0];
		return self;
	};
};
const makeExit = (options) => {
	const Proto$1 = {
		...makePrimitiveProto(options),
		[MicroExitTypeId]: MicroExitTypeId,
		_tag: options.op,
		get [options.prop]() {
			return this[args];
		},
		toJSON() {
			return {
				_id: "MicroExit",
				_tag: options.op,
				[options.prop]: this[args]
			};
		},
		[symbol](that) {
			return isMicroExit(that) && that._tag === options.op && equals(this[args], that[args]);
		},
		[symbol$1]() {
			return cached$2(this, combine$11(string(options.op))(hash(this[args])));
		}
	};
	return function(value) {
		const self = Object.create(Proto$1);
		self[args] = value;
		self[successCont] = void 0;
		self[failureCont] = void 0;
		self[ensureCont] = void 0;
		return self;
	};
};
/**
* Creates a `Micro` effect that will succeed with the specified constant value.
*
* @since 3.4.0
* @experimental
* @category constructors
*/
const succeed$8 = /* @__PURE__ */ makeExit({
	op: "Success",
	prop: "value",
	eval(fiber) {
		const cont = fiber.getCont(successCont);
		return cont ? cont[successCont](this[args], fiber) : fiber.yieldWith(this);
	}
});
/**
* Creates a `Micro` effect that will fail with the specified `MicroCause`.
*
* @since 3.4.6
* @experimental
* @category constructors
*/
const failCause$7 = /* @__PURE__ */ makeExit({
	op: "Failure",
	prop: "cause",
	eval(fiber) {
		let cont = fiber.getCont(failureCont);
		while (causeIsInterrupt(this[args]) && cont && fiber.interruptible) cont = fiber.getCont(failureCont);
		return cont ? cont[failureCont](this[args], fiber) : fiber.yieldWith(this);
	}
});
/**
* Creates a `Micro` effect that succeeds with a lazily evaluated value.
*
* If the evaluation of the value throws an error, the effect will fail with a
* `Die` variant of the `MicroCause` type.
*
* @since 3.4.0
* @experimental
* @category constructors
*/
const sync$2 = /* @__PURE__ */ makePrimitive({
	op: "Sync",
	eval(fiber) {
		const value = this[args]();
		const cont = fiber.getCont(successCont);
		return cont ? cont[successCont](value, fiber) : fiber.yieldWith(exitSucceed(value));
	}
});
/**
* Lazily creates a `Micro` effect from the given side-effect.
*
* @since 3.4.0
* @experimental
* @category constructors
*/
const suspend$2 = /* @__PURE__ */ makePrimitive({
	op: "Suspend",
	eval(_fiber) {
		return this[args]();
	}
});
/**
* Pause the execution of the current `Micro` effect, and resume it on the next
* scheduler tick.
*
* @since 3.4.0
* @experimental
* @category constructors
*/
const yieldNowWith = /* @__PURE__ */ makePrimitive({
	op: "Yield",
	eval(fiber) {
		let resumed = false;
		fiber.getRef(CurrentScheduler).scheduleTask(() => {
			if (resumed) return;
			fiber.evaluate(exitVoid);
		}, this[args] ?? 0);
		return fiber.yieldWith(() => {
			resumed = true;
		});
	}
});
/**
* Pause the execution of the current `Micro` effect, and resume it on the next
* scheduler tick.
*
* @since 3.4.0
* @experimental
* @category constructors
*/
const yieldNow$2 = /* @__PURE__ */ yieldNowWith(0);
const void_$3 = /* @__PURE__ */ succeed$8(void 0);
/**
* Create a `Micro` effect using the current `MicroFiber`.
*
* @since 3.4.0
* @experimental
* @category constructors
*/
const withMicroFiber = /* @__PURE__ */ makePrimitive({
	op: "WithMicroFiber",
	eval(fiber) {
		return this[args](fiber);
	}
});
const asyncOptions = /* @__PURE__ */ makePrimitive({
	op: "Async",
	single: false,
	eval(fiber) {
		const register = this[args][0];
		let resumed = false;
		let yielded = false;
		const controller = this[args][1] ? new AbortController() : void 0;
		const onCancel = register((effect) => {
			if (resumed) return;
			resumed = true;
			if (yielded) fiber.evaluate(effect);
			else yielded = effect;
		}, controller?.signal);
		if (yielded !== false) return yielded;
		yielded = true;
		fiber._yielded = () => {
			resumed = true;
		};
		if (controller === void 0 && onCancel === void 0) return Yield;
		fiber._stack.push(asyncFinalizer(() => {
			resumed = true;
			controller?.abort();
			return onCancel ?? exitVoid;
		}));
		return Yield;
	}
});
const asyncFinalizer = /* @__PURE__ */ makePrimitive({
	op: "AsyncFinalizer",
	ensure(fiber) {
		if (fiber.interruptible) {
			fiber.interruptible = false;
			fiber._stack.push(setInterruptible(true));
		}
	},
	contE(cause$2, _fiber) {
		return causeIsInterrupt(cause$2) ? flatMap$3(this[args](), () => failCause$7(cause$2)) : failCause$7(cause$2);
	}
});
/**
* Create a `Micro` effect from an asynchronous computation.
*
* You can return a cleanup effect that will be run when the effect is aborted.
* It is also passed an `AbortSignal` that is triggered when the effect is
* aborted.
*
* @since 3.4.0
* @experimental
* @category constructors
*/
const async$1 = (register) => asyncOptions(register, register.length >= 2);
/**
* Create a `Micro` effect that will replace the success value of the given
* effect.
*
* @since 3.4.0
* @experimental
* @category mapping & sequencing
*/
const as$2 = /* @__PURE__ */ dual(2, (self, value) => map$7(self, (_) => value));
/**
* Access the `MicroExit` of the given `Micro` effect.
*
* @since 3.4.6
* @experimental
* @category mapping & sequencing
*/
const exit$1 = (self) => matchCause$1(self, {
	onFailure: exitFailCause,
	onSuccess: exitSucceed
});
/**
* Map the success value of this `Micro` effect to another `Micro` effect, then
* flatten the result.
*
* @since 3.4.0
* @experimental
* @category mapping & sequencing
*/
const flatMap$3 = /* @__PURE__ */ dual(2, (self, f) => {
	const onSuccess = Object.create(OnSuccessProto);
	onSuccess[args] = self;
	onSuccess[successCont] = f;
	return onSuccess;
});
const OnSuccessProto = /* @__PURE__ */ makePrimitiveProto({
	op: "OnSuccess",
	eval(fiber) {
		fiber._stack.push(this);
		return this[args];
	}
});
/**
* Transforms the success value of the `Micro` effect with the specified
* function.
*
* @since 3.4.0
* @experimental
* @category mapping & sequencing
*/
const map$7 = /* @__PURE__ */ dual(2, (self, f) => flatMap$3(self, (a) => succeed$8(f(a))));
/**
* @since 3.4.6
* @experimental
* @category MicroExit
*/
const isMicroExit = (u) => hasProperty(u, MicroExitTypeId);
/**
* @since 3.4.6
* @experimental
* @category MicroExit
*/
const exitSucceed = succeed$8;
/**
* @since 3.4.6
* @experimental
* @category MicroExit
*/
const exitFailCause = failCause$7;
/**
* @since 3.4.6
* @experimental
* @category MicroExit
*/
const exitInterrupt = /* @__PURE__ */ exitFailCause(/* @__PURE__ */ causeInterrupt());
/**
* @since 3.4.6
* @experimental
* @category MicroExit
*/
const exitDie = (defect) => exitFailCause(causeDie(defect));
/**
* @since 3.4.6
* @experimental
* @category MicroExit
*/
const exitVoid = /* @__PURE__ */ exitSucceed(void 0);
/**
* @since 3.11.0
* @experimental
* @category MicroExit
*/
const exitVoidAll = (exits) => {
	for (const exit$3 of exits) if (exit$3._tag === "Failure") return exit$3;
	return exitVoid;
};
const setImmediate = "setImmediate" in globalThis ? globalThis.setImmediate : (f) => setTimeout(f, 0);
/**
* @since 3.5.9
* @experimental
* @category scheduler
*/
var MicroSchedulerDefault = class {
	tasks = [];
	running = false;
	/**
	* @since 3.5.9
	*/
	scheduleTask(task, _priority) {
		this.tasks.push(task);
		if (!this.running) {
			this.running = true;
			setImmediate(this.afterScheduled);
		}
	}
	/**
	* @since 3.5.9
	*/
	afterScheduled = () => {
		this.running = false;
		this.runTasks();
	};
	/**
	* @since 3.5.9
	*/
	runTasks() {
		const tasks = this.tasks;
		this.tasks = [];
		for (let i = 0, len = tasks.length; i < len; i++) tasks[i]();
	}
	/**
	* @since 3.5.9
	*/
	shouldYield(fiber) {
		return fiber.currentOpCount >= fiber.getRef(MaxOpsBeforeYield);
	}
	/**
	* @since 3.5.9
	*/
	flush() {
		while (this.tasks.length > 0) this.runTasks();
	}
};
/**
* Update the Context with the given mapping function.
*
* @since 3.11.0
* @experimental
* @category environment
*/
const updateContext = /* @__PURE__ */ dual(2, (self, f) => withMicroFiber((fiber) => {
	const prev = fiber.context;
	fiber.context = f(prev);
	return onExit$1(self, () => {
		fiber.context = prev;
		return void_$3;
	});
}));
/**
* Merge the given `Context` with the current context.
*
* @since 3.4.0
* @experimental
* @category environment
*/
const provideContext = /* @__PURE__ */ dual(2, (self, provided) => updateContext(self, merge$4(provided)));
/**
* @since 3.11.0
* @experimental
* @category references
*/
var MaxOpsBeforeYield = class extends Reference()("effect/Micro/currentMaxOpsBeforeYield", { defaultValue: () => 2048 }) {};
/**
* @since 3.11.0
* @experimental
* @category environment refs
*/
var CurrentConcurrency = class extends Reference()("effect/Micro/currentConcurrency", { defaultValue: () => "unbounded" }) {};
/**
* @since 3.11.0
* @experimental
* @category environment refs
*/
var CurrentScheduler = class extends Reference()("effect/Micro/currentScheduler", { defaultValue: () => new MicroSchedulerDefault() }) {};
/**
* @since 3.4.6
* @experimental
* @category pattern matching
*/
const matchCauseEffect$1 = /* @__PURE__ */ dual(2, (self, options) => {
	const primitive = Object.create(OnSuccessAndFailureProto);
	primitive[args] = self;
	primitive[successCont] = options.onSuccess;
	primitive[failureCont] = options.onFailure;
	return primitive;
});
const OnSuccessAndFailureProto = /* @__PURE__ */ makePrimitiveProto({
	op: "OnSuccessAndFailure",
	eval(fiber) {
		fiber._stack.push(this);
		return this[args];
	}
});
/**
* @since 3.4.6
* @experimental
* @category pattern matching
*/
const matchCause$1 = /* @__PURE__ */ dual(2, (self, options) => matchCauseEffect$1(self, {
	onFailure: (cause$2) => sync$2(() => options.onFailure(cause$2)),
	onSuccess: (value) => sync$2(() => options.onSuccess(value))
}));
/**
* @since 3.4.0
* @experimental
* @category resources & finalization
*/
const MicroScopeTypeId = /* @__PURE__ */ Symbol.for("effect/Micro/MicroScope");
var MicroScopeImpl = class MicroScopeImpl {
	[MicroScopeTypeId];
	state = {
		_tag: "Open",
		finalizers: /* @__PURE__ */ new Set()
	};
	constructor() {
		this[MicroScopeTypeId] = MicroScopeTypeId;
	}
	unsafeAddFinalizer(finalizer) {
		if (this.state._tag === "Open") this.state.finalizers.add(finalizer);
	}
	addFinalizer(finalizer) {
		return suspend$2(() => {
			if (this.state._tag === "Open") {
				this.state.finalizers.add(finalizer);
				return void_$3;
			}
			return finalizer(this.state.exit);
		});
	}
	unsafeRemoveFinalizer(finalizer) {
		if (this.state._tag === "Open") this.state.finalizers.delete(finalizer);
	}
	close(microExit) {
		return suspend$2(() => {
			if (this.state._tag === "Open") {
				const finalizers = Array.from(this.state.finalizers).reverse();
				this.state = {
					_tag: "Closed",
					exit: microExit
				};
				return flatMap$3(forEach$4(finalizers, (finalizer) => exit$1(finalizer(microExit))), exitVoidAll);
			}
			return void_$3;
		});
	}
	get fork() {
		return sync$2(() => {
			const newScope = new MicroScopeImpl();
			if (this.state._tag === "Closed") {
				newScope.state = this.state;
				return newScope;
			}
			function fin(exit$3) {
				return newScope.close(exit$3);
			}
			this.state.finalizers.add(fin);
			newScope.unsafeAddFinalizer((_) => sync$2(() => this.unsafeRemoveFinalizer(fin)));
			return newScope;
		});
	}
};
/**
* When the `Micro` effect is completed, run the given finalizer effect with the
* `MicroExit` of the executed effect.
*
* @since 3.4.6
* @experimental
* @category resources & finalization
*/
const onExit$1 = /* @__PURE__ */ dual(2, (self, f) => uninterruptibleMask$1((restore) => matchCauseEffect$1(restore(self), {
	onFailure: (cause$2) => flatMap$3(f(exitFailCause(cause$2)), () => failCause$7(cause$2)),
	onSuccess: (a) => flatMap$3(f(exitSucceed(a)), () => succeed$8(a))
})));
const setInterruptible = /* @__PURE__ */ makePrimitive({
	op: "SetInterruptible",
	ensure(fiber) {
		fiber.interruptible = this[args];
		if (fiber._interrupted && fiber.interruptible) return () => exitInterrupt;
	}
});
/**
* Flag the effect as interruptible, which means that when the effect is
* interrupted, it will be interrupted immediately.
*
* @since 3.4.0
* @experimental
* @category flags
*/
const interruptible$1 = (self) => withMicroFiber((fiber) => {
	if (fiber.interruptible) return self;
	fiber.interruptible = true;
	fiber._stack.push(setInterruptible(false));
	if (fiber._interrupted) return exitInterrupt;
	return self;
});
/**
* Wrap the given `Micro` effect in an uninterruptible region, preventing the
* effect from being aborted.
*
* You can use the `restore` function to restore a `Micro` effect to the
* interruptibility state before the `uninterruptibleMask` was applied.
*
* @example
* ```ts
* import * as Micro from "effect/Micro"
*
* Micro.uninterruptibleMask((restore) =>
*   Micro.sleep(1000).pipe( // uninterruptible
*     Micro.andThen(restore(Micro.sleep(1000))) // interruptible
*   )
* )
* ```
*
* @since 3.4.0
* @experimental
* @category interruption
*/
const uninterruptibleMask$1 = (f) => withMicroFiber((fiber) => {
	if (!fiber.interruptible) return f(identity);
	fiber.interruptible = false;
	fiber._stack.push(setInterruptible(true));
	return f(interruptible$1);
});
/**
* @since 3.11.0
* @experimental
* @category collecting & elements
*/
const whileLoop$1 = /* @__PURE__ */ makePrimitive({
	op: "While",
	contA(value, fiber) {
		this[args].step(value);
		if (this[args].while()) {
			fiber._stack.push(this);
			return this[args].body();
		}
		return exitVoid;
	},
	eval(fiber) {
		if (this[args].while()) {
			fiber._stack.push(this);
			return this[args].body();
		}
		return exitVoid;
	}
});
/**
* For each element of the provided iterable, run the effect and collect the
* results.
*
* If the `discard` option is set to `true`, the results will be discarded and
* the effect will return `void`.
*
* The `concurrency` option can be set to control how many effects are run
* concurrently. By default, the effects are run sequentially.
*
* @since 3.4.0
* @experimental
* @category collecting & elements
*/
const forEach$4 = (iterable, f, options) => withMicroFiber((parent) => {
	const concurrencyOption = options?.concurrency === "inherit" ? parent.getRef(CurrentConcurrency) : options?.concurrency ?? 1;
	const concurrency = concurrencyOption === "unbounded" ? Number.POSITIVE_INFINITY : Math.max(1, concurrencyOption);
	const items = fromIterable$10(iterable);
	let length$1 = items.length;
	if (length$1 === 0) return options?.discard ? void_$3 : succeed$8([]);
	const out = options?.discard ? void 0 : new Array(length$1);
	let index = 0;
	if (concurrency === 1) return as$2(whileLoop$1({
		while: () => index < items.length,
		body: () => f(items[index], index),
		step: out ? (b) => out[index++] = b : (_) => index++
	}), out);
	return async$1((resume$1) => {
		const fibers = /* @__PURE__ */ new Set();
		let result = void 0;
		let inProgress = 0;
		let doneCount = 0;
		let pumping = false;
		let interrupted$2 = false;
		function pump() {
			pumping = true;
			while (inProgress < concurrency && index < length$1) {
				const currentIndex = index;
				const item = items[currentIndex];
				index++;
				inProgress++;
				try {
					const child = unsafeFork$2(parent, f(item, currentIndex), true, true);
					fibers.add(child);
					child.addObserver((exit$3) => {
						fibers.delete(child);
						if (interrupted$2) return;
						else if (exit$3._tag === "Failure") {
							if (result === void 0) {
								result = exit$3;
								length$1 = index;
								fibers.forEach((fiber) => fiber.unsafeInterrupt());
							}
						} else if (out !== void 0) out[currentIndex] = exit$3.value;
						doneCount++;
						inProgress--;
						if (doneCount === length$1) resume$1(result ?? succeed$8(out));
						else if (!pumping && inProgress < concurrency) pump();
					});
				} catch (err) {
					result = exitDie(err);
					length$1 = index;
					fibers.forEach((fiber) => fiber.unsafeInterrupt());
				}
			}
			pumping = false;
		}
		pump();
		return suspend$2(() => {
			interrupted$2 = true;
			index = length$1;
			return fiberInterruptAll(fibers);
		});
	});
});
const unsafeFork$2 = (parent, effect, immediate = false, daemon = false) => {
	const child = new MicroFiberImpl(parent.context, parent.interruptible);
	if (!daemon) {
		parent.children().add(child);
		child.addObserver(() => parent.children().delete(child));
	}
	if (immediate) child.evaluate(effect);
	else parent.getRef(CurrentScheduler).scheduleTask(() => child.evaluate(effect), 0);
	return child;
};
/**
* Execute the `Micro` effect and return a `MicroFiber` that can be awaited, joined,
* or aborted.
*
* You can listen for the result by adding an observer using the handle's
* `addObserver` method.
*
* @example
* ```ts
* import * as Micro from "effect/Micro"
*
* const handle = Micro.succeed(42).pipe(
*   Micro.delay(1000),
*   Micro.runFork
* )
*
* handle.addObserver((exit) => {
*   console.log(exit)
* })
* ```
*
* @since 3.4.0
* @experimental
* @category execution
*/
const runFork$1 = (effect, options) => {
	const fiber = new MicroFiberImpl(CurrentScheduler.context(options?.scheduler ?? new MicroSchedulerDefault()));
	fiber.evaluate(effect);
	if (options?.signal) if (options.signal.aborted) fiber.unsafeInterrupt();
	else {
		const abort = () => fiber.unsafeInterrupt();
		options.signal.addEventListener("abort", abort, { once: true });
		fiber.addObserver(() => options.signal.removeEventListener("abort", abort));
	}
	return fiber;
};

//#endregion
//#region ../../node_modules/.bun/effect@3.17.14/node_modules/effect/dist/esm/Readable.js
/**
* @since 2.0.0
* @category type ids
*/
const TypeId$7 = /* @__PURE__ */ Symbol.for("effect/Readable");
const Proto = {
	[TypeId$7]: TypeId$7,
	pipe() {
		return pipeArguments(this, arguments);
	}
};

//#endregion
//#region ../../node_modules/.bun/effect@3.17.14/node_modules/effect/dist/esm/internal/ref.js
/** @internal */
const RefTypeId$1 = /* @__PURE__ */ Symbol.for("effect/Ref");
/** @internal */
const refVariance = { _A: (_) => _ };
var RefImpl = class extends Class$2 {
	ref;
	commit() {
		return this.get;
	}
	[RefTypeId$1] = refVariance;
	[TypeId$7] = TypeId$7;
	constructor(ref) {
		super();
		this.ref = ref;
		this.get = sync$3(() => get$6(this.ref));
	}
	get;
	modify(f) {
		return sync$3(() => {
			const current = get$6(this.ref);
			const [b, a] = f(current);
			if (current !== a) set$4(a)(this.ref);
			return b;
		});
	}
};
/** @internal */
const unsafeMake$4 = (value) => new RefImpl(make$34(value));
/** @internal */
const make$22 = (value) => sync$3(() => unsafeMake$4(value));
/** @internal */
const get$2 = (self) => self.get;
/** @internal */
const set$2 = /* @__PURE__ */ dual(2, (self, value) => self.modify(() => [void 0, value]));
/** @internal */
const getAndSet$1 = /* @__PURE__ */ dual(2, (self, value) => self.modify((a) => [a, value]));
/** @internal */
const getAndUpdate$1 = /* @__PURE__ */ dual(2, (self, f) => self.modify((a) => [a, f(a)]));
/** @internal */
const getAndUpdateSome$1 = /* @__PURE__ */ dual(2, (self, pf) => self.modify((value) => {
	const option$2 = pf(value);
	switch (option$2._tag) {
		case "None": return [value, value];
		case "Some": return [value, option$2.value];
	}
}));
/** @internal */
const setAndGet$1 = /* @__PURE__ */ dual(2, (self, value) => self.modify(() => [value, value]));
/** @internal */
const modify$1 = /* @__PURE__ */ dual(2, (self, f) => self.modify(f));
/** @internal */
const modifySome$1 = /* @__PURE__ */ dual(3, (self, fallback, pf) => self.modify((value) => {
	const option$2 = pf(value);
	switch (option$2._tag) {
		case "None": return [fallback, value];
		case "Some": return option$2.value;
	}
}));
/** @internal */
const update$3 = /* @__PURE__ */ dual(2, (self, f) => self.modify((a) => [void 0, f(a)]));
/** @internal */
const updateAndGet$1 = /* @__PURE__ */ dual(2, (self, f) => self.modify((a) => {
	const result = f(a);
	return [result, result];
}));
/** @internal */
const updateSome$1 = /* @__PURE__ */ dual(2, (self, f) => self.modify((a) => [void 0, match$10(f(a), {
	onNone: () => a,
	onSome: (b) => b
})]));
/** @internal */
const updateSomeAndGet$1 = /* @__PURE__ */ dual(2, (self, pf) => self.modify((value) => {
	const option$2 = pf(value);
	switch (option$2._tag) {
		case "None": return [value, value];
		case "Some": return [option$2.value, option$2.value];
	}
}));

//#endregion
//#region ../../node_modules/.bun/effect@3.17.14/node_modules/effect/dist/esm/Ref.js
/**
* @since 2.0.0
* @category symbols
*/
const RefTypeId = RefTypeId$1;
/**
* @since 2.0.0
* @category constructors
*/
const make$21 = make$22;
/**
* @since 2.0.0
* @category getters
*/
const get$1 = get$2;
/**
* @since 2.0.0
* @category utils
*/
const getAndSet = getAndSet$1;
/**
* @since 2.0.0
* @category utils
*/
const getAndUpdate = getAndUpdate$1;
/**
* @since 2.0.0
* @category utils
*/
const getAndUpdateSome = getAndUpdateSome$1;
/**
* @since 2.0.0
* @category utils
*/
const modify = modify$1;
/**
* @since 2.0.0
* @category utils
*/
const modifySome = modifySome$1;
/**
* @since 2.0.0
* @category utils
*/
const set$1 = set$2;
/**
* @since 2.0.0
* @category utils
*/
const setAndGet = setAndGet$1;
/**
* @since 2.0.0
* @category utils
*/
const update$2 = update$3;
/**
* @since 2.0.0
* @category utils
*/
const updateAndGet = updateAndGet$1;
/**
* @since 2.0.0
* @category utils
*/
const updateSome = updateSome$1;
/**
* @since 2.0.0
* @category utils
*/
const updateSomeAndGet = updateSomeAndGet$1;
/**
* @since 2.0.0
* @category unsafe
*/
const unsafeMake$3 = unsafeMake$4;

//#endregion
//#region ../../node_modules/.bun/effect@3.17.14/node_modules/effect/dist/esm/Scheduler.js
/**
* @since 2.0.0
* @category utils
*/
var PriorityBuckets = class {
	/**
	* @since 2.0.0
	*/
	buckets = [];
	/**
	* @since 2.0.0
	*/
	scheduleTask(task, priority) {
		const length$1 = this.buckets.length;
		let bucket = void 0;
		let index = 0;
		for (; index < length$1; index++) if (this.buckets[index][0] <= priority) bucket = this.buckets[index];
		else break;
		if (bucket && bucket[0] === priority) bucket[1].push(task);
		else if (index === length$1) this.buckets.push([priority, [task]]);
		else this.buckets.splice(index, 0, [priority, [task]]);
	}
};
/**
* @since 2.0.0
* @category constructors
*/
var MixedScheduler = class {
	maxNextTickBeforeTimer;
	/**
	* @since 2.0.0
	*/
	running = false;
	/**
	* @since 2.0.0
	*/
	tasks = /* @__PURE__ */ new PriorityBuckets();
	constructor(maxNextTickBeforeTimer) {
		this.maxNextTickBeforeTimer = maxNextTickBeforeTimer;
	}
	/**
	* @since 2.0.0
	*/
	starveInternal(depth) {
		const tasks = this.tasks.buckets;
		this.tasks.buckets = [];
		for (const [_, toRun] of tasks) for (let i = 0; i < toRun.length; i++) toRun[i]();
		if (this.tasks.buckets.length === 0) this.running = false;
		else this.starve(depth);
	}
	/**
	* @since 2.0.0
	*/
	starve(depth = 0) {
		if (depth >= this.maxNextTickBeforeTimer) setTimeout(() => this.starveInternal(0), 0);
		else Promise.resolve(void 0).then(() => this.starveInternal(depth + 1));
	}
	/**
	* @since 2.0.0
	*/
	shouldYield(fiber) {
		return fiber.currentOpCount > fiber.getFiberRef(currentMaxOpsBeforeYield) ? fiber.getFiberRef(currentSchedulingPriority) : false;
	}
	/**
	* @since 2.0.0
	*/
	scheduleTask(task, priority) {
		this.tasks.scheduleTask(task, priority);
		if (!this.running) {
			this.running = true;
			this.starve();
		}
	}
};
/**
* @since 2.0.0
* @category schedulers
*/
const defaultScheduler = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/Scheduler/defaultScheduler"), () => new MixedScheduler(2048));
/**
* @since 2.0.0
* @category constructors
*/
var SyncScheduler = class {
	/**
	* @since 2.0.0
	*/
	tasks = /* @__PURE__ */ new PriorityBuckets();
	/**
	* @since 2.0.0
	*/
	deferred = false;
	/**
	* @since 2.0.0
	*/
	scheduleTask(task, priority) {
		if (this.deferred) defaultScheduler.scheduleTask(task, priority);
		else this.tasks.scheduleTask(task, priority);
	}
	/**
	* @since 2.0.0
	*/
	shouldYield(fiber) {
		return fiber.currentOpCount > fiber.getFiberRef(currentMaxOpsBeforeYield) ? fiber.getFiberRef(currentSchedulingPriority) : false;
	}
	/**
	* @since 2.0.0
	*/
	flush() {
		while (this.tasks.buckets.length > 0) {
			const tasks = this.tasks.buckets;
			this.tasks.buckets = [];
			for (const [_, toRun] of tasks) for (let i = 0; i < toRun.length; i++) toRun[i]();
		}
		this.deferred = true;
	}
};
/** @internal */
const currentScheduler = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentScheduler"), () => fiberRefUnsafeMake(defaultScheduler));
/** @internal */
const withScheduler$1 = /* @__PURE__ */ dual(2, (self, scheduler) => fiberRefLocally(self, currentScheduler, scheduler));

//#endregion
//#region ../../node_modules/.bun/effect@3.17.14/node_modules/effect/dist/esm/internal/completedRequestMap.js
/** @internal */
const currentRequestMap = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentRequestMap"), () => fiberRefUnsafeMake(/* @__PURE__ */ new Map()));

//#endregion
//#region ../../node_modules/.bun/effect@3.17.14/node_modules/effect/dist/esm/internal/concurrency.js
/** @internal */
const match$5 = (concurrency, sequential$3, unbounded$1, bounded) => {
	switch (concurrency) {
		case void 0: return sequential$3();
		case "unbounded": return unbounded$1();
		case "inherit": return fiberRefGetWith(currentConcurrency, (concurrency$1) => concurrency$1 === "unbounded" ? unbounded$1() : concurrency$1 > 1 ? bounded(concurrency$1) : sequential$3());
		default: return concurrency > 1 ? bounded(concurrency) : sequential$3();
	}
};
/** @internal */
const matchSimple = (concurrency, sequential$3, concurrent) => {
	switch (concurrency) {
		case void 0: return sequential$3();
		case "unbounded": return concurrent();
		case "inherit": return fiberRefGetWith(currentConcurrency, (concurrency$1) => concurrency$1 === "unbounded" || concurrency$1 > 1 ? concurrent() : sequential$3());
		default: return concurrency > 1 ? concurrent() : sequential$3();
	}
};

//#endregion
//#region ../../node_modules/.bun/effect@3.17.14/node_modules/effect/dist/esm/Clock.js
/**
* @since 2.0.0
* @category symbols
*/
const ClockTypeId = ClockTypeId$1;
/**
* @since 2.0.0
* @category constructors
*/
const make$20 = make$26;
/**
* @since 2.0.0
* @category constructors
*/
const sleep$2 = sleep$3;
/**
* @since 2.0.0
* @category constructors
*/
const currentTimeMillis = currentTimeMillis$1;
/**
* @since 2.0.0
* @category constructors
*/
const currentTimeNanos = currentTimeNanos$1;
/**
* @since 2.0.0
* @category constructors
*/
const clockWith$2 = clockWith$3;
/**
* @since 2.0.0
* @category context
*/
const Clock = clockTag;

//#endregion
//#region ../../node_modules/.bun/effect@3.17.14/node_modules/effect/dist/esm/internal/logSpan.js
/** @internal */
const make$19 = (label, startTime) => ({
	label,
	startTime
});
/**
* Sanitize a given string by replacing spaces, equal signs, and double quotes with underscores.
*
* @internal
*/
const formatLabel = (key) => key.replace(/[\s="]/g, "_");
/** @internal */
const render$1 = (now) => (self) => {
	return `${formatLabel(self.label)}=${now - self.startTime}ms`;
};

//#endregion
//#region ../../node_modules/.bun/effect@3.17.14/node_modules/effect/dist/esm/LogSpan.js
/**
* @since 2.0.0
* @category constructors
*/
const make$18 = make$19;
/**
* @since 2.0.0
* @category destructors
*/
const render = render$1;

//#endregion
//#region ../../node_modules/.bun/effect@3.17.14/node_modules/effect/dist/esm/Tracer.js
/**
* @since 2.0.0
*/
const TracerTypeId = TracerTypeId$1;
/**
* @since 2.0.0
* @category tags
*/
const ParentSpan = spanTag;
/**
* @since 2.0.0
* @category tags
*/
const Tracer = tracerTag;
/**
* @since 2.0.0
* @category constructors
*/
const make$17 = make$23;
/**
* @since 2.0.0
* @category constructors
*/
const externalSpan = externalSpan$1;
/**
* @since 2.0.0
* @category constructors
*/
const tracerWith$2 = tracerWith$3;
/**
* @since 3.12.0
* @category annotations
*/
const DisablePropagation = DisablePropagation$1;

//#endregion
//#region ../../node_modules/.bun/effect@3.17.14/node_modules/effect/dist/esm/internal/metric/label.js
/** @internal */
const MetricLabelSymbolKey = "effect/MetricLabel";
/** @internal */
const MetricLabelTypeId = /* @__PURE__ */ Symbol.for(MetricLabelSymbolKey);
/** @internal */
var MetricLabelImpl = class {
	key;
	value;
	[MetricLabelTypeId] = MetricLabelTypeId;
	_hash;
	constructor(key, value) {
		this.key = key;
		this.value = value;
		this._hash = string(MetricLabelSymbolKey + this.key + this.value);
	}
	[symbol$1]() {
		return this._hash;
	}
	[symbol](that) {
		return isMetricLabel(that) && this.key === that.key && this.value === that.value;
	}
	pipe() {
		return pipeArguments(this, arguments);
	}
};
/** @internal */
const make$16 = (key, value) => {
	return new MetricLabelImpl(key, value);
};
/** @internal */
const isMetricLabel = (u) => hasProperty(u, MetricLabelTypeId);

//#endregion
//#region ../../node_modules/.bun/effect@3.17.14/node_modules/effect/dist/esm/internal/core-effect.js
const annotateLogs$1 = /* @__PURE__ */ dual((args$1) => isEffect$1(args$1[0]), function() {
	const args$1 = arguments;
	return fiberRefLocallyWith(args$1[0], currentLogAnnotations, typeof args$1[1] === "string" ? set$3(args$1[1], args$1[2]) : (annotations$1) => Object.entries(args$1[1]).reduce((acc, [key, value]) => set$3(acc, key, value), annotations$1));
});
const asSome$1 = (self) => map$8(self, some$4);
const asSomeError$1 = (self) => mapError$3(self, some$4);
const try_$1 = (arg) => {
	let evaluate$1;
	let onFailure = void 0;
	if (typeof arg === "function") evaluate$1 = arg;
	else {
		evaluate$1 = arg.try;
		onFailure = arg.catch;
	}
	return suspend$3(() => {
		try {
			return succeed$9(internalCall(evaluate$1));
		} catch (error) {
			return fail$8(onFailure ? internalCall(() => onFailure(error)) : new UnknownException(error, "An unknown error occurred in Effect.try"));
		}
	});
};
const _catch$1 = /* @__PURE__ */ dual(3, (self, tag, options) => catchAll$1(self, (e) => {
	if (hasProperty(e, tag) && e[tag] === options.failure) return options.onFailure(e);
	return fail$8(e);
}));
const catchAllDefect$1 = /* @__PURE__ */ dual(2, (self, f) => catchAllCause$1(self, (cause$2) => {
	const option$2 = find(cause$2, (_) => isDieType(_) ? some$4(_) : none$7());
	switch (option$2._tag) {
		case "None": return failCause$8(cause$2);
		case "Some": return f(option$2.value.defect);
	}
}));
const catchSomeCause$1 = /* @__PURE__ */ dual(2, (self, f) => matchCauseEffect$2(self, {
	onFailure: (cause$2) => {
		const option$2 = f(cause$2);
		switch (option$2._tag) {
			case "None": return failCause$8(cause$2);
			case "Some": return option$2.value;
		}
	},
	onSuccess: succeed$9
}));
const catchSomeDefect$1 = /* @__PURE__ */ dual(2, (self, pf) => catchAllCause$1(self, (cause$2) => {
	const option$2 = find(cause$2, (_) => isDieType(_) ? some$4(_) : none$7());
	switch (option$2._tag) {
		case "None": return failCause$8(cause$2);
		case "Some": {
			const optionEffect = pf(option$2.value.defect);
			return optionEffect._tag === "Some" ? optionEffect.value : failCause$8(cause$2);
		}
	}
}));
const catchTag$1 = /* @__PURE__ */ dual((args$1) => isEffect$1(args$1[0]), (self, ...args$1) => {
	const f = args$1[args$1.length - 1];
	let predicate;
	if (args$1.length === 2) predicate = isTagged(args$1[0]);
	else predicate = (e) => {
		const tag = hasProperty(e, "_tag") ? e["_tag"] : void 0;
		if (!tag) return false;
		for (let i = 0; i < args$1.length - 1; i++) if (args$1[i] === tag) return true;
		return false;
	};
	return catchIf$1(self, predicate, f);
});
/** @internal */
const catchTags$1 = /* @__PURE__ */ dual(2, (self, cases) => {
	let keys$5;
	return catchIf$1(self, (e) => {
		keys$5 ??= Object.keys(cases);
		return hasProperty(e, "_tag") && isString(e["_tag"]) && keys$5.includes(e["_tag"]);
	}, (e) => cases[e["_tag"]](e));
});
const cause$1 = (self) => matchCause$2(self, {
	onFailure: identity,
	onSuccess: () => empty$27
});
const clockWith$1 = clockWith$2;
const clock$1 = /* @__PURE__ */ clockWith$1(succeed$9);
const delay$1 = /* @__PURE__ */ dual(2, (self, duration) => zipRight$3(sleep$2(duration), self));
const descriptorWith$1 = (f) => withFiberRuntime$1((state, status$2) => f({
	id: state.id(),
	status: status$2,
	interruptors: interruptors(state.getFiberRef(currentInterruptedCause))
}));
const allowInterrupt$1 = /* @__PURE__ */ descriptorWith$1((descriptor$2) => size$6(descriptor$2.interruptors) > 0 ? interrupt$4 : void_$4);
const descriptor$1 = /* @__PURE__ */ descriptorWith$1(succeed$9);
const diffFiberRefs$1 = (self) => summarized$1(self, fiberRefs, diff$2);
const diffFiberRefsAndRuntimeFlags = (self) => summarized$1(self, zip$4(fiberRefs, runtimeFlags), ([refs, flags], [refsNew, flagsNew]) => [diff$2(refs, refsNew), diff$3(flags, flagsNew)]);
const Do$1 = /* @__PURE__ */ succeed$9({});
const bind$1 = /* @__PURE__ */ bind$2(map$8, flatMap$4);
const bindTo$1 = /* @__PURE__ */ bindTo$2(map$8);
const let_$1 = /* @__PURE__ */ let_$2(map$8);
const dropUntil$1 = /* @__PURE__ */ dual(2, (elements, predicate) => suspend$3(() => {
	const iterator = elements[Symbol.iterator]();
	const builder = [];
	let next;
	let dropping = succeed$9(false);
	let i = 0;
	while ((next = iterator.next()) && !next.done) {
		const a = next.value;
		const index = i++;
		dropping = flatMap$4(dropping, (bool) => {
			if (bool) {
				builder.push(a);
				return succeed$9(true);
			}
			return predicate(a, index);
		});
	}
	return map$8(dropping, () => builder);
}));
const dropWhile$1 = /* @__PURE__ */ dual(2, (elements, predicate) => suspend$3(() => {
	const iterator = elements[Symbol.iterator]();
	const builder = [];
	let next;
	let dropping = succeed$9(true);
	let i = 0;
	while ((next = iterator.next()) && !next.done) {
		const a = next.value;
		const index = i++;
		dropping = flatMap$4(dropping, (d) => map$8(d ? predicate(a, index) : succeed$9(false), (b) => {
			if (!b) builder.push(a);
			return b;
		}));
	}
	return map$8(dropping, () => builder);
}));
const contextWith$1 = (f) => map$8(context$1(), f);
const eventually$1 = (self) => orElse$4(self, () => flatMap$4(yieldNow$3(), () => eventually$1(self)));
const filterMap$1 = /* @__PURE__ */ dual(2, (elements, pf) => map$8(forEachSequential(elements, identity), filterMap$4(pf)));
const filterOrDie$1 = /* @__PURE__ */ dual(3, (self, predicate, orDieWith$2) => filterOrElse$1(self, predicate, (a) => dieSync$2(() => orDieWith$2(a))));
const filterOrDieMessage$1 = /* @__PURE__ */ dual(3, (self, predicate, message) => filterOrElse$1(self, predicate, () => dieMessage$1(message)));
const filterOrElse$1 = /* @__PURE__ */ dual(3, (self, predicate, orElse$6) => flatMap$4(self, (a) => predicate(a) ? succeed$9(a) : orElse$6(a)));
/** @internal */
const liftPredicate$1 = /* @__PURE__ */ dual(3, (self, predicate, orFailWith) => suspend$3(() => predicate(self) ? succeed$9(self) : fail$8(orFailWith(self))));
const filterOrFail$1 = /* @__PURE__ */ dual((args$1) => isEffect$1(args$1[0]), (self, predicate, orFailWith) => filterOrElse$1(self, predicate, (a) => orFailWith === void 0 ? fail$8(new NoSuchElementException()) : failSync$2(() => orFailWith(a))));
const findFirst$3 = /* @__PURE__ */ dual(2, (elements, predicate) => suspend$3(() => {
	const iterator = elements[Symbol.iterator]();
	const next = iterator.next();
	if (!next.done) return findLoop(iterator, 0, predicate, next.value);
	return succeed$9(none$7());
}));
const findLoop = (iterator, index, f, value) => flatMap$4(f(value, index), (result) => {
	if (result) return succeed$9(some$4(value));
	const next = iterator.next();
	if (!next.done) return findLoop(iterator, index + 1, f, next.value);
	return succeed$9(none$7());
});
const firstSuccessOf$1 = (effects) => suspend$3(() => {
	const list = fromIterable$9(effects);
	if (!isNonEmpty$5(list)) return dieSync$2(() => new IllegalArgumentException(`Received an empty collection of effects`));
	return pipe(tailNonEmpty(list), reduce$11(headNonEmpty(list), (left$2, right$2) => orElse$4(left$2, () => right$2)));
});
const flipWith$1 = /* @__PURE__ */ dual(2, (self, f) => flip$1(f(flip$1(self))));
const match$4 = /* @__PURE__ */ dual(2, (self, options) => matchEffect$2(self, {
	onFailure: (e) => succeed$9(options.onFailure(e)),
	onSuccess: (a) => succeed$9(options.onSuccess(a))
}));
const every$1 = /* @__PURE__ */ dual(2, (elements, predicate) => suspend$3(() => forAllLoop(elements[Symbol.iterator](), 0, predicate)));
const forAllLoop = (iterator, index, f) => {
	const next = iterator.next();
	return next.done ? succeed$9(true) : flatMap$4(f(next.value, index), (b) => b ? forAllLoop(iterator, index + 1, f) : succeed$9(b));
};
const forever$2 = (self) => {
	const loop$2 = flatMap$4(flatMap$4(self, () => yieldNow$3()), () => loop$2);
	return loop$2;
};
const fiberRefs = /* @__PURE__ */ withFiberRuntime$1((state) => succeed$9(state.getFiberRefs()));
const head$1 = (self) => flatMap$4(self, (as$4) => {
	const next = as$4[Symbol.iterator]().next();
	if (next.done) return fail$8(new NoSuchElementException());
	return succeed$9(next.value);
});
const ignore$1 = (self) => match$4(self, {
	onFailure: constVoid,
	onSuccess: constVoid
});
const ignoreLogged$1 = (self) => matchCauseEffect$2(self, {
	onFailure: (cause$2) => logDebug$1(cause$2, "An error was silently ignored because it is not anticipated to be useful"),
	onSuccess: () => void_$4
});
const inheritFiberRefs$1 = (childFiberRefs) => updateFiberRefs$1((parentFiberId, parentFiberRefs) => joinAs(parentFiberRefs, parentFiberId, childFiberRefs));
const isFailure$2 = (self) => match$4(self, {
	onFailure: constTrue,
	onSuccess: constFalse
});
const isSuccess$2 = (self) => match$4(self, {
	onFailure: constFalse,
	onSuccess: constTrue
});
const iterate$1 = (initial, options) => suspend$3(() => {
	if (options.while(initial)) return flatMap$4(options.body(initial), (z2) => iterate$1(z2, options));
	return succeed$9(initial);
});
/** @internal */
const logWithLevel = (level) => (...message) => {
	const levelOption = fromNullable$2(level);
	let cause$2 = void 0;
	for (let i = 0, len = message.length; i < len; i++) {
		const msg = message[i];
		if (isCause(msg)) {
			if (cause$2 !== void 0) cause$2 = sequential$2(cause$2, msg);
			else cause$2 = msg;
			message = [...message.slice(0, i), ...message.slice(i + 1)];
			i--;
		}
	}
	if (cause$2 === void 0) cause$2 = empty$27;
	return withFiberRuntime$1((fiberState) => {
		fiberState.log(message, cause$2, levelOption);
		return void_$4;
	});
};
/** @internal */
const log$1 = /* @__PURE__ */ logWithLevel();
/** @internal */
const logTrace$1 = /* @__PURE__ */ logWithLevel(Trace);
/** @internal */
const logDebug$1 = /* @__PURE__ */ logWithLevel(Debug);
/** @internal */
const logInfo$1 = /* @__PURE__ */ logWithLevel(Info);
/** @internal */
const logWarning$1 = /* @__PURE__ */ logWithLevel(Warning);
/** @internal */
const logError$1 = /* @__PURE__ */ logWithLevel(Error$1);
/** @internal */
const logFatal$1 = /* @__PURE__ */ logWithLevel(Fatal);
const withLogSpan$1 = /* @__PURE__ */ dual(2, (effect, label) => flatMap$4(currentTimeMillis, (now) => fiberRefLocallyWith(effect, currentLogSpan, prepend(make$18(label, now)))));
const logAnnotations$1 = /* @__PURE__ */ fiberRefGet(currentLogAnnotations);
const loop$1 = (initial, options) => options.discard ? loopDiscard(initial, options.while, options.step, options.body) : map$8(loopInternal(initial, options.while, options.step, options.body), fromIterable$10);
const loopInternal = (initial, cont, inc, body) => suspend$3(() => cont(initial) ? flatMap$4(body(initial), (a) => map$8(loopInternal(inc(initial), cont, inc, body), prepend(a))) : sync$3(() => empty$23()));
const loopDiscard = (initial, cont, inc, body) => suspend$3(() => cont(initial) ? flatMap$4(body(initial), () => loopDiscard(inc(initial), cont, inc, body)) : void_$4);
const mapAccum$1 = /* @__PURE__ */ dual(3, (elements, initial, f) => suspend$3(() => {
	const iterator = elements[Symbol.iterator]();
	const builder = [];
	let result = succeed$9(initial);
	let next;
	let i = 0;
	while (!(next = iterator.next()).done) {
		const index = i++;
		const value = next.value;
		result = flatMap$4(result, (state) => map$8(f(state, value, index), ([z, b]) => {
			builder.push(b);
			return z;
		}));
	}
	return map$8(result, (z) => [z, builder]);
}));
const mapErrorCause$2 = /* @__PURE__ */ dual(2, (self, f) => matchCauseEffect$2(self, {
	onFailure: (c) => failCauseSync$2(() => f(c)),
	onSuccess: succeed$9
}));
const memoize = (self) => pipe(deferredMake(), flatMap$4((deferred) => pipe(diffFiberRefsAndRuntimeFlags(self), intoDeferred$1(deferred), once$2, map$8((complete$4) => zipRight$3(complete$4, pipe(deferredAwait(deferred), flatMap$4(([patch$11, a]) => as$3(zip$4(patchFiberRefs$1(patch$11[0]), updateRuntimeFlags(patch$11[1])), a))))))));
const merge$2 = (self) => matchEffect$2(self, {
	onFailure: (e) => succeed$9(e),
	onSuccess: succeed$9
});
const negate$1 = (self) => map$8(self, (b) => !b);
const none$4 = (self) => flatMap$4(self, (option$2) => {
	switch (option$2._tag) {
		case "None": return void_$4;
		case "Some": return fail$8(new NoSuchElementException());
	}
});
const once$2 = (self) => map$8(make$21(true), (ref) => asVoid$3(whenEffect$1(self, getAndSet(ref, false))));
const option$1 = (self) => matchEffect$2(self, {
	onFailure: () => succeed$9(none$7()),
	onSuccess: (a) => succeed$9(some$4(a))
});
const orElseFail$1 = /* @__PURE__ */ dual(2, (self, evaluate$1) => orElse$4(self, () => failSync$2(evaluate$1)));
const orElseSucceed$1 = /* @__PURE__ */ dual(2, (self, evaluate$1) => orElse$4(self, () => sync$3(evaluate$1)));
const parallelErrors$1 = (self) => matchCauseEffect$2(self, {
	onFailure: (cause$2) => {
		const errors = fromIterable$10(failures(cause$2));
		return errors.length === 0 ? failCause$8(cause$2) : fail$8(errors);
	},
	onSuccess: succeed$9
});
const patchFiberRefs$1 = (patch$11) => updateFiberRefs$1((fiberId$2, fiberRefs$3) => pipe(patch$11, patch$2(fiberId$2, fiberRefs$3)));
const promise$1 = (evaluate$1) => evaluate$1.length >= 1 ? async_((resolve, signal) => {
	try {
		evaluate$1(signal).then((a) => resolve(succeed$9(a)), (e) => resolve(die$3(e)));
	} catch (e) {
		resolve(die$3(e));
	}
}) : async_((resolve) => {
	try {
		evaluate$1().then((a) => resolve(succeed$9(a)), (e) => resolve(die$3(e)));
	} catch (e) {
		resolve(die$3(e));
	}
});
const provideService$1 = /* @__PURE__ */ dual(3, (self, tag, service) => contextWithEffect$1((env) => provideContext$1(self, add$1(env, tag, service))));
const provideServiceEffect$1 = /* @__PURE__ */ dual(3, (self, tag, effect) => contextWithEffect$1((env) => flatMap$4(effect, (service) => provideContext$1(self, pipe(env, add$1(tag, service))))));
const random$1 = /* @__PURE__ */ randomWith$1(succeed$9);
const reduce$3 = /* @__PURE__ */ dual(3, (elements, zero$1, f) => fromIterable$10(elements).reduce((acc, el, i) => flatMap$4(acc, (a) => f(a, el, i)), succeed$9(zero$1)));
const reduceRight$1 = /* @__PURE__ */ dual(3, (elements, zero$1, f) => fromIterable$10(elements).reduceRight((acc, el, i) => flatMap$4(acc, (a) => f(el, a, i)), succeed$9(zero$1)));
const reduceWhile$1 = /* @__PURE__ */ dual(3, (elements, zero$1, options) => flatMap$4(sync$3(() => elements[Symbol.iterator]()), (iterator) => reduceWhileLoop(iterator, 0, zero$1, options.while, options.body)));
const reduceWhileLoop = (iterator, index, state, predicate, f) => {
	const next = iterator.next();
	if (!next.done && predicate(state)) return flatMap$4(f(state, next.value, index), (nextState) => reduceWhileLoop(iterator, index + 1, nextState, predicate, f));
	return succeed$9(state);
};
const repeatN$1 = /* @__PURE__ */ dual(2, (self, n) => suspend$3(() => repeatNLoop(self, n)));
const repeatNLoop = (self, n) => flatMap$4(self, (a) => n <= 0 ? succeed$9(a) : zipRight$3(yieldNow$3(), repeatNLoop(self, n - 1)));
const sandbox$1 = (self) => matchCauseEffect$2(self, {
	onFailure: fail$8,
	onSuccess: succeed$9
});
const setFiberRefs$1 = (fiberRefs$3) => suspend$3(() => setAll(fiberRefs$3));
const sleep$1 = sleep$2;
const succeedNone$1 = /* @__PURE__ */ succeed$9(/* @__PURE__ */ none$7());
const succeedSome$1 = (value) => succeed$9(some$4(value));
const summarized$1 = /* @__PURE__ */ dual(3, (self, summary$2, f) => flatMap$4(summary$2, (start$2) => flatMap$4(self, (value) => map$8(summary$2, (end$2) => [f(start$2, end$2), value]))));
const tagMetrics$1 = /* @__PURE__ */ dual((args$1) => isEffect$1(args$1[0]), function() {
	return labelMetrics$1(arguments[0], typeof arguments[1] === "string" ? [make$16(arguments[1], arguments[2])] : Object.entries(arguments[1]).map(([k, v]) => make$16(k, v)));
});
const labelMetrics$1 = /* @__PURE__ */ dual(2, (self, labels) => fiberRefLocallyWith(self, currentMetricLabels, (old) => union$8(old, labels)));
const takeUntil$1 = /* @__PURE__ */ dual(2, (elements, predicate) => suspend$3(() => {
	const iterator = elements[Symbol.iterator]();
	const builder = [];
	let next;
	let effect = succeed$9(false);
	let i = 0;
	while ((next = iterator.next()) && !next.done) {
		const a = next.value;
		const index = i++;
		effect = flatMap$4(effect, (bool) => {
			if (bool) return succeed$9(true);
			builder.push(a);
			return predicate(a, index);
		});
	}
	return map$8(effect, () => builder);
}));
const takeWhile$1 = /* @__PURE__ */ dual(2, (elements, predicate) => suspend$3(() => {
	const iterator = elements[Symbol.iterator]();
	const builder = [];
	let next;
	let taking = succeed$9(true);
	let i = 0;
	while ((next = iterator.next()) && !next.done) {
		const a = next.value;
		const index = i++;
		taking = flatMap$4(taking, (taking$1) => pipe(taking$1 ? predicate(a, index) : succeed$9(false), map$8((bool) => {
			if (bool) builder.push(a);
			return bool;
		})));
	}
	return map$8(taking, () => builder);
}));
const tapBoth$1 = /* @__PURE__ */ dual(2, (self, { onFailure, onSuccess }) => matchCauseEffect$2(self, {
	onFailure: (cause$2) => {
		const either$4 = failureOrCause(cause$2);
		switch (either$4._tag) {
			case "Left": return zipRight$3(onFailure(either$4.left), failCause$8(cause$2));
			case "Right": return failCause$8(cause$2);
		}
	},
	onSuccess: (a) => as$3(onSuccess(a), a)
}));
const tapDefect$1 = /* @__PURE__ */ dual(2, (self, f) => catchAllCause$1(self, (cause$2) => match$10(keepDefects(cause$2), {
	onNone: () => failCause$8(cause$2),
	onSome: (a) => zipRight$3(f(a), failCause$8(cause$2))
})));
const tapError$1 = /* @__PURE__ */ dual(2, (self, f) => matchCauseEffect$2(self, {
	onFailure: (cause$2) => {
		const either$4 = failureOrCause(cause$2);
		switch (either$4._tag) {
			case "Left": return zipRight$3(f(either$4.left), failCause$8(cause$2));
			case "Right": return failCause$8(cause$2);
		}
	},
	onSuccess: succeed$9
}));
const tapErrorTag$1 = /* @__PURE__ */ dual(3, (self, k, f) => tapError$1(self, (e) => {
	if (isTagged(e, k)) return f(e);
	return void_$4;
}));
const tapErrorCause$1 = /* @__PURE__ */ dual(2, (self, f) => matchCauseEffect$2(self, {
	onFailure: (cause$2) => zipRight$3(f(cause$2), failCause$8(cause$2)),
	onSuccess: succeed$9
}));
const timed$1 = (self) => timedWith$1(self, currentTimeNanos);
const timedWith$1 = /* @__PURE__ */ dual(2, (self, nanos$1) => summarized$1(self, nanos$1, (start$2, end$2) => nanos(end$2 - start$2)));
const tracerWith$1 = tracerWith$2;
/** @internal */
const tracer$1 = /* @__PURE__ */ tracerWith$1(succeed$9);
const tryPromise$1 = (arg) => {
	let evaluate$1;
	let catcher = void 0;
	if (typeof arg === "function") evaluate$1 = arg;
	else {
		evaluate$1 = arg.try;
		catcher = arg.catch;
	}
	const fail$10 = (e) => catcher ? failSync$2(() => catcher(e)) : fail$8(new UnknownException(e, "An unknown error occurred in Effect.tryPromise"));
	if (evaluate$1.length >= 1) return async_((resolve, signal) => {
		try {
			evaluate$1(signal).then((a) => resolve(succeed$9(a)), (e) => resolve(fail$10(e)));
		} catch (e) {
			resolve(fail$10(e));
		}
	});
	return async_((resolve) => {
		try {
			evaluate$1().then((a) => resolve(succeed$9(a)), (e) => resolve(fail$10(e)));
		} catch (e) {
			resolve(fail$10(e));
		}
	});
};
const tryMap$1 = /* @__PURE__ */ dual(2, (self, options) => flatMap$4(self, (a) => try_$1({
	try: () => options.try(a),
	catch: options.catch
})));
const tryMapPromise$1 = /* @__PURE__ */ dual(2, (self, options) => flatMap$4(self, (a) => tryPromise$1({
	try: options.try.length >= 1 ? (signal) => options.try(a, signal) : () => options.try(a),
	catch: options.catch
})));
const unless$1 = /* @__PURE__ */ dual(2, (self, condition) => suspend$3(() => condition() ? succeedNone$1 : asSome$1(self)));
const unlessEffect$1 = /* @__PURE__ */ dual(2, (self, condition) => flatMap$4(condition, (b) => b ? succeedNone$1 : asSome$1(self)));
const unsandbox$1 = (self) => mapErrorCause$2(self, flatten$5);
const updateFiberRefs$1 = (f) => withFiberRuntime$1((state) => {
	state.setFiberRefs(f(state.id(), state.getFiberRefs()));
	return void_$4;
});
const updateService$1 = /* @__PURE__ */ dual(3, (self, tag, f) => mapInputContext$1(self, (context$2) => add$1(context$2, tag, f(unsafeGet$1(context$2, tag)))));
const when$1 = /* @__PURE__ */ dual(2, (self, condition) => suspend$3(() => condition() ? map$8(self, some$4) : succeed$9(none$7())));
const whenFiberRef$1 = /* @__PURE__ */ dual(3, (self, fiberRef, predicate) => flatMap$4(fiberRefGet(fiberRef), (s) => predicate(s) ? map$8(self, (a) => [s, some$4(a)]) : succeed$9([s, none$7()])));
const whenRef$1 = /* @__PURE__ */ dual(3, (self, ref, predicate) => flatMap$4(get$1(ref), (s) => predicate(s) ? map$8(self, (a) => [s, some$4(a)]) : succeed$9([s, none$7()])));
const withMetric$1 = /* @__PURE__ */ dual(2, (self, metric) => metric(self));
/** @internal */
const serviceFunctionEffect$1 = (getService, f) => (...args$1) => flatMap$4(getService, (a) => f(a)(...args$1));
/** @internal */
const serviceFunction$1 = (getService, f) => (...args$1) => map$8(getService, (a) => f(a)(...args$1));
/** @internal */
const serviceFunctions$1 = (getService) => new Proxy({}, { get(_target, prop, _receiver) {
	return (...args$1) => flatMap$4(getService, (s) => s[prop](...args$1));
} });
/** @internal */
const serviceConstants$1 = (getService) => new Proxy({}, { get(_target, prop, _receiver) {
	return flatMap$4(getService, (s) => isEffect$1(s[prop]) ? s[prop] : succeed$9(s[prop]));
} });
/** @internal */
const serviceMembers$1 = (getService) => ({
	functions: serviceFunctions$1(getService),
	constants: serviceConstants$1(getService)
});
/** @internal */
const serviceOption$1 = (tag) => map$8(context$1(), getOption(tag));
/** @internal */
const serviceOptional$1 = (tag) => flatMap$4(context$1(), getOption(tag));
const annotateCurrentSpan$1 = function() {
	const args$1 = arguments;
	return ignore$1(flatMap$4(currentSpan$1, (span$1) => sync$3(() => {
		if (typeof args$1[0] === "string") span$1.attribute(args$1[0], args$1[1]);
		else for (const key in args$1[0]) span$1.attribute(key, args$1[0][key]);
	})));
};
const linkSpanCurrent$1 = function() {
	const args$1 = arguments;
	const links = Array.isArray(args$1[0]) ? args$1[0] : [{
		_tag: "SpanLink",
		span: args$1[0],
		attributes: args$1[1] ?? {}
	}];
	return ignore$1(flatMap$4(currentSpan$1, (span$1) => sync$3(() => span$1.addLinks(links))));
};
const annotateSpans$1 = /* @__PURE__ */ dual((args$1) => isEffect$1(args$1[0]), function() {
	const args$1 = arguments;
	return fiberRefLocallyWith(args$1[0], currentTracerSpanAnnotations, typeof args$1[1] === "string" ? set$3(args$1[1], args$1[2]) : (annotations$1) => Object.entries(args$1[1]).reduce((acc, [key, value]) => set$3(acc, key, value), annotations$1));
});
/** @internal */
const currentParentSpan$1 = /* @__PURE__ */ serviceOptional$1(spanTag);
/** @internal */
const currentSpan$1 = /* @__PURE__ */ flatMap$4(/* @__PURE__ */ context$1(), (context$2) => {
	const span$1 = context$2.unsafeMap.get(spanTag.key);
	return span$1 !== void 0 && span$1._tag === "Span" ? succeed$9(span$1) : fail$8(new NoSuchElementException());
});
const linkSpans$1 = /* @__PURE__ */ dual((args$1) => isEffect$1(args$1[0]), (self, span$1, attributes) => fiberRefLocallyWith(self, currentTracerSpanLinks, append$1({
	_tag: "SpanLink",
	span: span$1,
	attributes: attributes ?? {}
})));
const bigint0$1 = /* @__PURE__ */ BigInt(0);
const filterDisablePropagation = /* @__PURE__ */ flatMap$11((span$1) => get$7(span$1.context, DisablePropagation$1) ? span$1._tag === "Span" ? filterDisablePropagation(span$1.parent) : none$7() : some$4(span$1));
/** @internal */
const unsafeMakeSpan = (fiber, name, options) => {
	const disablePropagation = !fiber.getFiberRef(currentTracerEnabled) || options.context && get$7(options.context, DisablePropagation$1);
	const context$2 = fiber.getFiberRef(currentContext);
	const parent = options.parent ? some$4(options.parent) : options.root ? none$7() : filterDisablePropagation(getOption(context$2, spanTag));
	let span$1;
	if (disablePropagation) span$1 = noopSpan({
		name,
		parent,
		context: add$1(options.context ?? empty$25(), DisablePropagation$1, true)
	});
	else {
		const services = fiber.getFiberRef(currentServices);
		const tracer$2 = get$7(services, tracerTag);
		const clock$2 = get$7(services, Clock);
		const timingEnabled = fiber.getFiberRef(currentTracerTimingEnabled);
		const fiberRefs$3 = fiber.getFiberRefs();
		const annotationsFromEnv = get$3(fiberRefs$3, currentTracerSpanAnnotations);
		const linksFromEnv = get$3(fiberRefs$3, currentTracerSpanLinks);
		const links = linksFromEnv._tag === "Some" ? options.links !== void 0 ? [...toReadonlyArray(linksFromEnv.value), ...options.links ?? []] : toReadonlyArray(linksFromEnv.value) : options.links ?? empty$32();
		span$1 = tracer$2.span(name, parent, options.context ?? empty$25(), links, timingEnabled ? clock$2.unsafeCurrentTimeNanos() : bigint0$1, options.kind ?? "internal");
		if (annotationsFromEnv._tag === "Some") forEach$5(annotationsFromEnv.value, (value, key) => span$1.attribute(key, value));
		if (options.attributes !== void 0) Object.entries(options.attributes).forEach(([k, v]) => span$1.attribute(k, v));
	}
	if (typeof options.captureStackTrace === "function") spanToTrace.set(span$1, options.captureStackTrace);
	return span$1;
};
/** @internal */
const makeSpan$1 = (name, options) => {
	options = addSpanStackTrace(options);
	return withFiberRuntime$1((fiber) => succeed$9(unsafeMakeSpan(fiber, name, options)));
};
const spanAnnotations$1 = /* @__PURE__ */ fiberRefGet(currentTracerSpanAnnotations);
const spanLinks$1 = /* @__PURE__ */ fiberRefGet(currentTracerSpanLinks);
/** @internal */
const endSpan = (span$1, exit$3, clock$2, timingEnabled) => sync$3(() => {
	if (span$1.status._tag === "Ended") return;
	if (exitIsFailure(exit$3) && spanToTrace.has(span$1)) span$1.attribute("code.stacktrace", spanToTrace.get(span$1)());
	span$1.end(timingEnabled ? clock$2.unsafeCurrentTimeNanos() : bigint0$1, exit$3);
});
/** @internal */
const useSpan$1 = (name, ...args$1) => {
	const options = addSpanStackTrace(args$1.length === 1 ? void 0 : args$1[0]);
	const evaluate$1 = args$1[args$1.length - 1];
	return withFiberRuntime$1((fiber) => {
		const span$1 = unsafeMakeSpan(fiber, name, options);
		const timingEnabled = fiber.getFiberRef(currentTracerTimingEnabled);
		const clock$2 = get$7(fiber.getFiberRef(currentServices), clockTag);
		return onExit$2(evaluate$1(span$1), (exit$3) => endSpan(span$1, exit$3, clock$2, timingEnabled));
	});
};
/** @internal */
const withParentSpan$1 = /* @__PURE__ */ dual(2, (self, span$1) => provideService$1(self, spanTag, span$1));
/** @internal */
const withSpan$1 = function() {
	const dataFirst = typeof arguments[0] !== "string";
	const name = dataFirst ? arguments[1] : arguments[0];
	const options = addSpanStackTrace(dataFirst ? arguments[2] : arguments[1]);
	if (dataFirst) {
		const self = arguments[0];
		return useSpan$1(name, options, (span$1) => withParentSpan$1(self, span$1));
	}
	return (self) => useSpan$1(name, options, (span$1) => withParentSpan$1(self, span$1));
};
const functionWithSpan$1 = (options) => function() {
	let captureStackTrace = options.captureStackTrace ?? false;
	if (options.captureStackTrace !== false) {
		const limit = Error.stackTraceLimit;
		Error.stackTraceLimit = 2;
		const error = /* @__PURE__ */ new Error();
		Error.stackTraceLimit = limit;
		let cache = false;
		captureStackTrace = () => {
			if (cache !== false) return cache;
			if (error.stack) {
				cache = error.stack.trim().split("\n").slice(2).join("\n").trim();
				return cache;
			}
		};
	}
	return suspend$3(() => {
		const opts = typeof options.options === "function" ? options.options.apply(null, arguments) : options.options;
		return withSpan$1(suspend$3(() => internalCall(() => options.body.apply(this, arguments))), opts.name, {
			...opts,
			captureStackTrace
		});
	});
};
const fromNullable$1 = (value) => value == null ? fail$8(new NoSuchElementException()) : succeed$9(value);
const optionFromOptional$1 = (self) => catchAll$1(map$8(self, some$4), (error) => isNoSuchElementException(error) ? succeedNone$1 : fail$8(error));

//#endregion
//#region ../../node_modules/.bun/effect@3.17.14/node_modules/effect/dist/esm/Exit.js
/**
* Returns `true` if the specified value is an `Exit`, `false` otherwise.
*
* @since 2.0.0
* @category refinements
*/
const isExit = exitIsExit;
/**
* Returns `true` if the specified `Exit` is a `Failure`, `false` otherwise.
*
* @since 2.0.0
* @category refinements
*/
const isFailure$1 = exitIsFailure;
/**
* Returns `true` if the specified `Exit` is a `Success`, `false` otherwise.
*
* @since 2.0.0
* @category refinements
*/
const isSuccess$1 = exitIsSuccess;
/**
* Returns `true` if the specified exit is a `Failure` **and** the `Cause` of
* the failure was due to interruption, `false` otherwise.
*
* @since 2.0.0
* @category getters
*/
const isInterrupted = exitIsInterrupted;
/**
* Maps the `Success` value of the specified exit to the provided constant
* value.
*
* @since 2.0.0
* @category mapping
*/
const as$1 = exitAs;
/**
* Maps the `Success` value of the specified exit to a void.
*
* @since 2.0.0
* @category mapping
*/
const asVoid$2 = exitAsVoid;
/**
* Returns a `Some<Cause<E>>` if the specified exit is a `Failure`, `None`
* otherwise.
*
* @since 2.0.0
* @category getters
*/
const causeOption = exitCauseOption;
/**
* Collects all of the specified exit values into a `Some<Exit<List<A>, E>>`. If
* the provided iterable contains no elements, `None` will be returned.
*
* @since 2.0.0
* @category constructors
*/
const all$3 = exitCollectAll;
/**
* Constructs a new `Exit.Failure` from the specified unrecoverable defect.
*
* @since 2.0.0
* @category constructors
*/
const die$2 = exitDie$1;
/**
* Executes the predicate on the value of the specified exit if it is a
* `Success`, otherwise returns `false`.
*
* @since 2.0.0
* @category elements
*/
const exists$2 = exitExists;
/**
* Constructs a new `Exit.Failure` from the specified recoverable error of type
* `E`.
*
* @since 2.0.0
* @category constructors
*/
const fail$7 = exitFail;
/**
* Constructs a new `Exit.Failure` from the specified `Cause` of type `E`.
*
* @since 2.0.0
* @category constructors
*/
const failCause$6 = exitFailCause$1;
/**
* @since 2.0.0
* @category sequencing
*/
const flatMap$2 = exitFlatMap;
/**
* @since 2.0.0
* @category sequencing
*/
const flatMapEffect = exitFlatMapEffect;
/**
* @since 2.0.0
* @category sequencing
*/
const flatten$2 = exitFlatten;
/**
* @since 2.0.0
* @category traversing
*/
const forEachEffect = exitForEachEffect;
/**
* Converts an `Either<R, L>` into an `Exit<R, L>`.
*
* @since 2.0.0
* @category conversions
*/
const fromEither = exitFromEither;
/**
* Converts an `Option<A>` into an `Exit<void, A>`.
*
* @since 2.0.0
* @category conversions
*/
const fromOption$1 = exitFromOption;
/**
* Returns the `A` if specified exit is a `Success`, otherwise returns the
* alternate `A` value computed from the specified function which receives the
* `Cause<E>` of the exit `Failure`.
*
* @since 2.0.0
* @category getters
*/
const getOrElse = exitGetOrElse;
/**
* Constructs a new `Exit.Failure` from the specified `FiberId` indicating that
* the `Fiber` running an `Effect` workflow was terminated due to interruption.
*
* @since 2.0.0
* @category constructors
*/
const interrupt$3 = exitInterrupt$1;
/**
* Maps over the `Success` value of the specified exit using the provided
* function.
*
* @since 2.0.0
* @category mapping
*/
const map$6 = exitMap;
/**
* Maps over the `Success` and `Failure` cases of the specified exit using the
* provided functions.
*
* @since 2.0.0
* @category mapping
*/
const mapBoth$1 = exitMapBoth;
/**
* Maps over the error contained in the `Failure` of the specified exit using
* the provided function.
*
* @since 2.0.0
* @category mapping
*/
const mapError$2 = exitMapError;
/**
* Maps over the `Cause` contained in the `Failure` of the specified exit using
* the provided function.
*
* @since 2.0.0
* @category mapping
*/
const mapErrorCause$1 = exitMapErrorCause;
/**
* @since 2.0.0
* @category folding
*/
const match$3 = exitMatch;
/**
* @since 2.0.0
* @category folding
*/
const matchEffect$1 = exitMatchEffect;
/**
* Constructs a new `Exit.Success` containing the specified value of type `A`.
*
* @since 2.0.0
* @category constructors
*/
const succeed$7 = exitSucceed$1;
const void_$2 = exitVoid$1;
/**
* Sequentially zips the this result with the specified result or else returns
* the failed `Cause<E | E2>`.
*
* @since 2.0.0
* @category zipping
*/
const zip$3 = exitZip;
/**
* Sequentially zips the this result with the specified result discarding the
* second element of the tuple or else returns the failed `Cause<E | E2>`.
*
* @since 2.0.0
* @category zipping
*/
const zipLeft$2 = exitZipLeft;
/**
* Sequentially zips the this result with the specified result discarding the
* first element of the tuple or else returns the failed `Cause<E | E2>`.
*
* @since 2.0.0
* @category zipping
*/
const zipRight$2 = exitZipRight;
/**
* Parallelly zips the this result with the specified result or else returns
* the failed `Cause<E | E2>`.
*
* @since 2.0.0
* @category zipping
*/
const zipPar = exitZipPar;
/**
* Parallelly zips the this result with the specified result discarding the
* second element of the tuple or else returns the failed `Cause<E | E2>`.
*
* @since 2.0.0
* @category zipping
*/
const zipParLeft = exitZipParLeft;
/**
* Parallelly zips the this result with the specified result discarding the
* first element of the tuple or else returns the failed `Cause<E | E2>`.
*
* @since 2.0.0
* @category zipping
*/
const zipParRight = exitZipParRight;
/**
* Zips this exit together with that exit using the specified combination
* functions.
*
* @since 2.0.0
* @category zipping
*/
const zipWith$3 = exitZipWith;

//#endregion
//#region ../../node_modules/.bun/effect@3.17.14/node_modules/effect/dist/esm/internal/fiberMessage.js
/** @internal */
const OP_INTERRUPT_SIGNAL = "InterruptSignal";
/** @internal */
const OP_STATEFUL = "Stateful";
/** @internal */
const OP_RESUME = "Resume";
/** @internal */
const OP_YIELD_NOW = "YieldNow";
/** @internal */
const interruptSignal = (cause$2) => ({
	_tag: OP_INTERRUPT_SIGNAL,
	cause: cause$2
});
/** @internal */
const stateful = (onFiber) => ({
	_tag: OP_STATEFUL,
	onFiber
});
/** @internal */
const resume = (effect) => ({
	_tag: OP_RESUME,
	effect
});
/** @internal */
const yieldNow$1 = () => ({ _tag: OP_YIELD_NOW });

//#endregion
//#region ../../node_modules/.bun/effect@3.17.14/node_modules/effect/dist/esm/internal/fiberScope.js
/** @internal */
const FiberScopeSymbolKey = "effect/FiberScope";
/** @internal */
const FiberScopeTypeId = /* @__PURE__ */ Symbol.for(FiberScopeSymbolKey);
/** @internal */
var Global = class {
	[FiberScopeTypeId] = FiberScopeTypeId;
	fiberId = none$6;
	roots = /* @__PURE__ */ new Set();
	add(_runtimeFlags, child) {
		this.roots.add(child);
		child.addObserver(() => {
			this.roots.delete(child);
		});
	}
};
/** @internal */
var Local = class {
	fiberId;
	parent;
	[FiberScopeTypeId] = FiberScopeTypeId;
	constructor(fiberId$2, parent) {
		this.fiberId = fiberId$2;
		this.parent = parent;
	}
	add(_runtimeFlags, child) {
		this.parent.tell(stateful((parentFiber) => {
			parentFiber.addChild(child);
			child.addObserver(() => {
				parentFiber.removeChild(child);
			});
		}));
	}
};
/** @internal */
const unsafeMake$2 = (fiber) => {
	return new Local(fiber.id(), fiber);
};
/** @internal */
const globalScope = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberScope/Global"), () => new Global());

//#endregion
//#region ../../node_modules/.bun/effect@3.17.14/node_modules/effect/dist/esm/internal/fiber.js
/** @internal */
const FiberSymbolKey = "effect/Fiber";
/** @internal */
const FiberTypeId$1 = /* @__PURE__ */ Symbol.for(FiberSymbolKey);
/** @internal */
const fiberVariance = {
	_E: (_) => _,
	_A: (_) => _
};
/** @internal */
const fiberProto = {
	[FiberTypeId$1]: fiberVariance,
	pipe() {
		return pipeArguments(this, arguments);
	}
};
/** @internal */
const RuntimeFiberSymbolKey = "effect/Fiber";
/** @internal */
const RuntimeFiberTypeId$1 = /* @__PURE__ */ Symbol.for(RuntimeFiberSymbolKey);
/** @internal */
const Order$1 = /* @__PURE__ */ pipe(/* @__PURE__ */ tuple(Order$3, Order$3), /* @__PURE__ */ mapInput((fiber) => [fiber.id().startTimeMillis, fiber.id().id]));
/** @internal */
const isFiber$1 = (u) => hasProperty(u, FiberTypeId$1);
/** @internal */
const isRuntimeFiber$1 = (self) => RuntimeFiberTypeId$1 in self;
/** @internal */
const _await$2 = (self) => self.await;
/** @internal */
const children$1 = (self) => self.children;
/** @internal */
const done$4 = (exit$3) => {
	return {
		...CommitPrototype$1,
		commit() {
			return join$1(this);
		},
		...fiberProto,
		id: () => none$6,
		await: succeed$9(exit$3),
		children: succeed$9([]),
		inheritAll: void_$4,
		poll: succeed$9(some$4(exit$3)),
		interruptAsFork: () => void_$4
	};
};
/** @internal */
const dump$1 = (self) => map$8(self.status, (status$2) => ({
	id: self.id(),
	status: status$2
}));
/** @internal */
const dumpAll$1 = (fibers) => forEachSequential(fibers, dump$1);
/** @internal */
const fail$6 = (error) => done$4(fail$7(error));
/** @internal */
const failCause$5 = (cause$2) => done$4(failCause$6(cause$2));
/** @internal */
const fromEffect$2 = (effect) => map$8(exit$2(effect), done$4);
/** @internal */
const id$1 = (self) => self.id();
/** @internal */
const inheritAll$1 = (self) => self.inheritAll;
/** @internal */
const interrupted$1 = (fiberId$2) => done$4(interrupt$3(fiberId$2));
/** @internal */
const interruptAll$1 = (fibers) => flatMap$4(fiberId$1, (fiberId$2) => pipe(fibers, interruptAllAs$1(fiberId$2)));
/** @internal */
const interruptAllAs$1 = /* @__PURE__ */ dual(2, /* @__PURE__ */ fnUntraced$1(function* (fibers, fiberId$2) {
	for (const fiber of fibers) {
		if (isRuntimeFiber$1(fiber)) {
			fiber.unsafeInterruptAsFork(fiberId$2);
			continue;
		}
		yield* fiber.interruptAsFork(fiberId$2);
	}
	for (const fiber of fibers) {
		if (isRuntimeFiber$1(fiber) && fiber.unsafePoll()) continue;
		yield* fiber.await;
	}
}));
/** @internal */
const interruptAsFork$1 = /* @__PURE__ */ dual(2, (self, fiberId$2) => self.interruptAsFork(fiberId$2));
/** @internal */
const join$1 = (self) => zipLeft$3(flatten$3(self.await), self.inheritAll);
/** @internal */
const map$5 = /* @__PURE__ */ dual(2, (self, f) => mapEffect$2(self, (a) => sync$3(() => f(a))));
/** @internal */
const mapEffect$2 = /* @__PURE__ */ dual(2, (self, f) => {
	return {
		...CommitPrototype$1,
		commit() {
			return join$1(this);
		},
		...fiberProto,
		id: () => self.id(),
		await: flatMap$4(self.await, forEachEffect(f)),
		children: self.children,
		inheritAll: self.inheritAll,
		poll: flatMap$4(self.poll, (result) => {
			switch (result._tag) {
				case "None": return succeed$9(none$7());
				case "Some": return pipe(forEachEffect(result.value, f), map$8(some$4));
			}
		}),
		interruptAsFork: (id$2) => self.interruptAsFork(id$2)
	};
});
/** @internal */
const mapFiber$1 = /* @__PURE__ */ dual(2, (self, f) => map$8(self.await, match$3({
	onFailure: (cause$2) => failCause$5(cause$2),
	onSuccess: (a) => f(a)
})));
/** @internal */
const match$2 = /* @__PURE__ */ dual(2, (self, { onFiber, onRuntimeFiber }) => {
	if (isRuntimeFiber$1(self)) return onRuntimeFiber(self);
	return onFiber(self);
});
/** @internal */
const _never = {
	...CommitPrototype$1,
	commit() {
		return join$1(this);
	},
	...fiberProto,
	id: () => none$6,
	await: never$3,
	children: /* @__PURE__ */ succeed$9([]),
	inheritAll: never$3,
	poll: /* @__PURE__ */ succeed$9(/* @__PURE__ */ none$7()),
	interruptAsFork: () => never$3
};
/** @internal */
const never$2 = _never;
/** @internal */
const orElse$3 = /* @__PURE__ */ dual(2, (self, that) => ({
	...CommitPrototype$1,
	commit() {
		return join$1(this);
	},
	...fiberProto,
	id: () => getOrElse$1(self.id(), that.id()),
	await: zipWith$4(self.await, that.await, (exit1, exit2) => isSuccess$1(exit1) ? exit1 : exit2),
	children: self.children,
	inheritAll: zipRight$3(that.inheritAll, self.inheritAll),
	poll: zipWith$4(self.poll, that.poll, (option1, option2) => {
		switch (option1._tag) {
			case "None": return none$7();
			case "Some": return isSuccess$1(option1.value) ? option1 : option2;
		}
	}),
	interruptAsFork: (id$2) => pipe(interruptAsFiber(self, id$2), zipRight$3(pipe(that, interruptAsFiber(id$2))), asVoid$3)
}));
/** @internal */
const orElseEither$2 = /* @__PURE__ */ dual(2, (self, that) => orElse$3(map$5(self, left), map$5(that, right)));
/** @internal */
const poll$3 = (self) => self.poll;
/** @internal */
const parseMs = (milliseconds) => {
	const roundTowardsZero = milliseconds > 0 ? Math.floor : Math.ceil;
	return {
		days: roundTowardsZero(milliseconds / 864e5),
		hours: roundTowardsZero(milliseconds / 36e5) % 24,
		minutes: roundTowardsZero(milliseconds / 6e4) % 60,
		seconds: roundTowardsZero(milliseconds / 1e3) % 60,
		milliseconds: roundTowardsZero(milliseconds) % 1e3,
		microseconds: roundTowardsZero(milliseconds * 1e3) % 1e3,
		nanoseconds: roundTowardsZero(milliseconds * 1e6) % 1e3
	};
};
/** @internal */
const renderStatus = (status$2) => {
	if (isDone$3(status$2)) return "Done";
	if (isRunning(status$2)) return "Running";
	return `Suspended(${interruptible$3(status$2.runtimeFlags) ? "interruptible" : "uninterruptible"})`;
};
/** @internal */
const pretty$1 = (self) => flatMap$4(currentTimeMillis, (now) => map$8(dump$1(self), (dump$2) => {
	const time = now - dump$2.id.startTimeMillis;
	const { days: days$1, hours: hours$1, milliseconds, minutes: minutes$1, seconds: seconds$1 } = parseMs(time);
	const lifeMsg = (days$1 === 0 ? "" : `${days$1}d`) + (days$1 === 0 && hours$1 === 0 ? "" : `${hours$1}h`) + (days$1 === 0 && hours$1 === 0 && minutes$1 === 0 ? "" : `${minutes$1}m`) + (days$1 === 0 && hours$1 === 0 && minutes$1 === 0 && seconds$1 === 0 ? "" : `${seconds$1}s`) + `${milliseconds}ms`;
	const waitMsg = isSuspended(dump$2.status) ? (() => {
		const ids$2 = ids(dump$2.status.blockingOn);
		return size$6(ids$2) > 0 ? `waiting on ` + Array.from(ids$2).map((id$2) => `${id$2}`).join(", ") : "";
	})() : "";
	const statusMsg = renderStatus(dump$2.status);
	return `[Fiber](#${dump$2.id.id}) (${lifeMsg}) ${waitMsg}\n   Status: ${statusMsg}`;
}));
/** @internal */
const unsafeRoots$1 = () => Array.from(globalScope.roots);
/** @internal */
const roots$1 = /* @__PURE__ */ sync$3(unsafeRoots$1);
/** @internal */
const status$1 = (self) => self.status;
/** @internal */
const succeed$6 = (value) => done$4(succeed$7(value));
const void_$1 = /* @__PURE__ */ succeed$6(void 0);
/** @internal */
const currentFiberURI = "effect/FiberCurrent";
/** @internal */
const getCurrentFiber$1 = () => fromNullable$2(globalThis[currentFiberURI]);

//#endregion
//#region ../../node_modules/.bun/effect@3.17.14/node_modules/effect/dist/esm/internal/logger.js
/** @internal */
const LoggerSymbolKey = "effect/Logger";
/** @internal */
const LoggerTypeId = /* @__PURE__ */ Symbol.for(LoggerSymbolKey);
const loggerVariance = {
	_Message: (_) => _,
	_Output: (_) => _
};
/** @internal */
const makeLogger = (log$2) => ({
	[LoggerTypeId]: loggerVariance,
	log: log$2,
	pipe() {
		return pipeArguments(this, arguments);
	}
});
/** @internal */
const map$4 = /* @__PURE__ */ dual(2, (self, f) => makeLogger((options) => f(self.log(options))));
/** @internal */
const none$3 = {
	[LoggerTypeId]: loggerVariance,
	log: constVoid,
	pipe() {
		return pipeArguments(this, arguments);
	}
};
/**
* Match strings that do not contain any whitespace characters, double quotes,
* or equal signs.
*
* @internal
*/
const textOnly = /^[^\s"=]*$/;
/**
* Used by both {@link stringLogger} and {@link logfmtLogger} to render a log
* message.
*
* @internal
*/
const format$1 = (quoteValue, whitespace) => ({ annotations: annotations$1, cause: cause$2, date, fiberId: fiberId$2, logLevel, message, spans }) => {
	const formatValue = (value) => value.match(textOnly) ? value : quoteValue(value);
	const format$3 = (label, value) => `${formatLabel(label)}=${formatValue(value)}`;
	const append$3 = (label, value) => " " + format$3(label, value);
	let out = format$3("timestamp", date.toISOString());
	out += append$3("level", logLevel.label);
	out += append$3("fiber", threadName$1(fiberId$2));
	const messages = ensure(message);
	for (let i = 0; i < messages.length; i++) out += append$3("message", toStringUnknown(messages[i], whitespace));
	if (!isEmptyType(cause$2)) out += append$3("cause", pretty$2(cause$2, { renderErrorCause: true }));
	for (const span$1 of spans) out += " " + render$1(date.getTime())(span$1);
	for (const [label, value] of annotations$1) out += append$3(label, toStringUnknown(value, whitespace));
	return out;
};
/** @internal */
const escapeDoubleQuotes = (s) => `"${s.replace(/\\([\s\S])|(")/g, "\\$1$2")}"`;
/** @internal */
const stringLogger = /* @__PURE__ */ makeLogger(/* @__PURE__ */ format$1(escapeDoubleQuotes));
/** @internal */
const structuredLogger = /* @__PURE__ */ makeLogger(({ annotations: annotations$1, cause: cause$2, date, fiberId: fiberId$2, logLevel, message, spans }) => {
	const now = date.getTime();
	const annotationsObj = {};
	const spansObj = {};
	if (size$5(annotations$1) > 0) for (const [k, v] of annotations$1) annotationsObj[k] = structuredMessage(v);
	if (isCons(spans)) for (const span$1 of spans) spansObj[span$1.label] = now - span$1.startTime;
	const messageArr = ensure(message);
	return {
		message: messageArr.length === 1 ? structuredMessage(messageArr[0]) : messageArr.map(structuredMessage),
		logLevel: logLevel.label,
		timestamp: date.toISOString(),
		cause: isEmpty$6(cause$2) ? void 0 : pretty$2(cause$2, { renderErrorCause: true }),
		annotations: annotationsObj,
		spans: spansObj,
		fiberId: threadName$1(fiberId$2)
	};
});
/** @internal */
const structuredMessage = (u) => {
	switch (typeof u) {
		case "bigint":
		case "function":
		case "symbol": return String(u);
		default: return toJSON(u);
	}
};
/** @internal */
const jsonLogger = /* @__PURE__ */ map$4(structuredLogger, stringifyCircular);
const colors = {
	bold: "1",
	red: "31",
	green: "32",
	yellow: "33",
	blue: "34",
	cyan: "36",
	white: "37",
	gray: "90",
	black: "30",
	bgBrightRed: "101"
};
const logLevelColors = {
	None: [],
	All: [],
	Trace: [colors.gray],
	Debug: [colors.blue],
	Info: [colors.green],
	Warning: [colors.yellow],
	Error: [colors.red],
	Fatal: [colors.bgBrightRed, colors.black]
};
const hasProcessStdout = typeof process === "object" && process !== null && typeof process.stdout === "object" && process.stdout !== null;
const processStdoutIsTTY = hasProcessStdout && process.stdout.isTTY === true;
const hasProcessStdoutOrDeno = hasProcessStdout || "Deno" in globalThis;

//#endregion
//#region ../../node_modules/.bun/effect@3.17.14/node_modules/effect/dist/esm/internal/metric/boundaries.js
/** @internal */
const MetricBoundariesSymbolKey = "effect/MetricBoundaries";
/** @internal */
const MetricBoundariesTypeId = /* @__PURE__ */ Symbol.for(MetricBoundariesSymbolKey);
/** @internal */
var MetricBoundariesImpl = class {
	values;
	[MetricBoundariesTypeId] = MetricBoundariesTypeId;
	constructor(values$6) {
		this.values = values$6;
		this._hash = pipe(string(MetricBoundariesSymbolKey), combine$11(array$1(this.values)));
	}
	_hash;
	[symbol$1]() {
		return this._hash;
	}
	[symbol](u) {
		return isMetricBoundaries(u) && equals(this.values, u.values);
	}
	pipe() {
		return pipeArguments(this, arguments);
	}
};
/** @internal */
const isMetricBoundaries = (u) => hasProperty(u, MetricBoundariesTypeId);
/** @internal */
const fromIterable$4 = (iterable) => {
	const values$6 = pipe(iterable, appendAll$2(of$3(Number.POSITIVE_INFINITY)), dedupe);
	return new MetricBoundariesImpl(values$6);
};
/** @internal */
const exponential = (options) => pipe(makeBy(options.count - 1, (i) => options.start * Math.pow(options.factor, i)), unsafeFromArray, fromIterable$4);

//#endregion
//#region ../../node_modules/.bun/effect@3.17.14/node_modules/effect/dist/esm/internal/metric/keyType.js
/** @internal */
const MetricKeyTypeSymbolKey = "effect/MetricKeyType";
/** @internal */
const MetricKeyTypeTypeId = /* @__PURE__ */ Symbol.for(MetricKeyTypeSymbolKey);
/** @internal */
const CounterKeyTypeSymbolKey = "effect/MetricKeyType/Counter";
/** @internal */
const CounterKeyTypeTypeId = /* @__PURE__ */ Symbol.for(CounterKeyTypeSymbolKey);
/** @internal */
const FrequencyKeyTypeSymbolKey = "effect/MetricKeyType/Frequency";
/** @internal */
const FrequencyKeyTypeTypeId = /* @__PURE__ */ Symbol.for(FrequencyKeyTypeSymbolKey);
/** @internal */
const GaugeKeyTypeSymbolKey = "effect/MetricKeyType/Gauge";
/** @internal */
const GaugeKeyTypeTypeId = /* @__PURE__ */ Symbol.for(GaugeKeyTypeSymbolKey);
/** @internal */
const HistogramKeyTypeSymbolKey = "effect/MetricKeyType/Histogram";
/** @internal */
const HistogramKeyTypeTypeId = /* @__PURE__ */ Symbol.for(HistogramKeyTypeSymbolKey);
/** @internal */
const SummaryKeyTypeSymbolKey = "effect/MetricKeyType/Summary";
/** @internal */
const SummaryKeyTypeTypeId = /* @__PURE__ */ Symbol.for(SummaryKeyTypeSymbolKey);
const metricKeyTypeVariance = {
	_In: (_) => _,
	_Out: (_) => _
};
/** @internal */
var CounterKeyType = class {
	incremental;
	bigint;
	[MetricKeyTypeTypeId] = metricKeyTypeVariance;
	[CounterKeyTypeTypeId] = CounterKeyTypeTypeId;
	constructor(incremental, bigint) {
		this.incremental = incremental;
		this.bigint = bigint;
		this._hash = string(CounterKeyTypeSymbolKey);
	}
	_hash;
	[symbol$1]() {
		return this._hash;
	}
	[symbol](that) {
		return isCounterKey(that);
	}
	pipe() {
		return pipeArguments(this, arguments);
	}
};
const FrequencyKeyTypeHash = /* @__PURE__ */ string(FrequencyKeyTypeSymbolKey);
/** @internal */
var FrequencyKeyType = class {
	preregisteredWords;
	[MetricKeyTypeTypeId] = metricKeyTypeVariance;
	[FrequencyKeyTypeTypeId] = FrequencyKeyTypeTypeId;
	constructor(preregisteredWords) {
		this.preregisteredWords = preregisteredWords;
	}
	[symbol$1]() {
		return FrequencyKeyTypeHash;
	}
	[symbol](that) {
		return isFrequencyKey(that);
	}
	pipe() {
		return pipeArguments(this, arguments);
	}
};
const GaugeKeyTypeHash = /* @__PURE__ */ string(GaugeKeyTypeSymbolKey);
/** @internal */
var GaugeKeyType = class {
	bigint;
	[MetricKeyTypeTypeId] = metricKeyTypeVariance;
	[GaugeKeyTypeTypeId] = GaugeKeyTypeTypeId;
	constructor(bigint) {
		this.bigint = bigint;
	}
	[symbol$1]() {
		return GaugeKeyTypeHash;
	}
	[symbol](that) {
		return isGaugeKey(that);
	}
	pipe() {
		return pipeArguments(this, arguments);
	}
};
/** @internal */
var HistogramKeyType = class {
	boundaries;
	[MetricKeyTypeTypeId] = metricKeyTypeVariance;
	[HistogramKeyTypeTypeId] = HistogramKeyTypeTypeId;
	constructor(boundaries) {
		this.boundaries = boundaries;
		this._hash = pipe(string(HistogramKeyTypeSymbolKey), combine$11(hash(this.boundaries)));
	}
	_hash;
	[symbol$1]() {
		return this._hash;
	}
	[symbol](that) {
		return isHistogramKey(that) && equals(this.boundaries, that.boundaries);
	}
	pipe() {
		return pipeArguments(this, arguments);
	}
};
/** @internal */
var SummaryKeyType = class {
	maxAge;
	maxSize;
	error;
	quantiles;
	[MetricKeyTypeTypeId] = metricKeyTypeVariance;
	[SummaryKeyTypeTypeId] = SummaryKeyTypeTypeId;
	constructor(maxAge, maxSize, error, quantiles) {
		this.maxAge = maxAge;
		this.maxSize = maxSize;
		this.error = error;
		this.quantiles = quantiles;
		this._hash = pipe(string(SummaryKeyTypeSymbolKey), combine$11(hash(this.maxAge)), combine$11(hash(this.maxSize)), combine$11(hash(this.error)), combine$11(array$1(this.quantiles)));
	}
	_hash;
	[symbol$1]() {
		return this._hash;
	}
	[symbol](that) {
		return isSummaryKey(that) && equals(this.maxAge, that.maxAge) && this.maxSize === that.maxSize && this.error === that.error && equals(this.quantiles, that.quantiles);
	}
	pipe() {
		return pipeArguments(this, arguments);
	}
};
/** @internal */
const counter$4 = (options) => new CounterKeyType(options?.incremental ?? false, options?.bigint ?? false);
/** @internal */
const histogram$4 = (boundaries) => {
	return new HistogramKeyType(boundaries);
};
/** @internal */
const isCounterKey = (u) => hasProperty(u, CounterKeyTypeTypeId);
/** @internal */
const isFrequencyKey = (u) => hasProperty(u, FrequencyKeyTypeTypeId);
/** @internal */
const isGaugeKey = (u) => hasProperty(u, GaugeKeyTypeTypeId);
/** @internal */
const isHistogramKey = (u) => hasProperty(u, HistogramKeyTypeTypeId);
/** @internal */
const isSummaryKey = (u) => hasProperty(u, SummaryKeyTypeTypeId);

//#endregion
//#region ../../node_modules/.bun/effect@3.17.14/node_modules/effect/dist/esm/internal/metric/key.js
/** @internal */
const MetricKeySymbolKey = "effect/MetricKey";
/** @internal */
const MetricKeyTypeId = /* @__PURE__ */ Symbol.for(MetricKeySymbolKey);
const metricKeyVariance = { _Type: (_) => _ };
const arrayEquivilence = /* @__PURE__ */ getEquivalence$3(equals);
/** @internal */
var MetricKeyImpl = class {
	name;
	keyType;
	description;
	tags;
	[MetricKeyTypeId] = metricKeyVariance;
	constructor(name, keyType, description, tags = []) {
		this.name = name;
		this.keyType = keyType;
		this.description = description;
		this.tags = tags;
		this._hash = pipe(string(this.name + this.description), combine$11(hash(this.keyType)), combine$11(array$1(this.tags)));
	}
	_hash;
	[symbol$1]() {
		return this._hash;
	}
	[symbol](u) {
		return isMetricKey(u) && this.name === u.name && equals(this.keyType, u.keyType) && equals(this.description, u.description) && arrayEquivilence(this.tags, u.tags);
	}
	pipe() {
		return pipeArguments(this, arguments);
	}
};
/** @internal */
const isMetricKey = (u) => hasProperty(u, MetricKeyTypeId);
/** @internal */
const counter$3 = (name, options) => new MetricKeyImpl(name, counter$4(options), fromNullable$2(options?.description));
/** @internal */
const histogram$3 = (name, boundaries, description) => new MetricKeyImpl(name, histogram$4(boundaries), fromNullable$2(description));
/** @internal */
const taggedWithLabels$1 = /* @__PURE__ */ dual(2, (self, extraTags) => extraTags.length === 0 ? self : new MetricKeyImpl(self.name, self.keyType, self.description, union$8(self.tags, extraTags)));

//#endregion
//#region ../../node_modules/.bun/effect@3.17.14/node_modules/effect/dist/esm/MutableHashMap.js
const TypeId$6 = /* @__PURE__ */ Symbol.for("effect/MutableHashMap");
const MutableHashMapProto = {
	[TypeId$6]: TypeId$6,
	[Symbol.iterator]() {
		return new MutableHashMapIterator(this);
	},
	toString() {
		return format(this.toJSON());
	},
	toJSON() {
		return {
			_id: "MutableHashMap",
			values: Array.from(this).map(toJSON)
		};
	},
	[NodeInspectSymbol]() {
		return this.toJSON();
	},
	pipe() {
		return pipeArguments(this, arguments);
	}
};
var MutableHashMapIterator = class MutableHashMapIterator {
	self;
	referentialIterator;
	bucketIterator;
	constructor(self) {
		this.self = self;
		this.referentialIterator = self.referential[Symbol.iterator]();
	}
	next() {
		if (this.bucketIterator !== void 0) return this.bucketIterator.next();
		const result = this.referentialIterator.next();
		if (result.done) {
			this.bucketIterator = new BucketIterator(this.self.buckets.values());
			return this.next();
		}
		return result;
	}
	[Symbol.iterator]() {
		return new MutableHashMapIterator(this.self);
	}
};
var BucketIterator = class {
	backing;
	constructor(backing) {
		this.backing = backing;
	}
	currentBucket;
	next() {
		if (this.currentBucket === void 0) {
			const result$1 = this.backing.next();
			if (result$1.done) return result$1;
			this.currentBucket = result$1.value[Symbol.iterator]();
		}
		const result = this.currentBucket.next();
		if (result.done) {
			this.currentBucket = void 0;
			return this.next();
		}
		return result;
	}
};
/**
* @since 2.0.0
* @category constructors
*/
const empty$8 = () => {
	const self = Object.create(MutableHashMapProto);
	self.referential = /* @__PURE__ */ new Map();
	self.buckets = /* @__PURE__ */ new Map();
	self.bucketsSize = 0;
	return self;
};
/**
* @since 2.0.0
* @category elements
*/
const get = /* @__PURE__ */ dual(2, (self, key) => {
	if (isEqual(key) === false) return self.referential.has(key) ? some$4(self.referential.get(key)) : none$7();
	const hash$1 = key[symbol$1]();
	const bucket = self.buckets.get(hash$1);
	if (bucket === void 0) return none$7();
	return getFromBucket(self, bucket, key);
});
const getFromBucket = (self, bucket, key, remove$7 = false) => {
	for (let i = 0, len = bucket.length; i < len; i++) if (key[symbol](bucket[i][0])) {
		const value = bucket[i][1];
		if (remove$7) {
			bucket.splice(i, 1);
			self.bucketsSize--;
		}
		return some$4(value);
	}
	return none$7();
};
/**
* @since 2.0.0
* @category elements
*/
const has$2 = /* @__PURE__ */ dual(2, (self, key) => isSome(get(self, key)));
/**
* @since 2.0.0
*/
const set = /* @__PURE__ */ dual(3, (self, key, value) => {
	if (isEqual(key) === false) {
		self.referential.set(key, value);
		return self;
	}
	const hash$1 = key[symbol$1]();
	const bucket = self.buckets.get(hash$1);
	if (bucket === void 0) {
		self.buckets.set(hash$1, [[key, value]]);
		self.bucketsSize++;
		return self;
	}
	removeFromBucket(self, bucket, key);
	bucket.push([key, value]);
	self.bucketsSize++;
	return self;
});
const removeFromBucket = (self, bucket, key) => {
	for (let i = 0, len = bucket.length; i < len; i++) if (key[symbol](bucket[i][0])) {
		bucket.splice(i, 1);
		self.bucketsSize--;
		return;
	}
};
/**
* @since 2.0.0
*/
const remove$2 = /* @__PURE__ */ dual(2, (self, key) => {
	if (isEqual(key) === false) {
		self.referential.delete(key);
		return self;
	}
	const hash$1 = key[symbol$1]();
	const bucket = self.buckets.get(hash$1);
	if (bucket === void 0) return self;
	removeFromBucket(self, bucket, key);
	if (bucket.length === 0) self.buckets.delete(hash$1);
	return self;
});
/**
* @since 2.0.0
* @category elements
*/
const size$4 = (self) => {
	return self.referential.size + self.bucketsSize;
};

//#endregion
//#region ../../node_modules/.bun/effect@3.17.14/node_modules/effect/dist/esm/internal/metric/state.js
/** @internal */
const MetricStateSymbolKey = "effect/MetricState";
/** @internal */
const MetricStateTypeId = /* @__PURE__ */ Symbol.for(MetricStateSymbolKey);
/** @internal */
const CounterStateSymbolKey = "effect/MetricState/Counter";
/** @internal */
const CounterStateTypeId = /* @__PURE__ */ Symbol.for(CounterStateSymbolKey);
/** @internal */
const FrequencyStateSymbolKey = "effect/MetricState/Frequency";
/** @internal */
const FrequencyStateTypeId = /* @__PURE__ */ Symbol.for(FrequencyStateSymbolKey);
/** @internal */
const GaugeStateSymbolKey = "effect/MetricState/Gauge";
/** @internal */
const GaugeStateTypeId = /* @__PURE__ */ Symbol.for(GaugeStateSymbolKey);
/** @internal */
const HistogramStateSymbolKey = "effect/MetricState/Histogram";
/** @internal */
const HistogramStateTypeId = /* @__PURE__ */ Symbol.for(HistogramStateSymbolKey);
/** @internal */
const SummaryStateSymbolKey = "effect/MetricState/Summary";
/** @internal */
const SummaryStateTypeId = /* @__PURE__ */ Symbol.for(SummaryStateSymbolKey);
const metricStateVariance = { _A: (_) => _ };
/** @internal */
var CounterState = class {
	count;
	[MetricStateTypeId] = metricStateVariance;
	[CounterStateTypeId] = CounterStateTypeId;
	constructor(count) {
		this.count = count;
	}
	[symbol$1]() {
		return pipe(hash(CounterStateSymbolKey), combine$11(hash(this.count)), cached$2(this));
	}
	[symbol](that) {
		return isCounterState(that) && this.count === that.count;
	}
	pipe() {
		return pipeArguments(this, arguments);
	}
};
const arrayEquals = /* @__PURE__ */ getEquivalence$3(equals);
/** @internal */
var FrequencyState = class {
	occurrences;
	[MetricStateTypeId] = metricStateVariance;
	[FrequencyStateTypeId] = FrequencyStateTypeId;
	constructor(occurrences) {
		this.occurrences = occurrences;
	}
	_hash;
	[symbol$1]() {
		return pipe(string(FrequencyStateSymbolKey), combine$11(array$1(fromIterable$10(this.occurrences.entries()))), cached$2(this));
	}
	[symbol](that) {
		return isFrequencyState(that) && arrayEquals(fromIterable$10(this.occurrences.entries()), fromIterable$10(that.occurrences.entries()));
	}
	pipe() {
		return pipeArguments(this, arguments);
	}
};
/** @internal */
var GaugeState = class {
	value;
	[MetricStateTypeId] = metricStateVariance;
	[GaugeStateTypeId] = GaugeStateTypeId;
	constructor(value) {
		this.value = value;
	}
	[symbol$1]() {
		return pipe(hash(GaugeStateSymbolKey), combine$11(hash(this.value)), cached$2(this));
	}
	[symbol](u) {
		return isGaugeState(u) && this.value === u.value;
	}
	pipe() {
		return pipeArguments(this, arguments);
	}
};
/** @internal */
var HistogramState = class {
	buckets;
	count;
	min;
	max;
	sum;
	[MetricStateTypeId] = metricStateVariance;
	[HistogramStateTypeId] = HistogramStateTypeId;
	constructor(buckets, count, min$2, max$4, sum) {
		this.buckets = buckets;
		this.count = count;
		this.min = min$2;
		this.max = max$4;
		this.sum = sum;
	}
	[symbol$1]() {
		return pipe(hash(HistogramStateSymbolKey), combine$11(hash(this.buckets)), combine$11(hash(this.count)), combine$11(hash(this.min)), combine$11(hash(this.max)), combine$11(hash(this.sum)), cached$2(this));
	}
	[symbol](that) {
		return isHistogramState(that) && equals(this.buckets, that.buckets) && this.count === that.count && this.min === that.min && this.max === that.max && this.sum === that.sum;
	}
	pipe() {
		return pipeArguments(this, arguments);
	}
};
/** @internal */
var SummaryState = class {
	error;
	quantiles;
	count;
	min;
	max;
	sum;
	[MetricStateTypeId] = metricStateVariance;
	[SummaryStateTypeId] = SummaryStateTypeId;
	constructor(error, quantiles, count, min$2, max$4, sum) {
		this.error = error;
		this.quantiles = quantiles;
		this.count = count;
		this.min = min$2;
		this.max = max$4;
		this.sum = sum;
	}
	[symbol$1]() {
		return pipe(hash(SummaryStateSymbolKey), combine$11(hash(this.error)), combine$11(hash(this.quantiles)), combine$11(hash(this.count)), combine$11(hash(this.min)), combine$11(hash(this.max)), combine$11(hash(this.sum)), cached$2(this));
	}
	[symbol](that) {
		return isSummaryState(that) && this.error === that.error && equals(this.quantiles, that.quantiles) && this.count === that.count && this.min === that.min && this.max === that.max && this.sum === that.sum;
	}
	pipe() {
		return pipeArguments(this, arguments);
	}
};
/** @internal */
const counter$2 = (count) => new CounterState(count);
/** @internal */
const frequency$1 = (occurrences) => {
	return new FrequencyState(occurrences);
};
/** @internal */
const gauge$1 = (count) => new GaugeState(count);
/** @internal */
const histogram$2 = (options) => new HistogramState(options.buckets, options.count, options.min, options.max, options.sum);
/** @internal */
const summary$1 = (options) => new SummaryState(options.error, options.quantiles, options.count, options.min, options.max, options.sum);
/** @internal */
const isCounterState = (u) => hasProperty(u, CounterStateTypeId);
/**
* @since 2.0.0
* @category refinements
*/
const isFrequencyState = (u) => hasProperty(u, FrequencyStateTypeId);
/**
* @since 2.0.0
* @category refinements
*/
const isGaugeState = (u) => hasProperty(u, GaugeStateTypeId);
/**
* @since 2.0.0
* @category refinements
*/
const isHistogramState = (u) => hasProperty(u, HistogramStateTypeId);
/**
* @since 2.0.0
* @category refinements
*/
const isSummaryState = (u) => hasProperty(u, SummaryStateTypeId);

//#endregion
//#region ../../node_modules/.bun/effect@3.17.14/node_modules/effect/dist/esm/internal/metric/hook.js
/** @internal */
const MetricHookSymbolKey = "effect/MetricHook";
/** @internal */
const MetricHookTypeId = /* @__PURE__ */ Symbol.for(MetricHookSymbolKey);
const metricHookVariance = {
	_In: (_) => _,
	_Out: (_) => _
};
/** @internal */
const make$15 = (options) => ({
	[MetricHookTypeId]: metricHookVariance,
	pipe() {
		return pipeArguments(this, arguments);
	},
	...options
});
const bigint0 = /* @__PURE__ */ BigInt(0);
/** @internal */
const counter$1 = (key) => {
	let sum = key.keyType.bigint ? bigint0 : 0;
	const canUpdate = key.keyType.incremental ? key.keyType.bigint ? (value) => value >= bigint0 : (value) => value >= 0 : (_value) => true;
	const update$5 = (value) => {
		if (canUpdate(value)) sum = sum + value;
	};
	return make$15({
		get: () => counter$2(sum),
		update: update$5,
		modify: update$5
	});
};
/** @internal */
const frequency = (key) => {
	const values$6 = /* @__PURE__ */ new Map();
	for (const word of key.keyType.preregisteredWords) values$6.set(word, 0);
	const update$5 = (word) => {
		const slotCount = values$6.get(word) ?? 0;
		values$6.set(word, slotCount + 1);
	};
	return make$15({
		get: () => frequency$1(values$6),
		update: update$5,
		modify: update$5
	});
};
/** @internal */
const gauge = (_key, startAt) => {
	let value = startAt;
	return make$15({
		get: () => gauge$1(value),
		update: (v) => {
			value = v;
		},
		modify: (v) => {
			value = value + v;
		}
	});
};
/** @internal */
const histogram$1 = (key) => {
	const bounds = key.keyType.boundaries.values;
	const size$9 = bounds.length;
	const values$6 = new Uint32Array(size$9 + 1);
	const boundaries = new Float64Array(size$9);
	let count = 0;
	let sum = 0;
	let min$2 = Number.MAX_VALUE;
	let max$4 = Number.MIN_VALUE;
	pipe(bounds, sort(Order$3), map$14((n, i) => {
		boundaries[i] = n;
	}));
	const update$5 = (value) => {
		let from = 0;
		let to = size$9;
		while (from !== to) {
			const mid = Math.floor(from + (to - from) / 2);
			const boundary = boundaries[mid];
			if (value <= boundary) to = mid;
			else from = mid;
			if (to === from + 1) if (value <= boundaries[from]) to = from;
			else from = to;
		}
		values$6[from] = values$6[from] + 1;
		count = count + 1;
		sum = sum + value;
		if (value < min$2) min$2 = value;
		if (value > max$4) max$4 = value;
	};
	const getBuckets = () => {
		const builder = allocate(size$9);
		let cumulated = 0;
		for (let i = 0; i < size$9; i++) {
			const boundary = boundaries[i];
			const value = values$6[i];
			cumulated = cumulated + value;
			builder[i] = [boundary, cumulated];
		}
		return builder;
	};
	return make$15({
		get: () => histogram$2({
			buckets: getBuckets(),
			count,
			min: min$2,
			max: max$4,
			sum
		}),
		update: update$5,
		modify: update$5
	});
};
/** @internal */
const summary = (key) => {
	const { error, maxAge, maxSize, quantiles } = key.keyType;
	const sortedQuantiles = pipe(quantiles, sort(Order$3));
	const values$6 = allocate(maxSize);
	let head$4 = 0;
	let count = 0;
	let sum = 0;
	let min$2 = 0;
	let max$4 = 0;
	const snapshot = (now) => {
		const builder = [];
		let i = 0;
		while (i !== maxSize - 1) {
			const item = values$6[i];
			if (item != null) {
				const [t, v] = item;
				const age = millis(now - t);
				if (greaterThanOrEqualTo$1(age, zero) && lessThanOrEqualTo$1(age, maxAge)) builder.push(v);
			}
			i = i + 1;
		}
		return calculateQuantiles(error, sortedQuantiles, sort(builder, Order$3));
	};
	const observe = (value, timestamp) => {
		if (maxSize > 0) {
			head$4 = head$4 + 1;
			const target = head$4 % maxSize;
			values$6[target] = [timestamp, value];
		}
		min$2 = count === 0 ? value : Math.min(min$2, value);
		max$4 = count === 0 ? value : Math.max(max$4, value);
		count = count + 1;
		sum = sum + value;
	};
	return make$15({
		get: () => summary$1({
			error,
			quantiles: snapshot(Date.now()),
			count,
			min: min$2,
			max: max$4,
			sum
		}),
		update: ([value, timestamp]) => observe(value, timestamp),
		modify: ([value, timestamp]) => observe(value, timestamp)
	});
};
/** @internal */
const calculateQuantiles = (error, sortedQuantiles, sortedSamples) => {
	const sampleCount = sortedSamples.length;
	if (!isNonEmptyReadonlyArray(sortedQuantiles)) return empty$32();
	const head$4 = sortedQuantiles[0];
	const tail = sortedQuantiles.slice(1);
	const resolvedHead = resolveQuantile(error, sampleCount, none$7(), 0, head$4, sortedSamples);
	const resolved = of$4(resolvedHead);
	tail.forEach((quantile) => {
		resolved.push(resolveQuantile(error, sampleCount, resolvedHead.value, resolvedHead.consumed, quantile, resolvedHead.rest));
	});
	return map$14(resolved, (rq) => [rq.quantile, rq.value]);
};
/** @internal */
const resolveQuantile = (error, sampleCount, current, consumed, quantile, rest) => {
	let error_1 = error;
	let sampleCount_1 = sampleCount;
	let current_1 = current;
	let consumed_1 = consumed;
	let quantile_1 = quantile;
	let rest_1 = rest;
	let error_2 = error;
	let sampleCount_2 = sampleCount;
	let current_2 = current;
	let consumed_2 = consumed;
	let quantile_2 = quantile;
	let rest_2 = rest;
	while (1) {
		if (!isNonEmptyReadonlyArray(rest_1)) return {
			quantile: quantile_1,
			value: none$7(),
			consumed: consumed_1,
			rest: []
		};
		if (quantile_1 === 1) return {
			quantile: quantile_1,
			value: some$4(lastNonEmpty(rest_1)),
			consumed: consumed_1 + rest_1.length,
			rest: []
		};
		const headValue = headNonEmpty$1(rest_1);
		const sameHead = span(rest_1, (n) => n === headValue);
		const desired = quantile_1 * sampleCount_1;
		const allowedError = error_1 / 2 * desired;
		const candConsumed = consumed_1 + sameHead[0].length;
		const candError = Math.abs(candConsumed - desired);
		if (candConsumed < desired - allowedError) {
			error_2 = error_1;
			sampleCount_2 = sampleCount_1;
			current_2 = head$3(rest_1);
			consumed_2 = candConsumed;
			quantile_2 = quantile_1;
			rest_2 = sameHead[1];
			error_1 = error_2;
			sampleCount_1 = sampleCount_2;
			current_1 = current_2;
			consumed_1 = consumed_2;
			quantile_1 = quantile_2;
			rest_1 = rest_2;
			continue;
		}
		if (candConsumed > desired + allowedError) {
			const valueToReturn = isNone$2(current_1) ? some$4(headValue) : current_1;
			return {
				quantile: quantile_1,
				value: valueToReturn,
				consumed: consumed_1,
				rest: rest_1
			};
		}
		switch (current_1._tag) {
			case "None":
				error_2 = error_1;
				sampleCount_2 = sampleCount_1;
				current_2 = head$3(rest_1);
				consumed_2 = candConsumed;
				quantile_2 = quantile_1;
				rest_2 = sameHead[1];
				error_1 = error_2;
				sampleCount_1 = sampleCount_2;
				current_1 = current_2;
				consumed_1 = consumed_2;
				quantile_1 = quantile_2;
				rest_1 = rest_2;
				continue;
			case "Some": {
				const prevError = Math.abs(desired - current_1.value);
				if (candError < prevError) {
					error_2 = error_1;
					sampleCount_2 = sampleCount_1;
					current_2 = head$3(rest_1);
					consumed_2 = candConsumed;
					quantile_2 = quantile_1;
					rest_2 = sameHead[1];
					error_1 = error_2;
					sampleCount_1 = sampleCount_2;
					current_1 = current_2;
					consumed_1 = consumed_2;
					quantile_1 = quantile_2;
					rest_1 = rest_2;
					continue;
				}
				return {
					quantile: quantile_1,
					value: some$4(current_1.value),
					consumed: consumed_1,
					rest: rest_1
				};
			}
		}
	}
	throw new Error("BUG: MetricHook.resolveQuantiles - please report an issue at https://github.com/Effect-TS/effect/issues");
};

//#endregion
//#region ../../node_modules/.bun/effect@3.17.14/node_modules/effect/dist/esm/internal/metric/pair.js
/** @internal */
const MetricPairSymbolKey = "effect/MetricPair";
/** @internal */
const MetricPairTypeId = /* @__PURE__ */ Symbol.for(MetricPairSymbolKey);
const metricPairVariance = { _Type: (_) => _ };
/** @internal */
const unsafeMake$1 = (metricKey, metricState) => {
	return {
		[MetricPairTypeId]: metricPairVariance,
		metricKey,
		metricState,
		pipe() {
			return pipeArguments(this, arguments);
		}
	};
};

//#endregion
//#region ../../node_modules/.bun/effect@3.17.14/node_modules/effect/dist/esm/internal/metric/registry.js
/** @internal */
const MetricRegistrySymbolKey = "effect/MetricRegistry";
/** @internal */
const MetricRegistryTypeId = /* @__PURE__ */ Symbol.for(MetricRegistrySymbolKey);
/** @internal */
var MetricRegistryImpl = class {
	[MetricRegistryTypeId] = MetricRegistryTypeId;
	map = /* @__PURE__ */ empty$8();
	snapshot() {
		const result = [];
		for (const [key, hook] of this.map) result.push(unsafeMake$1(key, hook.get()));
		return result;
	}
	get(key) {
		const hook = pipe(this.map, get(key), getOrUndefined);
		if (hook == null) {
			if (isCounterKey(key.keyType)) return this.getCounter(key);
			if (isGaugeKey(key.keyType)) return this.getGauge(key);
			if (isFrequencyKey(key.keyType)) return this.getFrequency(key);
			if (isHistogramKey(key.keyType)) return this.getHistogram(key);
			if (isSummaryKey(key.keyType)) return this.getSummary(key);
			throw new Error("BUG: MetricRegistry.get - unknown MetricKeyType - please report an issue at https://github.com/Effect-TS/effect/issues");
		} else return hook;
	}
	getCounter(key) {
		let value = pipe(this.map, get(key), getOrUndefined);
		if (value == null) {
			const counter$5 = counter$1(key);
			if (!pipe(this.map, has$2(key))) pipe(this.map, set(key, counter$5));
			value = counter$5;
		}
		return value;
	}
	getFrequency(key) {
		let value = pipe(this.map, get(key), getOrUndefined);
		if (value == null) {
			const frequency$2 = frequency(key);
			if (!pipe(this.map, has$2(key))) pipe(this.map, set(key, frequency$2));
			value = frequency$2;
		}
		return value;
	}
	getGauge(key) {
		let value = pipe(this.map, get(key), getOrUndefined);
		if (value == null) {
			const gauge$2 = gauge(key, key.keyType.bigint ? BigInt(0) : 0);
			if (!pipe(this.map, has$2(key))) pipe(this.map, set(key, gauge$2));
			value = gauge$2;
		}
		return value;
	}
	getHistogram(key) {
		let value = pipe(this.map, get(key), getOrUndefined);
		if (value == null) {
			const histogram$5 = histogram$1(key);
			if (!pipe(this.map, has$2(key))) pipe(this.map, set(key, histogram$5));
			value = histogram$5;
		}
		return value;
	}
	getSummary(key) {
		let value = pipe(this.map, get(key), getOrUndefined);
		if (value == null) {
			const summary$2 = summary(key);
			if (!pipe(this.map, has$2(key))) pipe(this.map, set(key, summary$2));
			value = summary$2;
		}
		return value;
	}
};
/** @internal */
const make$14 = () => {
	return new MetricRegistryImpl();
};

//#endregion
//#region ../../node_modules/.bun/effect@3.17.14/node_modules/effect/dist/esm/internal/metric.js
/** @internal */
const MetricSymbolKey = "effect/Metric";
/** @internal */
const MetricTypeId = /* @__PURE__ */ Symbol.for(MetricSymbolKey);
const metricVariance = {
	_Type: (_) => _,
	_In: (_) => _,
	_Out: (_) => _
};
/** @internal */
const globalMetricRegistry = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/Metric/globalMetricRegistry"), () => make$14());
/** @internal */
const make$13 = function(keyType, unsafeUpdate, unsafeValue, unsafeModify) {
	const metric = Object.assign((effect) => tap$1(effect, (a) => update$1(metric, a)), {
		[MetricTypeId]: metricVariance,
		keyType,
		unsafeUpdate,
		unsafeValue,
		unsafeModify,
		register() {
			this.unsafeValue([]);
			return this;
		},
		pipe() {
			return pipeArguments(this, arguments);
		}
	});
	return metric;
};
/** @internal */
const counter = (name, options) => fromMetricKey(counter$3(name, options));
/** @internal */
const fromMetricKey = (key) => {
	let untaggedHook;
	const hookCache = /* @__PURE__ */ new WeakMap();
	const hook = (extraTags) => {
		if (extraTags.length === 0) {
			if (untaggedHook !== void 0) return untaggedHook;
			untaggedHook = globalMetricRegistry.get(key);
			return untaggedHook;
		}
		let hook$1 = hookCache.get(extraTags);
		if (hook$1 !== void 0) return hook$1;
		hook$1 = globalMetricRegistry.get(taggedWithLabels$1(key, extraTags));
		hookCache.set(extraTags, hook$1);
		return hook$1;
	};
	return make$13(key.keyType, (input, extraTags) => hook(extraTags).update(input), (extraTags) => hook(extraTags).get(), (input, extraTags) => hook(extraTags).modify(input));
};
/** @internal */
const histogram = (name, boundaries, description) => fromMetricKey(histogram$3(name, boundaries, description));
/** @internal */
const tagged$2 = /* @__PURE__ */ dual(3, (self, key, value) => taggedWithLabels(self, [make$16(key, value)]));
/** @internal */
const taggedWithLabels = /* @__PURE__ */ dual(2, (self, extraTags) => {
	return make$13(self.keyType, (input, extraTags1) => self.unsafeUpdate(input, union$8(extraTags, extraTags1)), (extraTags1) => self.unsafeValue(union$8(extraTags, extraTags1)), (input, extraTags1) => self.unsafeModify(input, union$8(extraTags, extraTags1)));
});
const update$1 = /* @__PURE__ */ dual(2, (self, input) => fiberRefGetWith(currentMetricLabels, (tags) => sync$3(() => self.unsafeUpdate(input, tags))));

//#endregion
//#region ../../node_modules/.bun/effect@3.17.14/node_modules/effect/dist/esm/internal/request.js
/** @internal */
const RequestSymbolKey = "effect/Request";
/** @internal */
const RequestTypeId$1 = /* @__PURE__ */ Symbol.for(RequestSymbolKey);
const requestVariance = {
	_E: (_) => _,
	_A: (_) => _
};
const RequestPrototype = {
	...StructuralPrototype,
	[RequestTypeId$1]: requestVariance
};
/** @internal */
const isRequest$1 = (u) => hasProperty(u, RequestTypeId$1);
/** @internal */
const of$1 = () => (args$1) => Object.assign(Object.create(RequestPrototype), args$1);
/** @internal */
const tagged$1 = (tag) => (args$1) => {
	const request$1 = Object.assign(Object.create(RequestPrototype), args$1);
	request$1._tag = tag;
	return request$1;
};
/** @internal */
const Class$1 = /* @__PURE__ */ function() {
	function Class$5(args$1) {
		if (args$1) Object.assign(this, args$1);
	}
	Class$5.prototype = RequestPrototype;
	return Class$5;
}();
/** @internal */
const TaggedClass$1 = (tag) => {
	return class TaggedClass$2 extends Class$1 {
		_tag = tag;
	};
};
/** @internal */
const complete$3 = /* @__PURE__ */ dual(2, (self, result) => fiberRefGetWith(currentRequestMap, (map$17) => sync$3(() => {
	if (map$17.has(self)) {
		const entry = map$17.get(self);
		if (!entry.state.completed) {
			entry.state.completed = true;
			deferredUnsafeDone(entry.result, result);
		}
	}
})));
/** @internal */
const completeEffect$1 = /* @__PURE__ */ dual(2, (self, effect) => matchEffect$2(effect, {
	onFailure: (error) => complete$3(self, exitFail(error)),
	onSuccess: (value) => complete$3(self, exitSucceed$1(value))
}));
/** @internal */
const fail$5 = /* @__PURE__ */ dual(2, (self, error) => complete$3(self, exitFail(error)));
/** @internal */
const failCause$4 = /* @__PURE__ */ dual(2, (self, cause$2) => complete$3(self, exitFailCause$1(cause$2)));
/** @internal */
const succeed$5 = /* @__PURE__ */ dual(2, (self, value) => complete$3(self, exitSucceed$1(value)));
/** @internal */
var Listeners = class {
	count = 0;
	observers = /* @__PURE__ */ new Set();
	interrupted = false;
	addObserver(f) {
		this.observers.add(f);
	}
	removeObserver(f) {
		this.observers.delete(f);
	}
	increment() {
		this.count++;
		this.observers.forEach((f) => f(this.count));
	}
	decrement() {
		this.count--;
		this.observers.forEach((f) => f(this.count));
	}
};

//#endregion
//#region ../../node_modules/.bun/effect@3.17.14/node_modules/effect/dist/esm/internal/redBlackTree/iterator.js
/** @internal */
const Direction$1 = {
	Forward: 0,
	Backward: 1
};
/** @internal */
var RedBlackTreeIterator = class RedBlackTreeIterator {
	self;
	stack;
	direction;
	count = 0;
	constructor(self, stack, direction) {
		this.self = self;
		this.stack = stack;
		this.direction = direction;
	}
	/**
	* Clones the iterator
	*/
	clone() {
		return new RedBlackTreeIterator(this.self, this.stack.slice(), this.direction);
	}
	/**
	* Reverse the traversal direction
	*/
	reversed() {
		return new RedBlackTreeIterator(this.self, this.stack.slice(), this.direction === Direction$1.Forward ? Direction$1.Backward : Direction$1.Forward);
	}
	/**
	* Iterator next
	*/
	next() {
		const entry = this.entry;
		this.count++;
		if (this.direction === Direction$1.Forward) this.moveNext();
		else this.movePrev();
		switch (entry._tag) {
			case "None": return {
				done: true,
				value: this.count
			};
			case "Some": return {
				done: false,
				value: entry.value
			};
		}
	}
	/**
	* Returns the key
	*/
	get key() {
		if (this.stack.length > 0) return some$4(this.stack[this.stack.length - 1].key);
		return none$7();
	}
	/**
	* Returns the value
	*/
	get value() {
		if (this.stack.length > 0) return some$4(this.stack[this.stack.length - 1].value);
		return none$7();
	}
	/**
	* Returns the key
	*/
	get entry() {
		return map$15(last$2(this.stack), (node) => [node.key, node.value]);
	}
	/**
	* Returns the position of this iterator in the sorted list
	*/
	get index() {
		let idx = 0;
		const stack = this.stack;
		if (stack.length === 0) {
			const r = this.self._root;
			if (r != null) return r.count;
			return 0;
		} else if (stack[stack.length - 1].left != null) idx = stack[stack.length - 1].left.count;
		for (let s = stack.length - 2; s >= 0; --s) if (stack[s + 1] === stack[s].right) {
			++idx;
			if (stack[s].left != null) idx += stack[s].left.count;
		}
		return idx;
	}
	/**
	* Advances iterator to next element in list
	*/
	moveNext() {
		const stack = this.stack;
		if (stack.length === 0) return;
		let n = stack[stack.length - 1];
		if (n.right != null) {
			n = n.right;
			while (n != null) {
				stack.push(n);
				n = n.left;
			}
		} else {
			stack.pop();
			while (stack.length > 0 && stack[stack.length - 1].right === n) {
				n = stack[stack.length - 1];
				stack.pop();
			}
		}
	}
	/**
	* Checks if there is a next element
	*/
	get hasNext() {
		const stack = this.stack;
		if (stack.length === 0) return false;
		if (stack[stack.length - 1].right != null) return true;
		for (let s = stack.length - 1; s > 0; --s) if (stack[s - 1].left === stack[s]) return true;
		return false;
	}
	/**
	* Advances iterator to previous element in list
	*/
	movePrev() {
		const stack = this.stack;
		if (stack.length === 0) return;
		let n = stack[stack.length - 1];
		if (n != null && n.left != null) {
			n = n.left;
			while (n != null) {
				stack.push(n);
				n = n.right;
			}
		} else {
			stack.pop();
			while (stack.length > 0 && stack[stack.length - 1].left === n) {
				n = stack[stack.length - 1];
				stack.pop();
			}
		}
	}
	/**
	* Checks if there is a previous element
	*/
	get hasPrev() {
		const stack = this.stack;
		if (stack.length === 0) return false;
		if (stack[stack.length - 1].left != null) return true;
		for (let s = stack.length - 1; s > 0; --s) if (stack[s - 1].right === stack[s]) return true;
		return false;
	}
};

//#endregion
//#region ../../node_modules/.bun/effect@3.17.14/node_modules/effect/dist/esm/internal/redBlackTree/node.js
/** @internal */
const Color = {
	Red: 0,
	Black: 1
};
/** @internal */
const clone = ({ color, count, key, left: left$2, right: right$2, value }) => ({
	color,
	key,
	value,
	left: left$2,
	right: right$2,
	count
});
/** @internal */
function swap(n, v) {
	n.key = v.key;
	n.value = v.value;
	n.left = v.left;
	n.right = v.right;
	n.color = v.color;
	n.count = v.count;
}
/** @internal */
const repaint = ({ count, key, left: left$2, right: right$2, value }, color) => ({
	color,
	key,
	value,
	left: left$2,
	right: right$2,
	count
});
/** @internal */
const recount = (node) => {
	node.count = 1 + (node.left?.count ?? 0) + (node.right?.count ?? 0);
};

//#endregion
//#region ../../node_modules/.bun/effect@3.17.14/node_modules/effect/dist/esm/internal/redBlackTree.js
const RedBlackTreeSymbolKey = "effect/RedBlackTree";
/** @internal */
const RedBlackTreeTypeId = /* @__PURE__ */ Symbol.for(RedBlackTreeSymbolKey);
const redBlackTreeVariance = {
	_Key: (_) => _,
	_Value: (_) => _
};
const RedBlackTreeProto = {
	[RedBlackTreeTypeId]: redBlackTreeVariance,
	[symbol$1]() {
		let hash$1 = hash(RedBlackTreeSymbolKey);
		for (const item of this) hash$1 ^= pipe(hash(item[0]), combine$11(hash(item[1])));
		return cached$2(this, hash$1);
	},
	[symbol](that) {
		if (isRedBlackTree$1(that)) {
			if ((this._root?.count ?? 0) !== (that._root?.count ?? 0)) return false;
			const entries$2 = Array.from(that);
			return Array.from(this).every((itemSelf, i) => {
				const itemThat = entries$2[i];
				return equals(itemSelf[0], itemThat[0]) && equals(itemSelf[1], itemThat[1]);
			});
		}
		return false;
	},
	[Symbol.iterator]() {
		const stack = [];
		let n = this._root;
		while (n != null) {
			stack.push(n);
			n = n.left;
		}
		return new RedBlackTreeIterator(this, stack, Direction$1.Forward);
	},
	toString() {
		return format(this.toJSON());
	},
	toJSON() {
		return {
			_id: "RedBlackTree",
			values: Array.from(this).map(toJSON)
		};
	},
	[NodeInspectSymbol]() {
		return this.toJSON();
	},
	pipe() {
		return pipeArguments(this, arguments);
	}
};
const makeImpl = (ord, root) => {
	const tree = Object.create(RedBlackTreeProto);
	tree._ord = ord;
	tree._root = root;
	return tree;
};
/** @internal */
const isRedBlackTree$1 = (u) => hasProperty(u, RedBlackTreeTypeId);
/** @internal */
const empty$7 = (ord) => makeImpl(ord, void 0);
/** @internal */
const fromIterable$3 = /* @__PURE__ */ dual(2, (entries$2, ord) => {
	let tree = empty$7(ord);
	for (const [key, value] of entries$2) tree = insert$1(tree, key, value);
	return tree;
});
/** @internal */
const make$12 = (ord) => (...entries$2) => {
	return fromIterable$3(entries$2, ord);
};
/** @internal */
const atBackwards = /* @__PURE__ */ dual(2, (self, index) => at$1(self, index, Direction$1.Backward));
/** @internal */
const atForwards = /* @__PURE__ */ dual(2, (self, index) => at$1(self, index, Direction$1.Forward));
const at$1 = (self, index, direction) => {
	return { [Symbol.iterator]: () => {
		if (index < 0) return new RedBlackTreeIterator(self, [], direction);
		let node = self._root;
		const stack = [];
		while (node !== void 0) {
			stack.push(node);
			if (node.left !== void 0) {
				if (index < node.left.count) {
					node = node.left;
					continue;
				}
				index -= node.left.count;
			}
			if (!index) return new RedBlackTreeIterator(self, stack, direction);
			index -= 1;
			if (node.right !== void 0) {
				if (index >= node.right.count) break;
				node = node.right;
			} else break;
		}
		return new RedBlackTreeIterator(self, [], direction);
	} };
};
/** @internal */
const findAll$1 = /* @__PURE__ */ dual(2, (self, key) => {
	const stack = [];
	let node = self._root;
	let result = empty$31();
	while (node !== void 0 || stack.length > 0) if (node) {
		stack.push(node);
		node = node.left;
	} else {
		const current = stack.pop();
		if (equals(key, current.key)) result = prepend$1(current.value)(result);
		node = current.right;
	}
	return result;
});
/** @internal */
const findFirst$2 = /* @__PURE__ */ dual(2, (self, key) => {
	const cmp = self._ord;
	let node = self._root;
	while (node !== void 0) {
		const d = cmp(key, node.key);
		if (equals(key, node.key)) return some$4(node.value);
		if (d <= 0) node = node.left;
		else node = node.right;
	}
	return none$7();
});
/** @internal */
const first$1 = (self) => {
	let node = self._root;
	let current = self._root;
	while (node !== void 0) {
		current = node;
		node = node.left;
	}
	return current ? some$4([current.key, current.value]) : none$7();
};
/** @internal */
const getAt$1 = /* @__PURE__ */ dual(2, (self, index) => {
	if (index < 0) return none$7();
	let root = self._root;
	let node = void 0;
	while (root !== void 0) {
		node = root;
		if (root.left) {
			if (index < root.left.count) {
				root = root.left;
				continue;
			}
			index -= root.left.count;
		}
		if (!index) return some$4([node.key, node.value]);
		index -= 1;
		if (root.right) {
			if (index >= root.right.count) break;
			root = root.right;
		} else break;
	}
	return none$7();
});
/** @internal */
const getOrder$2 = (tree) => tree._ord;
/** @internal */
const has$1 = /* @__PURE__ */ dual(2, (self, key) => isSome(findFirst$2(self, key)));
/** @internal */
const insert$1 = /* @__PURE__ */ dual(3, (self, key, value) => {
	const cmp = self._ord;
	let n = self._root;
	const n_stack = [];
	const d_stack = [];
	while (n != null) {
		const d = cmp(key, n.key);
		n_stack.push(n);
		d_stack.push(d);
		if (d <= 0) n = n.left;
		else n = n.right;
	}
	n_stack.push({
		color: Color.Red,
		key,
		value,
		left: void 0,
		right: void 0,
		count: 1
	});
	for (let s = n_stack.length - 2; s >= 0; --s) {
		const n2 = n_stack[s];
		if (d_stack[s] <= 0) n_stack[s] = {
			color: n2.color,
			key: n2.key,
			value: n2.value,
			left: n_stack[s + 1],
			right: n2.right,
			count: n2.count + 1
		};
		else n_stack[s] = {
			color: n2.color,
			key: n2.key,
			value: n2.value,
			left: n2.left,
			right: n_stack[s + 1],
			count: n2.count + 1
		};
	}
	for (let s = n_stack.length - 1; s > 1; --s) {
		const p = n_stack[s - 1];
		const n3 = n_stack[s];
		if (p.color === Color.Black || n3.color === Color.Black) break;
		const pp = n_stack[s - 2];
		if (pp.left === p) if (p.left === n3) {
			const y = pp.right;
			if (y && y.color === Color.Red) {
				p.color = Color.Black;
				pp.right = repaint(y, Color.Black);
				pp.color = Color.Red;
				s -= 1;
			} else {
				pp.color = Color.Red;
				pp.left = p.right;
				p.color = Color.Black;
				p.right = pp;
				n_stack[s - 2] = p;
				n_stack[s - 1] = n3;
				recount(pp);
				recount(p);
				if (s >= 3) {
					const ppp = n_stack[s - 3];
					if (ppp.left === pp) ppp.left = p;
					else ppp.right = p;
				}
				break;
			}
		} else {
			const y = pp.right;
			if (y && y.color === Color.Red) {
				p.color = Color.Black;
				pp.right = repaint(y, Color.Black);
				pp.color = Color.Red;
				s -= 1;
			} else {
				p.right = n3.left;
				pp.color = Color.Red;
				pp.left = n3.right;
				n3.color = Color.Black;
				n3.left = p;
				n3.right = pp;
				n_stack[s - 2] = n3;
				n_stack[s - 1] = p;
				recount(pp);
				recount(p);
				recount(n3);
				if (s >= 3) {
					const ppp = n_stack[s - 3];
					if (ppp.left === pp) ppp.left = n3;
					else ppp.right = n3;
				}
				break;
			}
		}
		else if (p.right === n3) {
			const y = pp.left;
			if (y && y.color === Color.Red) {
				p.color = Color.Black;
				pp.left = repaint(y, Color.Black);
				pp.color = Color.Red;
				s -= 1;
			} else {
				pp.color = Color.Red;
				pp.right = p.left;
				p.color = Color.Black;
				p.left = pp;
				n_stack[s - 2] = p;
				n_stack[s - 1] = n3;
				recount(pp);
				recount(p);
				if (s >= 3) {
					const ppp = n_stack[s - 3];
					if (ppp.right === pp) ppp.right = p;
					else ppp.left = p;
				}
				break;
			}
		} else {
			const y = pp.left;
			if (y && y.color === Color.Red) {
				p.color = Color.Black;
				pp.left = repaint(y, Color.Black);
				pp.color = Color.Red;
				s -= 1;
			} else {
				p.left = n3.right;
				pp.color = Color.Red;
				pp.right = n3.left;
				n3.color = Color.Black;
				n3.right = p;
				n3.left = pp;
				n_stack[s - 2] = n3;
				n_stack[s - 1] = p;
				recount(pp);
				recount(p);
				recount(n3);
				if (s >= 3) {
					const ppp = n_stack[s - 3];
					if (ppp.right === pp) ppp.right = n3;
					else ppp.left = n3;
				}
				break;
			}
		}
	}
	n_stack[0].color = Color.Black;
	return makeImpl(self._ord, n_stack[0]);
});
/** @internal */
const keysForward = (self) => keys$1(self, Direction$1.Forward);
/** @internal */
const keysBackward = (self) => keys$1(self, Direction$1.Backward);
const keys$1 = (self, direction) => {
	const begin = self[Symbol.iterator]();
	let count = 0;
	return {
		[Symbol.iterator]: () => keys$1(self, direction),
		next: () => {
			count++;
			const entry = begin.key;
			if (direction === Direction$1.Forward) begin.moveNext();
			else begin.movePrev();
			switch (entry._tag) {
				case "None": return {
					done: true,
					value: count
				};
				case "Some": return {
					done: false,
					value: entry.value
				};
			}
		}
	};
};
/** @internal */
const last$1 = (self) => {
	let node = self._root;
	let current = self._root;
	while (node !== void 0) {
		current = node;
		node = node.right;
	}
	return current ? some$4([current.key, current.value]) : none$7();
};
/** @internal */
const reversed$1 = (self) => {
	return { [Symbol.iterator]: () => {
		const stack = [];
		let node = self._root;
		while (node !== void 0) {
			stack.push(node);
			node = node.right;
		}
		return new RedBlackTreeIterator(self, stack, Direction$1.Backward);
	} };
};
/** @internal */
const greaterThanBackwards = /* @__PURE__ */ dual(2, (self, key) => greaterThan$1(self, key, Direction$1.Backward));
/** @internal */
const greaterThanForwards = /* @__PURE__ */ dual(2, (self, key) => greaterThan$1(self, key, Direction$1.Forward));
const greaterThan$1 = (self, key, direction) => {
	return { [Symbol.iterator]: () => {
		const cmp = self._ord;
		let node = self._root;
		const stack = [];
		let last_ptr = 0;
		while (node !== void 0) {
			const d = cmp(key, node.key);
			stack.push(node);
			if (d < 0) last_ptr = stack.length;
			if (d < 0) node = node.left;
			else node = node.right;
		}
		stack.length = last_ptr;
		return new RedBlackTreeIterator(self, stack, direction);
	} };
};
/** @internal */
const greaterThanEqualBackwards = /* @__PURE__ */ dual(2, (self, key) => greaterThanEqual$1(self, key, Direction$1.Backward));
/** @internal */
const greaterThanEqualForwards = /* @__PURE__ */ dual(2, (self, key) => greaterThanEqual$1(self, key, Direction$1.Forward));
const greaterThanEqual$1 = (self, key, direction = Direction$1.Forward) => {
	return { [Symbol.iterator]: () => {
		const cmp = self._ord;
		let node = self._root;
		const stack = [];
		let last_ptr = 0;
		while (node !== void 0) {
			const d = cmp(key, node.key);
			stack.push(node);
			if (d <= 0) last_ptr = stack.length;
			if (d <= 0) node = node.left;
			else node = node.right;
		}
		stack.length = last_ptr;
		return new RedBlackTreeIterator(self, stack, direction);
	} };
};
/** @internal */
const lessThanBackwards = /* @__PURE__ */ dual(2, (self, key) => lessThan$5(self, key, Direction$1.Backward));
/** @internal */
const lessThanForwards = /* @__PURE__ */ dual(2, (self, key) => lessThan$5(self, key, Direction$1.Forward));
const lessThan$5 = (self, key, direction) => {
	return { [Symbol.iterator]: () => {
		const cmp = self._ord;
		let node = self._root;
		const stack = [];
		let last_ptr = 0;
		while (node !== void 0) {
			const d = cmp(key, node.key);
			stack.push(node);
			if (d > 0) last_ptr = stack.length;
			if (d <= 0) node = node.left;
			else node = node.right;
		}
		stack.length = last_ptr;
		return new RedBlackTreeIterator(self, stack, direction);
	} };
};
/** @internal */
const lessThanEqualBackwards = /* @__PURE__ */ dual(2, (self, key) => lessThanEqual$1(self, key, Direction$1.Backward));
/** @internal */
const lessThanEqualForwards = /* @__PURE__ */ dual(2, (self, key) => lessThanEqual$1(self, key, Direction$1.Forward));
const lessThanEqual$1 = (self, key, direction) => {
	return { [Symbol.iterator]: () => {
		const cmp = self._ord;
		let node = self._root;
		const stack = [];
		let last_ptr = 0;
		while (node !== void 0) {
			const d = cmp(key, node.key);
			stack.push(node);
			if (d >= 0) last_ptr = stack.length;
			if (d < 0) node = node.left;
			else node = node.right;
		}
		stack.length = last_ptr;
		return new RedBlackTreeIterator(self, stack, direction);
	} };
};
/** @internal */
const forEach$3 = /* @__PURE__ */ dual(2, (self, f) => {
	const root = self._root;
	if (root !== void 0) visitFull(root, (key, value) => {
		f(key, value);
		return none$7();
	});
});
/** @internal */
const forEachGreaterThanEqual$1 = /* @__PURE__ */ dual(3, (self, min$2, f) => {
	const root = self._root;
	const ord = self._ord;
	if (root !== void 0) visitGreaterThanEqual(root, min$2, ord, (key, value) => {
		f(key, value);
		return none$7();
	});
});
/** @internal */
const forEachLessThan$1 = /* @__PURE__ */ dual(3, (self, max$4, f) => {
	const root = self._root;
	const ord = self._ord;
	if (root !== void 0) visitLessThan(root, max$4, ord, (key, value) => {
		f(key, value);
		return none$7();
	});
});
/** @internal */
const forEachBetween$1 = /* @__PURE__ */ dual(2, (self, { body, max: max$4, min: min$2 }) => {
	const root = self._root;
	const ord = self._ord;
	if (root) visitBetween(root, min$2, max$4, ord, (key, value) => {
		body(key, value);
		return none$7();
	});
});
/** @internal */
const reduce$2 = /* @__PURE__ */ dual(3, (self, zero$1, f) => {
	let accumulator = zero$1;
	for (const entry of self) accumulator = f(accumulator, entry[1], entry[0]);
	return accumulator;
});
/** @internal */
const removeFirst$1 = /* @__PURE__ */ dual(2, (self, key) => {
	if (!has$1(self, key)) return self;
	const ord = self._ord;
	const cmp = ord;
	let node = self._root;
	const stack = [];
	while (node !== void 0) {
		const d = cmp(key, node.key);
		stack.push(node);
		if (equals(key, node.key)) node = void 0;
		else if (d <= 0) node = node.left;
		else node = node.right;
	}
	if (stack.length === 0) return self;
	const cstack = new Array(stack.length);
	let n = stack[stack.length - 1];
	cstack[cstack.length - 1] = {
		color: n.color,
		key: n.key,
		value: n.value,
		left: n.left,
		right: n.right,
		count: n.count
	};
	for (let i = stack.length - 2; i >= 0; --i) {
		n = stack[i];
		if (n.left === stack[i + 1]) cstack[i] = {
			color: n.color,
			key: n.key,
			value: n.value,
			left: cstack[i + 1],
			right: n.right,
			count: n.count
		};
		else cstack[i] = {
			color: n.color,
			key: n.key,
			value: n.value,
			left: n.left,
			right: cstack[i + 1],
			count: n.count
		};
	}
	n = cstack[cstack.length - 1];
	if (n.left !== void 0 && n.right !== void 0) {
		const split = cstack.length;
		n = n.left;
		while (n.right != null) {
			cstack.push(n);
			n = n.right;
		}
		const v = cstack[split - 1];
		cstack.push({
			color: n.color,
			key: v.key,
			value: v.value,
			left: n.left,
			right: n.right,
			count: n.count
		});
		cstack[split - 1].key = n.key;
		cstack[split - 1].value = n.value;
		for (let i = cstack.length - 2; i >= split; --i) {
			n = cstack[i];
			cstack[i] = {
				color: n.color,
				key: n.key,
				value: n.value,
				left: n.left,
				right: cstack[i + 1],
				count: n.count
			};
		}
		cstack[split - 1].left = cstack[split];
	}
	n = cstack[cstack.length - 1];
	if (n.color === Color.Red) {
		const p = cstack[cstack.length - 2];
		if (p.left === n) p.left = void 0;
		else if (p.right === n) p.right = void 0;
		cstack.pop();
		for (let i = 0; i < cstack.length; ++i) cstack[i].count--;
		return makeImpl(ord, cstack[0]);
	} else if (n.left !== void 0 || n.right !== void 0) {
		if (n.left !== void 0) swap(n, n.left);
		else if (n.right !== void 0) swap(n, n.right);
		n.color = Color.Black;
		for (let i = 0; i < cstack.length - 1; ++i) cstack[i].count--;
		return makeImpl(ord, cstack[0]);
	} else if (cstack.length === 1) return makeImpl(ord, void 0);
	else {
		for (let i = 0; i < cstack.length; ++i) cstack[i].count--;
		const parent = cstack[cstack.length - 2];
		fixDoubleBlack(cstack);
		if (parent.left === n) parent.left = void 0;
		else parent.right = void 0;
	}
	return makeImpl(ord, cstack[0]);
});
/** @internal */
const size$3 = (self) => self._root?.count ?? 0;
/** @internal */
const valuesForward = (self) => values$1(self, Direction$1.Forward);
/** @internal */
const valuesBackward = (self) => values$1(self, Direction$1.Backward);
/** @internal */
const values$1 = (self, direction) => {
	const begin = self[Symbol.iterator]();
	let count = 0;
	return {
		[Symbol.iterator]: () => values$1(self, direction),
		next: () => {
			count++;
			const entry = begin.value;
			if (direction === Direction$1.Forward) begin.moveNext();
			else begin.movePrev();
			switch (entry._tag) {
				case "None": return {
					done: true,
					value: count
				};
				case "Some": return {
					done: false,
					value: entry.value
				};
			}
		}
	};
};
const visitFull = (node, visit) => {
	let current = node;
	let stack = void 0;
	let done$8 = false;
	while (!done$8) if (current != null) {
		stack = make$41(current, stack);
		current = current.left;
	} else if (stack != null) {
		const value = visit(stack.value.key, stack.value.value);
		if (isSome(value)) return value;
		current = stack.value.right;
		stack = stack.previous;
	} else done$8 = true;
	return none$7();
};
const visitGreaterThanEqual = (node, min$2, ord, visit) => {
	let current = node;
	let stack = void 0;
	let done$8 = false;
	while (!done$8) if (current !== void 0) {
		stack = make$41(current, stack);
		if (ord(min$2, current.key) <= 0) current = current.left;
		else current = void 0;
	} else if (stack !== void 0) {
		if (ord(min$2, stack.value.key) <= 0) {
			const value = visit(stack.value.key, stack.value.value);
			if (isSome(value)) return value;
		}
		current = stack.value.right;
		stack = stack.previous;
	} else done$8 = true;
	return none$7();
};
const visitLessThan = (node, max$4, ord, visit) => {
	let current = node;
	let stack = void 0;
	let done$8 = false;
	while (!done$8) if (current !== void 0) {
		stack = make$41(current, stack);
		current = current.left;
	} else if (stack !== void 0 && ord(max$4, stack.value.key) > 0) {
		const value = visit(stack.value.key, stack.value.value);
		if (isSome(value)) return value;
		current = stack.value.right;
		stack = stack.previous;
	} else done$8 = true;
	return none$7();
};
const visitBetween = (node, min$2, max$4, ord, visit) => {
	let current = node;
	let stack = void 0;
	let done$8 = false;
	while (!done$8) if (current !== void 0) {
		stack = make$41(current, stack);
		if (ord(min$2, current.key) <= 0) current = current.left;
		else current = void 0;
	} else if (stack !== void 0 && ord(max$4, stack.value.key) > 0) {
		if (ord(min$2, stack.value.key) <= 0) {
			const value = visit(stack.value.key, stack.value.value);
			if (isSome(value)) return value;
		}
		current = stack.value.right;
		stack = stack.previous;
	} else done$8 = true;
	return none$7();
};
/**
* Fix up a double black node in a Red-Black Tree.
*/
const fixDoubleBlack = (stack) => {
	let n, p, s, z;
	for (let i = stack.length - 1; i >= 0; --i) {
		n = stack[i];
		if (i === 0) {
			n.color = Color.Black;
			return;
		}
		p = stack[i - 1];
		if (p.left === n) {
			s = p.right;
			if (s !== void 0 && s.right !== void 0 && s.right.color === Color.Red) {
				s = p.right = clone(s);
				z = s.right = clone(s.right);
				p.right = s.left;
				s.left = p;
				s.right = z;
				s.color = p.color;
				n.color = Color.Black;
				p.color = Color.Black;
				z.color = Color.Black;
				recount(p);
				recount(s);
				if (i > 1) {
					const pp = stack[i - 2];
					if (pp.left === p) pp.left = s;
					else pp.right = s;
				}
				stack[i - 1] = s;
				return;
			} else if (s !== void 0 && s.left !== void 0 && s.left.color === Color.Red) {
				s = p.right = clone(s);
				z = s.left = clone(s.left);
				p.right = z.left;
				s.left = z.right;
				z.left = p;
				z.right = s;
				z.color = p.color;
				p.color = Color.Black;
				s.color = Color.Black;
				n.color = Color.Black;
				recount(p);
				recount(s);
				recount(z);
				if (i > 1) {
					const pp = stack[i - 2];
					if (pp.left === p) pp.left = z;
					else pp.right = z;
				}
				stack[i - 1] = z;
				return;
			}
			if (s !== void 0 && s.color === Color.Black) if (p.color === Color.Red) {
				p.color = Color.Black;
				p.right = repaint(s, Color.Red);
				return;
			} else {
				p.right = repaint(s, Color.Red);
				continue;
			}
			else if (s !== void 0) {
				s = clone(s);
				p.right = s.left;
				s.left = p;
				s.color = p.color;
				p.color = Color.Red;
				recount(p);
				recount(s);
				if (i > 1) {
					const pp = stack[i - 2];
					if (pp.left === p) pp.left = s;
					else pp.right = s;
				}
				stack[i - 1] = s;
				stack[i] = p;
				if (i + 1 < stack.length) stack[i + 1] = n;
				else stack.push(n);
				i = i + 2;
			}
		} else {
			s = p.left;
			if (s !== void 0 && s.left !== void 0 && s.left.color === Color.Red) {
				s = p.left = clone(s);
				z = s.left = clone(s.left);
				p.left = s.right;
				s.right = p;
				s.left = z;
				s.color = p.color;
				n.color = Color.Black;
				p.color = Color.Black;
				z.color = Color.Black;
				recount(p);
				recount(s);
				if (i > 1) {
					const pp = stack[i - 2];
					if (pp.right === p) pp.right = s;
					else pp.left = s;
				}
				stack[i - 1] = s;
				return;
			} else if (s !== void 0 && s.right !== void 0 && s.right.color === Color.Red) {
				s = p.left = clone(s);
				z = s.right = clone(s.right);
				p.left = z.right;
				s.right = z.left;
				z.right = p;
				z.left = s;
				z.color = p.color;
				p.color = Color.Black;
				s.color = Color.Black;
				n.color = Color.Black;
				recount(p);
				recount(s);
				recount(z);
				if (i > 1) {
					const pp = stack[i - 2];
					if (pp.right === p) pp.right = z;
					else pp.left = z;
				}
				stack[i - 1] = z;
				return;
			}
			if (s !== void 0 && s.color === Color.Black) if (p.color === Color.Red) {
				p.color = Color.Black;
				p.left = repaint(s, Color.Red);
				return;
			} else {
				p.left = repaint(s, Color.Red);
				continue;
			}
			else if (s !== void 0) {
				s = clone(s);
				p.left = s.right;
				s.right = p;
				s.color = p.color;
				p.color = Color.Red;
				recount(p);
				recount(s);
				if (i > 1) {
					const pp = stack[i - 2];
					if (pp.right === p) pp.right = s;
					else pp.left = s;
				}
				stack[i - 1] = s;
				stack[i] = p;
				if (i + 1 < stack.length) stack[i + 1] = n;
				else stack.push(n);
				i = i + 2;
			}
		}
	}
};

//#endregion
//#region ../../node_modules/.bun/effect@3.17.14/node_modules/effect/dist/esm/RedBlackTree.js
RedBlackTreeTypeId;
/**
* @since 2.0.0
* @category constants
*/
const Direction = Direction$1;
/**
* @since 2.0.0
* @category refinements
*/
const isRedBlackTree = isRedBlackTree$1;
/**
* Creates an empty `RedBlackTree`.
*
* @since 2.0.0
* @category constructors
*/
const empty$6 = empty$7;
/**
* Creates a new `RedBlackTree` from an iterable collection of key/value pairs.
*
* @since 2.0.0
* @category constructors
*/
const fromIterable$2 = fromIterable$3;
/**
* Constructs a new `RedBlackTree` from the specified entries.
*
* @since 2.0.0
* @category constructors
*/
const make$11 = make$12;
/**
* Returns an iterator that points to the element at the specified index of the
* tree.
*
* **Note**: The iterator will run through elements in order.
*
* @since 2.0.0
* @category traversing
*/
const at = atForwards;
/**
* Returns an iterator that points to the element at the specified index of the
* tree.
*
* **Note**: The iterator will run through elements in reverse order.
*
* @since 2.0.0
* @category traversing
*/
const atReversed = atBackwards;
/**
* Finds all values in the tree associated with the specified key.
*
* @since 2.0.0
* @category elements
*/
const findAll = findAll$1;
/**
* Finds the first value in the tree associated with the specified key, if it exists.
*
* @category elements
* @since 2.0.0
*/
const findFirst$1 = findFirst$2;
/**
* Returns the first entry in the tree, if it exists.
*
* @since 2.0.0
* @category getters
*/
const first = first$1;
/**
* Returns the element at the specified index within the tree or `None` if the
* specified index does not exist.
*
* @since 2.0.0
* @category elements
*/
const getAt = getAt$1;
/**
* Gets the `Order<K>` that the `RedBlackTree<K, V>` is using.
*
* @since 2.0.0
* @category getters
*/
const getOrder$1 = getOrder$2;
/**
* Returns an iterator that traverse entries in order with keys greater than the
* specified key.
*
* @since 2.0.0
* @category traversing
*/
const greaterThan = greaterThanForwards;
/**
* Returns an iterator that traverse entries in reverse order with keys greater
* than the specified key.
*
* @since 2.0.0
* @category traversing
*/
const greaterThanReversed = greaterThanBackwards;
/**
* Returns an iterator that traverse entries in order with keys greater than or
* equal to the specified key.
*
* @since 2.0.0
* @category traversing
*/
const greaterThanEqual = greaterThanEqualForwards;
/**
* Returns an iterator that traverse entries in reverse order with keys greater
* than or equal to the specified key.
*
* @since 2.0.0
* @category traversing
*/
const greaterThanEqualReversed = greaterThanEqualBackwards;
/**
* Finds the item with key, if it exists.
*
* @since 2.0.0
* @category elements
*/
const has = has$1;
/**
* Insert a new item into the tree.
*
* @since 2.0.0
*/
const insert = insert$1;
/**
* Get all the keys present in the tree in order.
*
* @since 2.0.0
* @category getters
*/
const keys = keysForward;
/**
* Get all the keys present in the tree in reverse order.
*
* @since 2.0.0
* @category getters
*/
const keysReversed = keysBackward;
/**
* Returns the last entry in the tree, if it exists.
*
* @since 2.0.0
* @category getters
*/
const last = last$1;
/**
* Returns an iterator that traverse entries in order with keys less than the
* specified key.
*
* @since 2.0.0
* @category traversing
*/
const lessThan$4 = lessThanForwards;
/**
* Returns an iterator that traverse entries in reverse order with keys less
* than the specified key.
*
* @since 2.0.0
* @category traversing
*/
const lessThanReversed = lessThanBackwards;
/**
* Returns an iterator that traverse entries in order with keys less than or
* equal to the specified key.
*
* @since 2.0.0
* @category traversing
*/
const lessThanEqual = lessThanEqualForwards;
/**
* Returns an iterator that traverse entries in reverse order with keys less
* than or equal to the specified key.
*
* @since 2.0.0
* @category traversing
*/
const lessThanEqualReversed = lessThanEqualBackwards;
/**
* Execute the specified function for each node of the tree, in order.
*
* @since 2.0.0
* @category traversing
*/
const forEach$2 = forEach$3;
/**
* Visit each node of the tree in order with key greater then or equal to max.
*
* @since 2.0.0
* @category traversing
*/
const forEachGreaterThanEqual = forEachGreaterThanEqual$1;
/**
* Visit each node of the tree in order with key lower then max.
*
* @since 2.0.0
* @category traversing
*/
const forEachLessThan = forEachLessThan$1;
/**
* Visit each node of the tree in order with key lower than max and greater
* than or equal to min.
*
* @since 2.0.0
* @category traversing
*/
const forEachBetween = forEachBetween$1;
/**
* Reduce a state over the entries of the tree.
*
* @since 2.0.0
* @category folding
*/
const reduce$1 = reduce$2;
/**
* Removes the entry with the specified key, if it exists.
*
* @since 2.0.0
*/
const removeFirst = removeFirst$1;
/**
* Traverse the tree in reverse order.
*
* @since 2.0.0
* @category traversing
*/
const reversed = reversed$1;
/**
* Returns the size of the tree.
*
* @since 2.0.0
* @category getters
*/
const size$2 = size$3;
/**
* Get all values present in the tree in order.
*
* @since 2.0.0
* @category getters
*/
const values = valuesForward;
/**
* Get all values present in the tree in reverse order.
*
* @since 2.0.0
* @category getters
*/
const valuesReversed = valuesBackward;

//#endregion
//#region ../../node_modules/.bun/effect@3.17.14/node_modules/effect/dist/esm/SortedSet.js
const TypeId$5 = /* @__PURE__ */ Symbol.for("effect/SortedSet");
const SortedSetProto = {
	[TypeId$5]: { _A: (_) => _ },
	[symbol$1]() {
		return pipe(hash(this.keyTree), combine$11(hash(TypeId$5)), cached$2(this));
	},
	[symbol](that) {
		return isSortedSet(that) && equals(this.keyTree, that.keyTree);
	},
	[Symbol.iterator]() {
		return keys(this.keyTree);
	},
	toString() {
		return format(this.toJSON());
	},
	toJSON() {
		return {
			_id: "SortedSet",
			values: Array.from(this).map(toJSON)
		};
	},
	[NodeInspectSymbol]() {
		return this.toJSON();
	},
	pipe() {
		return pipeArguments(this, arguments);
	}
};
const fromTree = (keyTree) => {
	const a = Object.create(SortedSetProto);
	a.keyTree = keyTree;
	return a;
};
/**
* @since 2.0.0
* @category refinements
*/
const isSortedSet = (u) => hasProperty(u, TypeId$5);
/**
* @since 2.0.0
* @category elements
*/
const add = /* @__PURE__ */ dual(2, (self, value) => has(self.keyTree, value) ? self : fromTree(insert(self.keyTree, value, true)));
/**
* @since 2.0.0
* @category elements
*/
const remove$1 = /* @__PURE__ */ dual(2, (self, value) => fromTree(removeFirst(self.keyTree, value)));

//#endregion
//#region ../../node_modules/.bun/effect@3.17.14/node_modules/effect/dist/esm/internal/supervisor.js
/** @internal */
const SupervisorSymbolKey = "effect/Supervisor";
/** @internal */
const SupervisorTypeId = /* @__PURE__ */ Symbol.for(SupervisorSymbolKey);
/** @internal */
const supervisorVariance = { _T: (_) => _ };
/** @internal */
var ProxySupervisor = class ProxySupervisor {
	underlying;
	value0;
	[SupervisorTypeId] = supervisorVariance;
	constructor(underlying, value0) {
		this.underlying = underlying;
		this.value0 = value0;
	}
	get value() {
		return this.value0;
	}
	onStart(context$2, effect, parent, fiber) {
		this.underlying.onStart(context$2, effect, parent, fiber);
	}
	onEnd(value, fiber) {
		this.underlying.onEnd(value, fiber);
	}
	onEffect(fiber, effect) {
		this.underlying.onEffect(fiber, effect);
	}
	onSuspend(fiber) {
		this.underlying.onSuspend(fiber);
	}
	onResume(fiber) {
		this.underlying.onResume(fiber);
	}
	map(f) {
		return new ProxySupervisor(this, pipe(this.value, map$8(f)));
	}
	zip(right$2) {
		return new Zip(this, right$2);
	}
};
/** @internal */
var Zip = class Zip {
	left;
	right;
	_tag = "Zip";
	[SupervisorTypeId] = supervisorVariance;
	constructor(left$2, right$2) {
		this.left = left$2;
		this.right = right$2;
	}
	get value() {
		return zip$4(this.left.value, this.right.value);
	}
	onStart(context$2, effect, parent, fiber) {
		this.left.onStart(context$2, effect, parent, fiber);
		this.right.onStart(context$2, effect, parent, fiber);
	}
	onEnd(value, fiber) {
		this.left.onEnd(value, fiber);
		this.right.onEnd(value, fiber);
	}
	onEffect(fiber, effect) {
		this.left.onEffect(fiber, effect);
		this.right.onEffect(fiber, effect);
	}
	onSuspend(fiber) {
		this.left.onSuspend(fiber);
		this.right.onSuspend(fiber);
	}
	onResume(fiber) {
		this.left.onResume(fiber);
		this.right.onResume(fiber);
	}
	map(f) {
		return new ProxySupervisor(this, pipe(this.value, map$8(f)));
	}
	zip(right$2) {
		return new Zip(this, right$2);
	}
};
/** @internal */
const isZip = (self) => hasProperty(self, SupervisorTypeId) && isTagged(self, "Zip");
/** @internal */
var Track = class {
	[SupervisorTypeId] = supervisorVariance;
	fibers = /* @__PURE__ */ new Set();
	get value() {
		return sync$3(() => Array.from(this.fibers));
	}
	onStart(_context, _effect, _parent, fiber) {
		this.fibers.add(fiber);
	}
	onEnd(_value, fiber) {
		this.fibers.delete(fiber);
	}
	onEffect(_fiber, _effect) {}
	onSuspend(_fiber) {}
	onResume(_fiber) {}
	map(f) {
		return new ProxySupervisor(this, pipe(this.value, map$8(f)));
	}
	zip(right$2) {
		return new Zip(this, right$2);
	}
	onRun(execution, _fiber) {
		return execution();
	}
};
/** @internal */
var Const = class {
	effect;
	[SupervisorTypeId] = supervisorVariance;
	constructor(effect) {
		this.effect = effect;
	}
	get value() {
		return this.effect;
	}
	onStart(_context, _effect, _parent, _fiber) {}
	onEnd(_value, _fiber) {}
	onEffect(_fiber, _effect) {}
	onSuspend(_fiber) {}
	onResume(_fiber) {}
	map(f) {
		return new ProxySupervisor(this, pipe(this.value, map$8(f)));
	}
	zip(right$2) {
		return new Zip(this, right$2);
	}
	onRun(execution, _fiber) {
		return execution();
	}
};
var FibersIn = class {
	ref;
	[SupervisorTypeId] = supervisorVariance;
	constructor(ref) {
		this.ref = ref;
	}
	get value() {
		return sync$3(() => get$6(this.ref));
	}
	onStart(_context, _effect, _parent, fiber) {
		pipe(this.ref, set$4(pipe(get$6(this.ref), add(fiber))));
	}
	onEnd(_value, fiber) {
		pipe(this.ref, set$4(pipe(get$6(this.ref), remove$1(fiber))));
	}
	onEffect(_fiber, _effect) {}
	onSuspend(_fiber) {}
	onResume(_fiber) {}
	map(f) {
		return new ProxySupervisor(this, pipe(this.value, map$8(f)));
	}
	zip(right$2) {
		return new Zip(this, right$2);
	}
	onRun(execution, _fiber) {
		return execution();
	}
};
/** @internal */
const unsafeTrack = () => {
	return new Track();
};
/** @internal */
const track = /* @__PURE__ */ sync$3(unsafeTrack);
/** @internal */
const fromEffect$1 = (effect) => {
	return new Const(effect);
};
/** @internal */
const none$2 = /* @__PURE__ */ globalValue("effect/Supervisor/none", () => fromEffect$1(void_$4));

//#endregion
//#region ../../node_modules/.bun/effect@3.17.14/node_modules/effect/dist/esm/Differ.js
/**
* @since 2.0.0
* @category symbol
*/
const TypeId$4 = DifferTypeId;
ChunkPatchTypeId;
ContextPatchTypeId;
HashMapPatchTypeId;
HashSetPatchTypeId;
OrPatchTypeId;
ReadonlyArrayPatchTypeId;
/**
* Constructs a new `Differ`.
*
* @since 2.0.0
* @category constructors
*/
const make$10 = make$30;
/**
* Constructs a differ that knows how to diff `Env` values.
*
* @since 2.0.0
* @category constructors
*/
const environment = environment$1;
/**
* Constructs a differ that knows how to diff a `Chunk` of values given a
* differ that knows how to diff the values.
*
* @since 2.0.0
* @category constructors
*/
const chunk = chunk$1;
/**
* Constructs a differ that knows how to diff a `HashMap` of keys and values given
* a differ that knows how to diff the values.
*
* @since 2.0.0
* @category constructors
*/
const hashMap = hashMap$1;
/**
* Constructs a differ that knows how to diff a `HashSet` of values.
*
* @since 2.0.0
* @category constructors
*/
const hashSet = hashSet$1;
/**
* Combines this differ and the specified differ to produce a differ that
* knows how to diff the sum of their values.
*
* @since 2.0.0
*/
const orElseEither$1 = orElseEither$3;
/**
* Constructs a differ that knows how to diff a `ReadonlyArray` of values.
*
* @since 2.0.0
* @category constructors
*/
const readonlyArray = readonlyArray$1;
/**
* Transforms the type of values that this differ knows how to differ using
* the specified functions that map the new and old value types to each other.
*
* @since 2.0.0
*/
const transform$1 = transform$2;
/**
* Constructs a differ that just diffs two values by returning a function that
* sets the value to the new value. This differ does not support combining
* multiple updates to the value compositionally and should only be used when
* there is no compositional way to update them.
*
* @since 2.0.0
*/
const update = update$4;
/**
* A variant of `update` that allows specifying the function that will be used
* to combine old values with new values.
*
* @since 2.0.0
*/
const updateWith = updateWith$1;
/**
* Combines this differ and the specified differ to produce a new differ that
* knows how to diff the product of their values.
*
* @since 2.0.0
*/
const zip$2 = zip$5;

//#endregion
//#region ../../node_modules/.bun/effect@3.17.14/node_modules/effect/dist/esm/internal/supervisor/patch.js
/** @internal */
const OP_EMPTY = "Empty";
/** @internal */
const OP_ADD_SUPERVISOR = "AddSupervisor";
/** @internal */
const OP_REMOVE_SUPERVISOR = "RemoveSupervisor";
/** @internal */
const OP_AND_THEN = "AndThen";
/**
* The empty `SupervisorPatch`.
*
* @internal
*/
const empty$5 = { _tag: OP_EMPTY };
/**
* Combines two patches to produce a new patch that describes applying the
* updates from this patch and then the updates from the specified patch.
*
* @internal
*/
const combine = (self, that) => {
	return {
		_tag: OP_AND_THEN,
		first: self,
		second: that
	};
};
/**
* Applies a `SupervisorPatch` to a `Supervisor` to produce a new `Supervisor`.
*
* @internal
*/
const patch = (self, supervisor) => {
	return patchLoop(supervisor, of$3(self));
};
/** @internal */
const patchLoop = (_supervisor, _patches) => {
	let supervisor = _supervisor;
	let patches = _patches;
	while (isNonEmpty$5(patches)) {
		const head$4 = headNonEmpty(patches);
		switch (head$4._tag) {
			case OP_EMPTY:
				patches = tailNonEmpty(patches);
				break;
			case OP_ADD_SUPERVISOR:
				supervisor = supervisor.zip(head$4.supervisor);
				patches = tailNonEmpty(patches);
				break;
			case OP_REMOVE_SUPERVISOR:
				supervisor = removeSupervisor(supervisor, head$4.supervisor);
				patches = tailNonEmpty(patches);
				break;
			case OP_AND_THEN:
				patches = prepend$1(head$4.first)(prepend$1(head$4.second)(tailNonEmpty(patches)));
				break;
		}
	}
	return supervisor;
};
/** @internal */
const removeSupervisor = (self, that) => {
	if (equals(self, that)) return none$2;
	else if (isZip(self)) return removeSupervisor(self.left, that).zip(removeSupervisor(self.right, that));
	else return self;
};
/** @internal */
const toSet = (self) => {
	if (equals(self, none$2)) return empty$28();
	else if (isZip(self)) return pipe(toSet(self.left), union$5(toSet(self.right)));
	else return make$38(self);
};
/** @internal */
const diff = (oldValue, newValue) => {
	if (equals(oldValue, newValue)) return empty$5;
	const oldSupervisors = toSet(oldValue);
	const newSupervisors = toSet(newValue);
	const added = pipe(newSupervisors, difference(oldSupervisors), reduce$7(empty$5, (patch$11, supervisor) => combine(patch$11, {
		_tag: OP_ADD_SUPERVISOR,
		supervisor
	})));
	const removed = pipe(oldSupervisors, difference(newSupervisors), reduce$7(empty$5, (patch$11, supervisor) => combine(patch$11, {
		_tag: OP_REMOVE_SUPERVISOR,
		supervisor
	})));
	return combine(added, removed);
};
/** @internal */
const differ = /* @__PURE__ */ make$10({
	empty: empty$5,
	patch,
	combine,
	diff
});

//#endregion
//#region ../../node_modules/.bun/effect@3.17.14/node_modules/effect/dist/esm/internal/fiberRuntime.js
/** @internal */
const fiberStarted = /* @__PURE__ */ counter("effect_fiber_started", { incremental: true });
/** @internal */
const fiberActive = /* @__PURE__ */ counter("effect_fiber_active");
/** @internal */
const fiberSuccesses = /* @__PURE__ */ counter("effect_fiber_successes", { incremental: true });
/** @internal */
const fiberFailures = /* @__PURE__ */ counter("effect_fiber_failures", { incremental: true });
/** @internal */
const fiberLifetimes = /* @__PURE__ */ tagged$2(/* @__PURE__ */ histogram("effect_fiber_lifetimes", /* @__PURE__ */ exponential({
	start: .5,
	factor: 2,
	count: 35
})), "time_unit", "milliseconds");
/** @internal */
const EvaluationSignalContinue = "Continue";
/** @internal */
const EvaluationSignalDone = "Done";
/** @internal */
const EvaluationSignalYieldNow = "Yield";
const runtimeFiberVariance = {
	_E: (_) => _,
	_A: (_) => _
};
const absurd = (_) => {
	throw new Error(`BUG: FiberRuntime - ${toStringUnknown(_)} - please report an issue at https://github.com/Effect-TS/effect/issues`);
};
const YieldedOp = /* @__PURE__ */ Symbol.for("effect/internal/fiberRuntime/YieldedOp");
const yieldedOpChannel = /* @__PURE__ */ globalValue("effect/internal/fiberRuntime/yieldedOpChannel", () => ({ currentOp: null }));
const contOpSuccess = {
	[OP_ON_SUCCESS]: (_, cont, value) => {
		return internalCall(() => cont.effect_instruction_i1(value));
	},
	["OnStep"]: (_, _cont, value) => {
		return exitSucceed$1(exitSucceed$1(value));
	},
	[OP_ON_SUCCESS_AND_FAILURE]: (_, cont, value) => {
		return internalCall(() => cont.effect_instruction_i2(value));
	},
	[OP_REVERT_FLAGS]: (self, cont, value) => {
		self.patchRuntimeFlags(self.currentRuntimeFlags, cont.patch);
		if (interruptible$3(self.currentRuntimeFlags) && self.isInterrupted()) return exitFailCause$1(self.getInterruptedCause());
		else return exitSucceed$1(value);
	},
	[OP_WHILE]: (self, cont, value) => {
		internalCall(() => cont.effect_instruction_i2(value));
		if (internalCall(() => cont.effect_instruction_i0())) {
			self.pushStack(cont);
			return internalCall(() => cont.effect_instruction_i1());
		} else return void_$4;
	},
	[OP_ITERATOR]: (self, cont, value) => {
		const state = internalCall(() => cont.effect_instruction_i0.next(value));
		if (state.done) return exitSucceed$1(state.value);
		self.pushStack(cont);
		return yieldWrapGet(state.value);
	}
};
const drainQueueWhileRunningTable = {
	[OP_INTERRUPT_SIGNAL]: (self, runtimeFlags$1, cur, message) => {
		self.processNewInterruptSignal(message.cause);
		return interruptible$3(runtimeFlags$1) ? exitFailCause$1(message.cause) : cur;
	},
	[OP_RESUME]: (_self, _runtimeFlags, _cur, _message) => {
		throw new Error("It is illegal to have multiple concurrent run loops in a single fiber");
	},
	[OP_STATEFUL]: (self, runtimeFlags$1, cur, message) => {
		message.onFiber(self, running(runtimeFlags$1));
		return cur;
	},
	[OP_YIELD_NOW]: (_self, _runtimeFlags, cur, _message) => {
		return flatMap$4(yieldNow$3(), () => cur);
	}
};
/**
* Executes all requests, submitting requests to each data source in parallel.
*/
const runBlockedRequests = (self) => forEachSequentialDiscard(flatten$4(self), (requestsByRequestResolver) => forEachConcurrentDiscard(sequentialCollectionToChunk(requestsByRequestResolver), ([dataSource, sequential$3]) => {
	const map$17 = /* @__PURE__ */ new Map();
	const arr = [];
	for (const block of sequential$3) {
		arr.push(toReadonlyArray(block));
		for (const entry of block) map$17.set(entry.request, entry);
	}
	const flat = arr.flat();
	return fiberRefLocally(invokeWithInterrupt(dataSource.runAll(arr), flat, () => flat.forEach((entry) => {
		entry.listeners.interrupted = true;
	})), currentRequestMap, map$17);
}, false, false));
const _version = /* @__PURE__ */ getCurrentVersion();
/** @internal */
var FiberRuntime = class extends Class$2 {
	[FiberTypeId$1] = fiberVariance;
	[RuntimeFiberTypeId$1] = runtimeFiberVariance;
	_fiberRefs;
	_fiberId;
	_queue = /* @__PURE__ */ new Array();
	_children = null;
	_observers = /* @__PURE__ */ new Array();
	_running = false;
	_stack = [];
	_asyncInterruptor = null;
	_asyncBlockingOn = null;
	_exitValue = null;
	_steps = [];
	_isYielding = false;
	currentRuntimeFlags;
	currentOpCount = 0;
	currentSupervisor;
	currentScheduler;
	currentTracer;
	currentSpan;
	currentContext;
	currentDefaultServices;
	constructor(fiberId$2, fiberRefs0, runtimeFlags0) {
		super();
		this.currentRuntimeFlags = runtimeFlags0;
		this._fiberId = fiberId$2;
		this._fiberRefs = fiberRefs0;
		if (runtimeMetrics(runtimeFlags0)) {
			const tags = this.getFiberRef(currentMetricLabels);
			fiberStarted.unsafeUpdate(1, tags);
			fiberActive.unsafeUpdate(1, tags);
		}
		this.refreshRefCache();
	}
	commit() {
		return join$1(this);
	}
	/**
	* The identity of the fiber.
	*/
	id() {
		return this._fiberId;
	}
	/**
	* Begins execution of the effect associated with this fiber on in the
	* background. This can be called to "kick off" execution of a fiber after
	* it has been created.
	*/
	resume(effect) {
		this.tell(resume(effect));
	}
	/**
	* The status of the fiber.
	*/
	get status() {
		return this.ask((_, status$2) => status$2);
	}
	/**
	* Gets the fiber runtime flags.
	*/
	get runtimeFlags() {
		return this.ask((state, status$2) => {
			if (isDone$3(status$2)) return state.currentRuntimeFlags;
			return status$2.runtimeFlags;
		});
	}
	/**
	* Returns the current `FiberScope` for the fiber.
	*/
	scope() {
		return unsafeMake$2(this);
	}
	/**
	* Retrieves the immediate children of the fiber.
	*/
	get children() {
		return this.ask((fiber) => Array.from(fiber.getChildren()));
	}
	/**
	* Gets the fiber's set of children.
	*/
	getChildren() {
		if (this._children === null) this._children = /* @__PURE__ */ new Set();
		return this._children;
	}
	/**
	* Retrieves the interrupted cause of the fiber, which will be `Cause.empty`
	* if the fiber has not been interrupted.
	*
	* **NOTE**: This method is safe to invoke on any fiber, but if not invoked
	* on this fiber, then values derived from the fiber's state (including the
	* log annotations and log level) may not be up-to-date.
	*/
	getInterruptedCause() {
		return this.getFiberRef(currentInterruptedCause);
	}
	/**
	* Retrieves the whole set of fiber refs.
	*/
	fiberRefs() {
		return this.ask((fiber) => fiber.getFiberRefs());
	}
	/**
	* Returns an effect that will contain information computed from the fiber
	* state and status while running on the fiber.
	*
	* This allows the outside world to interact safely with mutable fiber state
	* without locks or immutable data.
	*/
	ask(f) {
		return suspend$3(() => {
			const deferred = deferredUnsafeMake(this._fiberId);
			this.tell(stateful((fiber, status$2) => {
				deferredUnsafeDone(deferred, sync$3(() => f(fiber, status$2)));
			}));
			return deferredAwait(deferred);
		});
	}
	/**
	* Adds a message to be processed by the fiber on the fiber.
	*/
	tell(message) {
		this._queue.push(message);
		if (!this._running) {
			this._running = true;
			this.drainQueueLaterOnExecutor();
		}
	}
	get await() {
		return async_((resume$1) => {
			const cb = (exit$3) => resume$1(succeed$9(exit$3));
			this.tell(stateful((fiber, _) => {
				if (fiber._exitValue !== null) cb(this._exitValue);
				else fiber.addObserver(cb);
			}));
			return sync$3(() => this.tell(stateful((fiber, _) => {
				fiber.removeObserver(cb);
			})));
		}, this.id());
	}
	get inheritAll() {
		return withFiberRuntime$1((parentFiber, parentStatus) => {
			const parentFiberId = parentFiber.id();
			const parentFiberRefs = parentFiber.getFiberRefs();
			const parentRuntimeFlags = parentStatus.runtimeFlags;
			const childFiberRefs = this.getFiberRefs();
			const updatedFiberRefs = joinAs$1(parentFiberRefs, parentFiberId, childFiberRefs);
			parentFiber.setFiberRefs(updatedFiberRefs);
			const updatedRuntimeFlags = parentFiber.getFiberRef(currentRuntimeFlags);
			const patch$11 = pipe(diff$3(parentRuntimeFlags, updatedRuntimeFlags), exclude(Interruption), exclude(WindDown));
			return updateRuntimeFlags(patch$11);
		});
	}
	/**
	* Tentatively observes the fiber, but returns immediately if it is not
	* already done.
	*/
	get poll() {
		return sync$3(() => fromNullable$2(this._exitValue));
	}
	/**
	* Unsafely observes the fiber, but returns immediately if it is not
	* already done.
	*/
	unsafePoll() {
		return this._exitValue;
	}
	/**
	* In the background, interrupts the fiber as if interrupted from the specified fiber.
	*/
	interruptAsFork(fiberId$2) {
		return sync$3(() => this.tell(interruptSignal(interrupt$5(fiberId$2))));
	}
	/**
	* In the background, interrupts the fiber as if interrupted from the specified fiber.
	*/
	unsafeInterruptAsFork(fiberId$2) {
		this.tell(interruptSignal(interrupt$5(fiberId$2)));
	}
	/**
	* Adds an observer to the list of observers.
	*
	* **NOTE**: This method must be invoked by the fiber itself.
	*/
	addObserver(observer) {
		if (this._exitValue !== null) observer(this._exitValue);
		else this._observers.push(observer);
	}
	/**
	* Removes the specified observer from the list of observers that will be
	* notified when the fiber exits.
	*
	* **NOTE**: This method must be invoked by the fiber itself.
	*/
	removeObserver(observer) {
		this._observers = this._observers.filter((o) => o !== observer);
	}
	/**
	* Retrieves all fiber refs of the fiber.
	*
	* **NOTE**: This method is safe to invoke on any fiber, but if not invoked
	* on this fiber, then values derived from the fiber's state (including the
	* log annotations and log level) may not be up-to-date.
	*/
	getFiberRefs() {
		this.setFiberRef(currentRuntimeFlags, this.currentRuntimeFlags);
		return this._fiberRefs;
	}
	/**
	* Deletes the specified fiber ref.
	*
	* **NOTE**: This method must be invoked by the fiber itself.
	*/
	unsafeDeleteFiberRef(fiberRef) {
		this._fiberRefs = delete_$1(this._fiberRefs, fiberRef);
	}
	/**
	* Retrieves the state of the fiber ref, or else its initial value.
	*
	* **NOTE**: This method is safe to invoke on any fiber, but if not invoked
	* on this fiber, then values derived from the fiber's state (including the
	* log annotations and log level) may not be up-to-date.
	*/
	getFiberRef(fiberRef) {
		if (this._fiberRefs.locals.has(fiberRef)) return this._fiberRefs.locals.get(fiberRef)[0][1];
		return fiberRef.initial;
	}
	/**
	* Sets the fiber ref to the specified value.
	*
	* **NOTE**: This method must be invoked by the fiber itself.
	*/
	setFiberRef(fiberRef, value) {
		this._fiberRefs = updateAs$1(this._fiberRefs, {
			fiberId: this._fiberId,
			fiberRef,
			value
		});
		this.refreshRefCache();
	}
	refreshRefCache() {
		this.currentDefaultServices = this.getFiberRef(currentServices);
		this.currentTracer = this.currentDefaultServices.unsafeMap.get(tracerTag.key);
		this.currentSupervisor = this.getFiberRef(currentSupervisor);
		this.currentScheduler = this.getFiberRef(currentScheduler);
		this.currentContext = this.getFiberRef(currentContext);
		this.currentSpan = this.currentContext.unsafeMap.get(spanTag.key);
	}
	/**
	* Wholesale replaces all fiber refs of this fiber.
	*
	* **NOTE**: This method must be invoked by the fiber itself.
	*/
	setFiberRefs(fiberRefs$3) {
		this._fiberRefs = fiberRefs$3;
		this.refreshRefCache();
	}
	/**
	* Adds a reference to the specified fiber inside the children set.
	*
	* **NOTE**: This method must be invoked by the fiber itself.
	*/
	addChild(child) {
		this.getChildren().add(child);
	}
	/**
	* Removes a reference to the specified fiber inside the children set.
	*
	* **NOTE**: This method must be invoked by the fiber itself.
	*/
	removeChild(child) {
		this.getChildren().delete(child);
	}
	/**
	* Transfers all children of this fiber that are currently running to the
	* specified fiber scope.
	*
	* **NOTE**: This method must be invoked by the fiber itself after it has
	* evaluated the effects but prior to exiting.
	*/
	transferChildren(scope$2) {
		const children$2 = this._children;
		this._children = null;
		if (children$2 !== null && children$2.size > 0) {
			for (const child of children$2) if (child._exitValue === null) scope$2.add(this.currentRuntimeFlags, child);
		}
	}
	/**
	* On the current thread, executes all messages in the fiber's inbox. This
	* method may return before all work is done, in the event the fiber executes
	* an asynchronous operation.
	*
	* **NOTE**: This method must be invoked by the fiber itself.
	*/
	drainQueueOnCurrentThread() {
		let recurse = true;
		while (recurse) {
			let evaluationSignal = EvaluationSignalContinue;
			const prev = globalThis[currentFiberURI];
			globalThis[currentFiberURI] = this;
			try {
				while (evaluationSignal === EvaluationSignalContinue) evaluationSignal = this._queue.length === 0 ? EvaluationSignalDone : this.evaluateMessageWhileSuspended(this._queue.splice(0, 1)[0]);
			} finally {
				this._running = false;
				globalThis[currentFiberURI] = prev;
			}
			if (this._queue.length > 0 && !this._running) {
				this._running = true;
				if (evaluationSignal === EvaluationSignalYieldNow) {
					this.drainQueueLaterOnExecutor();
					recurse = false;
				} else recurse = true;
			} else recurse = false;
		}
	}
	/**
	* Schedules the execution of all messages in the fiber's inbox.
	*
	* This method will return immediately after the scheduling
	* operation is completed, but potentially before such messages have been
	* executed.
	*
	* **NOTE**: This method must be invoked by the fiber itself.
	*/
	drainQueueLaterOnExecutor() {
		this.currentScheduler.scheduleTask(this.run, this.getFiberRef(currentSchedulingPriority));
	}
	/**
	* Drains the fiber's message queue while the fiber is actively running,
	* returning the next effect to execute, which may be the input effect if no
	* additional effect needs to be executed.
	*
	* **NOTE**: This method must be invoked by the fiber itself.
	*/
	drainQueueWhileRunning(runtimeFlags$1, cur0) {
		let cur = cur0;
		while (this._queue.length > 0) {
			const message = this._queue.splice(0, 1)[0];
			cur = drainQueueWhileRunningTable[message._tag](this, runtimeFlags$1, cur, message);
		}
		return cur;
	}
	/**
	* Determines if the fiber is interrupted.
	*
	* **NOTE**: This method is safe to invoke on any fiber, but if not invoked
	* on this fiber, then values derived from the fiber's state (including the
	* log annotations and log level) may not be up-to-date.
	*/
	isInterrupted() {
		return !isEmpty$6(this.getFiberRef(currentInterruptedCause));
	}
	/**
	* Adds an interruptor to the set of interruptors that are interrupting this
	* fiber.
	*
	* **NOTE**: This method must be invoked by the fiber itself.
	*/
	addInterruptedCause(cause$2) {
		const oldSC = this.getFiberRef(currentInterruptedCause);
		this.setFiberRef(currentInterruptedCause, sequential$2(oldSC, cause$2));
	}
	/**
	* Processes a new incoming interrupt signal.
	*
	* **NOTE**: This method must be invoked by the fiber itself.
	*/
	processNewInterruptSignal(cause$2) {
		this.addInterruptedCause(cause$2);
		this.sendInterruptSignalToAllChildren();
	}
	/**
	* Interrupts all children of the current fiber, returning an effect that will
	* await the exit of the children. This method will return null if the fiber
	* has no children.
	*
	* **NOTE**: This method must be invoked by the fiber itself.
	*/
	sendInterruptSignalToAllChildren() {
		if (this._children === null || this._children.size === 0) return false;
		let told = false;
		for (const child of this._children) {
			child.tell(interruptSignal(interrupt$5(this.id())));
			told = true;
		}
		return told;
	}
	/**
	* Interrupts all children of the current fiber, returning an effect that will
	* await the exit of the children. This method will return null if the fiber
	* has no children.
	*
	* **NOTE**: This method must be invoked by the fiber itself.
	*/
	interruptAllChildren() {
		if (this.sendInterruptSignalToAllChildren()) {
			const it = this._children.values();
			this._children = null;
			let isDone$5 = false;
			const body = () => {
				const next = it.next();
				if (!next.done) return asVoid$3(next.value.await);
				else return sync$3(() => {
					isDone$5 = true;
				});
			};
			return whileLoop$2({
				while: () => !isDone$5,
				body,
				step: () => {}
			});
		}
		return null;
	}
	reportExitValue(exit$3) {
		if (runtimeMetrics(this.currentRuntimeFlags)) {
			const tags = this.getFiberRef(currentMetricLabels);
			const startTimeMillis = this.id().startTimeMillis;
			const endTimeMillis = Date.now();
			fiberLifetimes.unsafeUpdate(endTimeMillis - startTimeMillis, tags);
			fiberActive.unsafeUpdate(-1, tags);
			switch (exit$3._tag) {
				case OP_SUCCESS:
					fiberSuccesses.unsafeUpdate(1, tags);
					break;
				case OP_FAILURE:
					fiberFailures.unsafeUpdate(1, tags);
					break;
			}
		}
		if (exit$3._tag === "Failure") {
			const level = this.getFiberRef(currentUnhandledErrorLogLevel);
			if (!isInterruptedOnly(exit$3.cause) && level._tag === "Some") this.log("Fiber terminated with an unhandled error", exit$3.cause, level);
		}
	}
	setExitValue(exit$3) {
		this._exitValue = exit$3;
		this.reportExitValue(exit$3);
		for (let i = this._observers.length - 1; i >= 0; i--) this._observers[i](exit$3);
		this._observers = [];
	}
	getLoggers() {
		return this.getFiberRef(currentLoggers);
	}
	log(message, cause$2, overrideLogLevel) {
		const logLevel = isSome(overrideLogLevel) ? overrideLogLevel.value : this.getFiberRef(currentLogLevel);
		const minimumLogLevel = this.getFiberRef(currentMinimumLogLevel);
		if (greaterThan$2(minimumLogLevel, logLevel)) return;
		const spans = this.getFiberRef(currentLogSpan);
		const annotations$1 = this.getFiberRef(currentLogAnnotations);
		const loggers = this.getLoggers();
		const contextMap = this.getFiberRefs();
		if (size$6(loggers) > 0) {
			const clockService = get$7(this.getFiberRef(currentServices), clockTag);
			const date = new Date(clockService.unsafeCurrentTimeMillis());
			withRedactableContext(contextMap, () => {
				for (const logger of loggers) logger.log({
					fiberId: this.id(),
					logLevel,
					message,
					cause: cause$2,
					context: contextMap,
					spans,
					annotations: annotations$1,
					date
				});
			});
		}
	}
	/**
	* Evaluates a single message on the current thread, while the fiber is
	* suspended. This method should only be called while evaluation of the
	* fiber's effect is suspended due to an asynchronous operation.
	*
	* **NOTE**: This method must be invoked by the fiber itself.
	*/
	evaluateMessageWhileSuspended(message) {
		switch (message._tag) {
			case OP_YIELD_NOW: return EvaluationSignalYieldNow;
			case OP_INTERRUPT_SIGNAL:
				this.processNewInterruptSignal(message.cause);
				if (this._asyncInterruptor !== null) {
					this._asyncInterruptor(exitFailCause$1(message.cause));
					this._asyncInterruptor = null;
				}
				return EvaluationSignalContinue;
			case OP_RESUME:
				this._asyncInterruptor = null;
				this._asyncBlockingOn = null;
				this.evaluateEffect(message.effect);
				return EvaluationSignalContinue;
			case OP_STATEFUL:
				message.onFiber(this, this._exitValue !== null ? done$5 : suspended(this.currentRuntimeFlags, this._asyncBlockingOn));
				return EvaluationSignalContinue;
			default: return absurd(message);
		}
	}
	/**
	* Evaluates an effect until completion, potentially asynchronously.
	*
	* **NOTE**: This method must be invoked by the fiber itself.
	*/
	evaluateEffect(effect0) {
		this.currentSupervisor.onResume(this);
		try {
			let effect = interruptible$3(this.currentRuntimeFlags) && this.isInterrupted() ? exitFailCause$1(this.getInterruptedCause()) : effect0;
			while (effect !== null) {
				const eff = effect;
				const exit$3 = this.runLoop(eff);
				if (exit$3 === YieldedOp) {
					const op = yieldedOpChannel.currentOp;
					yieldedOpChannel.currentOp = null;
					if (op._op === OP_YIELD) if (cooperativeYielding(this.currentRuntimeFlags)) {
						this.tell(yieldNow$1());
						this.tell(resume(exitVoid$1));
						effect = null;
					} else effect = exitVoid$1;
					else if (op._op === OP_ASYNC) effect = null;
				} else {
					this.currentRuntimeFlags = pipe(this.currentRuntimeFlags, enable$1(WindDown));
					const interruption$1 = this.interruptAllChildren();
					if (interruption$1 !== null) effect = flatMap$4(interruption$1, () => exit$3);
					else {
						if (this._queue.length === 0) this.setExitValue(exit$3);
						else this.tell(resume(exit$3));
						effect = null;
					}
				}
			}
		} finally {
			this.currentSupervisor.onSuspend(this);
		}
	}
	/**
	* Begins execution of the effect associated with this fiber on the current
	* thread. This can be called to "kick off" execution of a fiber after it has
	* been created, in hopes that the effect can be executed synchronously.
	*
	* This is not the normal way of starting a fiber, but it is useful when the
	* express goal of executing the fiber is to synchronously produce its exit.
	*/
	start(effect) {
		if (!this._running) {
			this._running = true;
			const prev = globalThis[currentFiberURI];
			globalThis[currentFiberURI] = this;
			try {
				this.evaluateEffect(effect);
			} finally {
				this._running = false;
				globalThis[currentFiberURI] = prev;
				if (this._queue.length > 0) this.drainQueueLaterOnExecutor();
			}
		} else this.tell(resume(effect));
	}
	/**
	* Begins execution of the effect associated with this fiber on in the
	* background, and on the correct thread pool. This can be called to "kick
	* off" execution of a fiber after it has been created, in hopes that the
	* effect can be executed synchronously.
	*/
	startFork(effect) {
		this.tell(resume(effect));
	}
	/**
	* Takes the current runtime flags, patches them to return the new runtime
	* flags, and then makes any changes necessary to fiber state based on the
	* specified patch.
	*
	* **NOTE**: This method must be invoked by the fiber itself.
	*/
	patchRuntimeFlags(oldRuntimeFlags, patch$11) {
		const newRuntimeFlags = patch$4(oldRuntimeFlags, patch$11);
		globalThis[currentFiberURI] = this;
		this.currentRuntimeFlags = newRuntimeFlags;
		return newRuntimeFlags;
	}
	/**
	* Initiates an asynchronous operation, by building a callback that will
	* resume execution, and then feeding that callback to the registration
	* function, handling error cases and repeated resumptions appropriately.
	*
	* **NOTE**: This method must be invoked by the fiber itself.
	*/
	initiateAsync(runtimeFlags$1, asyncRegister) {
		let alreadyCalled = false;
		const callback = (effect) => {
			if (!alreadyCalled) {
				alreadyCalled = true;
				this.tell(resume(effect));
			}
		};
		if (interruptible$3(runtimeFlags$1)) this._asyncInterruptor = callback;
		try {
			asyncRegister(callback);
		} catch (e) {
			callback(failCause$8(die$4(e)));
		}
	}
	pushStack(cont) {
		this._stack.push(cont);
		if (cont._op === "OnStep") this._steps.push({
			refs: this.getFiberRefs(),
			flags: this.currentRuntimeFlags
		});
	}
	popStack() {
		const item = this._stack.pop();
		if (item) {
			if (item._op === "OnStep") this._steps.pop();
			return item;
		}
	}
	getNextSuccessCont() {
		let frame = this.popStack();
		while (frame) {
			if (frame._op !== OP_ON_FAILURE) return frame;
			frame = this.popStack();
		}
	}
	getNextFailCont() {
		let frame = this.popStack();
		while (frame) {
			if (frame._op !== OP_ON_SUCCESS && frame._op !== OP_WHILE && frame._op !== OP_ITERATOR) return frame;
			frame = this.popStack();
		}
	}
	[OP_TAG](op) {
		return sync$3(() => unsafeGet$1(this.currentContext, op));
	}
	["Left"](op) {
		return fail$8(op.left);
	}
	["None"](_) {
		return fail$8(new NoSuchElementException());
	}
	["Right"](op) {
		return exitSucceed$1(op.right);
	}
	["Some"](op) {
		return exitSucceed$1(op.value);
	}
	["Micro"](op) {
		return unsafeAsync((microResume) => {
			let resume$1 = microResume;
			const fiber = runFork$1(provideContext(op, this.currentContext));
			fiber.addObserver((exit$3) => {
				if (exit$3._tag === "Success") return resume$1(exitSucceed$1(exit$3.value));
				switch (exit$3.cause._tag) {
					case "Interrupt": return resume$1(exitFailCause$1(interrupt$5(none$6)));
					case "Fail": return resume$1(fail$8(exit$3.cause.error));
					case "Die": return resume$1(die$3(exit$3.cause.defect));
				}
			});
			return unsafeAsync((abortResume) => {
				resume$1 = (_) => {
					abortResume(void_$4);
				};
				fiber.unsafeInterrupt();
			});
		});
	}
	[OP_SYNC](op) {
		const value = internalCall(() => op.effect_instruction_i0());
		const cont = this.getNextSuccessCont();
		if (cont !== void 0) {
			if (!(cont._op in contOpSuccess)) absurd(cont);
			return contOpSuccess[cont._op](this, cont, value);
		} else {
			yieldedOpChannel.currentOp = exitSucceed$1(value);
			return YieldedOp;
		}
	}
	[OP_SUCCESS](op) {
		const oldCur = op;
		const cont = this.getNextSuccessCont();
		if (cont !== void 0) {
			if (!(cont._op in contOpSuccess)) absurd(cont);
			return contOpSuccess[cont._op](this, cont, oldCur.effect_instruction_i0);
		} else {
			yieldedOpChannel.currentOp = oldCur;
			return YieldedOp;
		}
	}
	[OP_FAILURE](op) {
		const cause$2 = op.effect_instruction_i0;
		const cont = this.getNextFailCont();
		if (cont !== void 0) switch (cont._op) {
			case OP_ON_FAILURE:
			case OP_ON_SUCCESS_AND_FAILURE: if (!(interruptible$3(this.currentRuntimeFlags) && this.isInterrupted())) return internalCall(() => cont.effect_instruction_i1(cause$2));
			else return exitFailCause$1(stripFailures(cause$2));
			case "OnStep": if (!(interruptible$3(this.currentRuntimeFlags) && this.isInterrupted())) return exitSucceed$1(exitFailCause$1(cause$2));
			else return exitFailCause$1(stripFailures(cause$2));
			case OP_REVERT_FLAGS:
				this.patchRuntimeFlags(this.currentRuntimeFlags, cont.patch);
				if (interruptible$3(this.currentRuntimeFlags) && this.isInterrupted()) return exitFailCause$1(sequential$2(cause$2, this.getInterruptedCause()));
				else return exitFailCause$1(cause$2);
			default: absurd(cont);
		}
		else {
			yieldedOpChannel.currentOp = exitFailCause$1(cause$2);
			return YieldedOp;
		}
	}
	[OP_WITH_RUNTIME](op) {
		return internalCall(() => op.effect_instruction_i0(this, running(this.currentRuntimeFlags)));
	}
	["Blocked"](op) {
		const refs = this.getFiberRefs();
		const flags = this.currentRuntimeFlags;
		if (this._steps.length > 0) {
			const frames = [];
			const snap = this._steps[this._steps.length - 1];
			let frame = this.popStack();
			while (frame && frame._op !== "OnStep") {
				frames.push(frame);
				frame = this.popStack();
			}
			this.setFiberRefs(snap.refs);
			this.currentRuntimeFlags = snap.flags;
			const patchRefs = diff$1(snap.refs, refs);
			const patchFlags = diff$3(snap.flags, flags);
			return exitSucceed$1(blocked$1(op.effect_instruction_i0, withFiberRuntime$1((newFiber) => {
				while (frames.length > 0) newFiber.pushStack(frames.pop());
				newFiber.setFiberRefs(patch$1(newFiber.id(), newFiber.getFiberRefs())(patchRefs));
				newFiber.currentRuntimeFlags = patch$4(patchFlags)(newFiber.currentRuntimeFlags);
				return op.effect_instruction_i1;
			})));
		}
		return uninterruptibleMask$2((restore) => flatMap$4(forkDaemon$1(runRequestBlock$1(op.effect_instruction_i0)), () => restore(op.effect_instruction_i1)));
	}
	["RunBlocked"](op) {
		return runBlockedRequests(op.effect_instruction_i0);
	}
	[OP_UPDATE_RUNTIME_FLAGS](op) {
		const updateFlags = op.effect_instruction_i0;
		const oldRuntimeFlags = this.currentRuntimeFlags;
		const newRuntimeFlags = patch$4(oldRuntimeFlags, updateFlags);
		if (interruptible$3(newRuntimeFlags) && this.isInterrupted()) return exitFailCause$1(this.getInterruptedCause());
		else {
			this.patchRuntimeFlags(this.currentRuntimeFlags, updateFlags);
			if (op.effect_instruction_i1) {
				const revertFlags = diff$3(newRuntimeFlags, oldRuntimeFlags);
				this.pushStack(new RevertFlags(revertFlags, op));
				return internalCall(() => op.effect_instruction_i1(oldRuntimeFlags));
			} else return exitVoid$1;
		}
	}
	[OP_ON_SUCCESS](op) {
		this.pushStack(op);
		return op.effect_instruction_i0;
	}
	["OnStep"](op) {
		this.pushStack(op);
		return op.effect_instruction_i0;
	}
	[OP_ON_FAILURE](op) {
		this.pushStack(op);
		return op.effect_instruction_i0;
	}
	[OP_ON_SUCCESS_AND_FAILURE](op) {
		this.pushStack(op);
		return op.effect_instruction_i0;
	}
	[OP_ASYNC](op) {
		this._asyncBlockingOn = op.effect_instruction_i1;
		this.initiateAsync(this.currentRuntimeFlags, op.effect_instruction_i0);
		yieldedOpChannel.currentOp = op;
		return YieldedOp;
	}
	[OP_YIELD](op) {
		this._isYielding = false;
		yieldedOpChannel.currentOp = op;
		return YieldedOp;
	}
	[OP_WHILE](op) {
		const check$1 = op.effect_instruction_i0;
		const body = op.effect_instruction_i1;
		if (check$1()) {
			this.pushStack(op);
			return body();
		} else return exitVoid$1;
	}
	[OP_ITERATOR](op) {
		return contOpSuccess[OP_ITERATOR](this, op, void 0);
	}
	[OP_COMMIT](op) {
		return internalCall(() => op.commit());
	}
	/**
	* The main run-loop for evaluating effects.
	*
	* **NOTE**: This method must be invoked by the fiber itself.
	*/
	runLoop(effect0) {
		let cur = effect0;
		this.currentOpCount = 0;
		while (true) {
			if ((this.currentRuntimeFlags & OpSupervision) !== 0) this.currentSupervisor.onEffect(this, cur);
			if (this._queue.length > 0) cur = this.drainQueueWhileRunning(this.currentRuntimeFlags, cur);
			if (!this._isYielding) {
				this.currentOpCount += 1;
				const shouldYield = this.currentScheduler.shouldYield(this);
				if (shouldYield !== false) {
					this._isYielding = true;
					this.currentOpCount = 0;
					const oldCur = cur;
					cur = flatMap$4(yieldNow$3({ priority: shouldYield }), () => oldCur);
				}
			}
			try {
				cur = this.currentTracer.context(() => {
					if (_version !== cur[EffectTypeId$2]._V) {
						const level = this.getFiberRef(currentVersionMismatchErrorLogLevel);
						if (level._tag === "Some") {
							const effectVersion = cur[EffectTypeId$2]._V;
							this.log(`Executing an Effect versioned ${effectVersion} with a Runtime of version ${getCurrentVersion()}, you may want to dedupe the effect dependencies, you can use the language service plugin to detect this at compile time: https://github.com/Effect-TS/language-service`, empty$27, level);
						}
					}
					return this[cur._op](cur);
				}, this);
				if (cur === YieldedOp) {
					const op = yieldedOpChannel.currentOp;
					if (op._op === OP_YIELD || op._op === OP_ASYNC) return YieldedOp;
					yieldedOpChannel.currentOp = null;
					return op._op === OP_SUCCESS || op._op === OP_FAILURE ? op : exitFailCause$1(die$4(op));
				}
			} catch (e) {
				if (cur !== YieldedOp && !hasProperty(cur, "_op") || !(cur._op in this)) cur = dieMessage$1(`Not a valid effect: ${toStringUnknown(cur)}`);
				else if (isInterruptedException(e)) cur = exitFailCause$1(sequential$2(die$4(e), interrupt$5(none$6)));
				else cur = die$3(e);
			}
		}
	}
	run = () => {
		this.drainQueueOnCurrentThread();
	};
};
/** @internal */
const currentMinimumLogLevel = /* @__PURE__ */ globalValue("effect/FiberRef/currentMinimumLogLevel", () => fiberRefUnsafeMake(fromLiteral("Info")));
/** @internal */
const loggerWithConsoleLog = (self) => makeLogger((opts) => {
	const services = getOrDefault(opts.context, currentServices);
	get$7(services, consoleTag).unsafe.log(self.log(opts));
});
/** @internal */
const defaultLogger = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/Logger/defaultLogger"), () => loggerWithConsoleLog(stringLogger));
/** @internal */
const tracerLogger = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/Logger/tracerLogger"), () => makeLogger(({ annotations: annotations$1, cause: cause$2, context: context$2, fiberId: fiberId$2, logLevel, message }) => {
	const span$1 = getOption(getOrDefault$1(context$2, currentContext), spanTag);
	if (span$1._tag === "None" || span$1.value._tag === "ExternalSpan") return;
	const clockService = unsafeGet$1(getOrDefault$1(context$2, currentServices), clockTag);
	const attributes = {};
	for (const [key, value] of annotations$1) attributes[key] = value;
	attributes["effect.fiberId"] = threadName(fiberId$2);
	attributes["effect.logLevel"] = logLevel.label;
	if (cause$2 !== null && cause$2._tag !== "Empty") attributes["effect.cause"] = pretty$2(cause$2, { renderErrorCause: true });
	span$1.value.event(toStringUnknown(Array.isArray(message) && message.length === 1 ? message[0] : message), clockService.unsafeCurrentTimeNanos(), attributes);
}));
/** @internal */
const currentLoggers = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentLoggers"), () => fiberRefUnsafeMakeHashSet(make$38(defaultLogger, tracerLogger)));
const annotateLogsScoped$1 = function() {
	if (typeof arguments[0] === "string") return fiberRefLocallyScopedWith(currentLogAnnotations, set$3(arguments[0], arguments[1]));
	const entries$2 = Object.entries(arguments[0]);
	return fiberRefLocallyScopedWith(currentLogAnnotations, mutate((annotations$1) => {
		for (let i = 0; i < entries$2.length; i++) {
			const [key, value] = entries$2[i];
			set$3(annotations$1, key, value);
		}
		return annotations$1;
	}));
};
/** @internal */
const whenLogLevel$1 = /* @__PURE__ */ dual(2, (effect, level) => {
	const requiredLogLevel = typeof level === "string" ? fromLiteral(level) : level;
	return withFiberRuntime$1((fiberState) => {
		const minimumLogLevel = fiberState.getFiberRef(currentMinimumLogLevel);
		if (greaterThan$2(minimumLogLevel, requiredLogLevel)) return succeed$9(none$7());
		return map$8(effect, some$4);
	});
});
const acquireRelease$1 = /* @__PURE__ */ dual((args$1) => isEffect$1(args$1[0]), (acquire, release) => uninterruptible$1(tap$1(acquire, (a) => addFinalizer$2((exit$3) => release(a, exit$3)))));
const acquireReleaseInterruptible$1 = /* @__PURE__ */ dual((args$1) => isEffect$1(args$1[0]), (acquire, release) => ensuring$1(acquire, addFinalizer$2((exit$3) => release(exit$3))));
const addFinalizer$2 = (finalizer) => withFiberRuntime$1((runtime$4) => {
	const acquireRefs = runtime$4.getFiberRefs();
	const acquireFlags = disable$1(runtime$4.currentRuntimeFlags, Interruption);
	return flatMap$4(scope$1, (scope$2) => scopeAddFinalizerExit(scope$2, (exit$3) => withFiberRuntime$1((runtimeFinalizer) => {
		const preRefs = runtimeFinalizer.getFiberRefs();
		const preFlags = runtimeFinalizer.currentRuntimeFlags;
		const patchRefs = diff$1(preRefs, acquireRefs);
		const patchFlags = diff$3(preFlags, acquireFlags);
		const inverseRefs = diff$1(acquireRefs, preRefs);
		runtimeFinalizer.setFiberRefs(patch$1(patchRefs, runtimeFinalizer.id(), acquireRefs));
		return ensuring$1(withRuntimeFlags(finalizer(exit$3), patchFlags), sync$3(() => {
			runtimeFinalizer.setFiberRefs(patch$1(inverseRefs, runtimeFinalizer.id(), runtimeFinalizer.getFiberRefs()));
		}));
	})));
});
const daemonChildren$1 = (self) => {
	return fiberRefLocally(currentForkScopeOverride, some$4(globalScope))(self);
};
/** @internal */
const _existsParFound = /* @__PURE__ */ Symbol.for("effect/Effect/existsPar/found");
const exists$1 = /* @__PURE__ */ dual((args$1) => isIterable(args$1[0]) && !isEffect$1(args$1[0]), (elements, predicate, options) => matchSimple(options?.concurrency, () => suspend$3(() => existsLoop(elements[Symbol.iterator](), 0, predicate)), () => matchEffect$2(forEach$1(elements, (a, i) => if_$1(predicate(a, i), {
	onTrue: () => fail$8(_existsParFound),
	onFalse: () => void_$4
}), options), {
	onFailure: (e) => e === _existsParFound ? succeed$9(true) : fail$8(e),
	onSuccess: () => succeed$9(false)
})));
const existsLoop = (iterator, index, f) => {
	const next = iterator.next();
	if (next.done) return succeed$9(false);
	return flatMap$4(f(next.value, index), (b) => b ? succeed$9(b) : existsLoop(iterator, index + 1, f));
};
const filter$2 = /* @__PURE__ */ dual((args$1) => isIterable(args$1[0]) && !isEffect$1(args$1[0]), (elements, predicate, options) => {
	const predicate_ = options?.negate ? (a, i) => map$8(predicate(a, i), not) : predicate;
	return matchSimple(options?.concurrency, () => suspend$3(() => fromIterable$10(elements).reduceRight((effect, a, i) => zipWith$4(effect, suspend$3(() => predicate_(a, i)), (list, b) => b ? [a, ...list] : list), sync$3(() => new Array()))), () => map$8(forEach$1(elements, (a, i) => map$8(predicate_(a, i), (b) => b ? some$4(a) : none$7()), options), getSomes));
});
const allResolveInput = (input) => {
	if (Array.isArray(input) || isIterable(input)) return [input, none$7()];
	const keys$5 = Object.keys(input);
	const size$9 = keys$5.length;
	return [keys$5.map((k) => input[k]), some$4((values$6) => {
		const res = {};
		for (let i = 0; i < size$9; i++) res[keys$5[i]] = values$6[i];
		return res;
	})];
};
const allValidate = (effects, reconcile, options) => {
	const eitherEffects = [];
	for (const effect of effects) eitherEffects.push(either$1(effect));
	return flatMap$4(forEach$1(eitherEffects, identity, {
		concurrency: options?.concurrency,
		batching: options?.batching,
		concurrentFinalizers: options?.concurrentFinalizers
	}), (eithers) => {
		const none$9 = none$7();
		const size$9 = eithers.length;
		const errors = new Array(size$9);
		const successes = new Array(size$9);
		let errored = false;
		for (let i = 0; i < size$9; i++) {
			const either$4 = eithers[i];
			if (either$4._tag === "Left") {
				errors[i] = some$4(either$4.left);
				errored = true;
			} else {
				successes[i] = either$4.right;
				errors[i] = none$9;
			}
		}
		if (errored) return reconcile._tag === "Some" ? fail$8(reconcile.value(errors)) : fail$8(errors);
		else if (options?.discard) return void_$4;
		return reconcile._tag === "Some" ? succeed$9(reconcile.value(successes)) : succeed$9(successes);
	});
};
const allEither = (effects, reconcile, options) => {
	const eitherEffects = [];
	for (const effect of effects) eitherEffects.push(either$1(effect));
	if (options?.discard) return forEach$1(eitherEffects, identity, {
		concurrency: options?.concurrency,
		batching: options?.batching,
		discard: true,
		concurrentFinalizers: options?.concurrentFinalizers
	});
	return map$8(forEach$1(eitherEffects, identity, {
		concurrency: options?.concurrency,
		batching: options?.batching,
		concurrentFinalizers: options?.concurrentFinalizers
	}), (eithers) => reconcile._tag === "Some" ? reconcile.value(eithers) : eithers);
};
const all$2 = (arg, options) => {
	const [effects, reconcile] = allResolveInput(arg);
	if (options?.mode === "validate") return allValidate(effects, reconcile, options);
	else if (options?.mode === "either") return allEither(effects, reconcile, options);
	return options?.discard !== true && reconcile._tag === "Some" ? map$8(forEach$1(effects, identity, options), reconcile.value) : forEach$1(effects, identity, options);
};
const allWith$1 = (options) => (arg) => all$2(arg, options);
const allSuccesses$1 = (elements, options) => map$8(all$2(fromIterable$10(elements).map(exit$2), options), filterMap$4((exit$3) => exitIsSuccess(exit$3) ? some$4(exit$3.effect_instruction_i0) : none$7()));
const replicate$1 = /* @__PURE__ */ dual(2, (self, n) => Array.from({ length: n }, () => self));
const replicateEffect$1 = /* @__PURE__ */ dual((args$1) => isEffect$1(args$1[0]), (self, n, options) => all$2(replicate$1(self, n), options));
const forEach$1 = /* @__PURE__ */ dual((args$1) => isIterable(args$1[0]), (self, f, options) => withFiberRuntime$1((r) => {
	const isRequestBatchingEnabled = options?.batching === true || options?.batching === "inherit" && r.getFiberRef(currentRequestBatching);
	if (options?.discard) return match$5(options.concurrency, () => finalizersMaskInternal(sequential, options?.concurrentFinalizers)((restore) => isRequestBatchingEnabled ? forEachConcurrentDiscard(self, (a, i) => restore(f(a, i)), true, false, 1) : forEachSequentialDiscard(self, (a, i) => restore(f(a, i)))), () => finalizersMaskInternal(parallel, options?.concurrentFinalizers)((restore) => forEachConcurrentDiscard(self, (a, i) => restore(f(a, i)), isRequestBatchingEnabled, false)), (n) => finalizersMaskInternal(parallelN(n), options?.concurrentFinalizers)((restore) => forEachConcurrentDiscard(self, (a, i) => restore(f(a, i)), isRequestBatchingEnabled, false, n)));
	return match$5(options?.concurrency, () => finalizersMaskInternal(sequential, options?.concurrentFinalizers)((restore) => isRequestBatchingEnabled ? forEachParN(self, 1, (a, i) => restore(f(a, i)), true) : forEachSequential(self, (a, i) => restore(f(a, i)))), () => finalizersMaskInternal(parallel, options?.concurrentFinalizers)((restore) => forEachParUnbounded(self, (a, i) => restore(f(a, i)), isRequestBatchingEnabled)), (n) => finalizersMaskInternal(parallelN(n), options?.concurrentFinalizers)((restore) => forEachParN(self, n, (a, i) => restore(f(a, i)), isRequestBatchingEnabled)));
}));
const forEachParUnbounded = (self, f, batching) => suspend$3(() => {
	const as$4 = fromIterable$10(self);
	const array$3 = new Array(as$4.length);
	const fn = (a, i) => flatMap$4(f(a, i), (b) => sync$3(() => array$3[i] = b));
	return zipRight$3(forEachConcurrentDiscard(as$4, fn, batching, false), succeed$9(array$3));
});
/** @internal */
const forEachConcurrentDiscard = (self, f, batching, processAll, n) => uninterruptibleMask$2((restore) => transplant$1((graft) => withFiberRuntime$1((parent) => {
	let todos = Array.from(self).reverse();
	let target = todos.length;
	if (target === 0) return void_$4;
	let counter$5 = 0;
	let interrupted$2 = false;
	const fibersCount = n ? Math.min(todos.length, n) : todos.length;
	const fibers = /* @__PURE__ */ new Set();
	const results = new Array();
	const interruptAll$2 = () => fibers.forEach((fiber) => {
		fiber.currentScheduler.scheduleTask(() => {
			fiber.unsafeInterruptAsFork(parent.id());
		}, 0);
	});
	const startOrder = new Array();
	const joinOrder = new Array();
	const residual = new Array();
	const collectExits = () => {
		const exits = results.filter(({ exit: exit$3 }) => exit$3._tag === "Failure").sort((a, b) => a.index < b.index ? -1 : a.index === b.index ? 0 : 1).map(({ exit: exit$3 }) => exit$3);
		if (exits.length === 0) exits.push(exitVoid$1);
		return exits;
	};
	const runFiber = (eff, interruptImmediately = false) => {
		const runnable = uninterruptible$1(graft(eff));
		const fiber = unsafeForkUnstarted(runnable, parent, parent.currentRuntimeFlags, globalScope);
		parent.currentScheduler.scheduleTask(() => {
			if (interruptImmediately) fiber.unsafeInterruptAsFork(parent.id());
			fiber.resume(runnable);
		}, 0);
		return fiber;
	};
	const onInterruptSignal = () => {
		if (!processAll) {
			target -= todos.length;
			todos = [];
		}
		interrupted$2 = true;
		interruptAll$2();
	};
	const stepOrExit = batching ? step$1 : exit$2;
	const processingFiber = runFiber(async_((resume$1) => {
		const pushResult = (res, index) => {
			if (res._op === "Blocked") residual.push(res);
			else {
				results.push({
					index,
					exit: res
				});
				if (res._op === "Failure" && !interrupted$2) onInterruptSignal();
			}
		};
		const next = () => {
			if (todos.length > 0) {
				const a = todos.pop();
				let index = counter$5++;
				const returnNextElement = () => {
					const a$1 = todos.pop();
					index = counter$5++;
					return flatMap$4(yieldNow$3(), () => flatMap$4(stepOrExit(restore(f(a$1, index))), onRes));
				};
				const onRes = (res) => {
					if (todos.length > 0) {
						pushResult(res, index);
						if (todos.length > 0) return returnNextElement();
					}
					return succeed$9(res);
				};
				const todo = flatMap$4(stepOrExit(restore(f(a, index))), onRes);
				const fiber = runFiber(todo);
				startOrder.push(fiber);
				fibers.add(fiber);
				if (interrupted$2) fiber.currentScheduler.scheduleTask(() => {
					fiber.unsafeInterruptAsFork(parent.id());
				}, 0);
				fiber.addObserver((wrapped) => {
					let exit$3;
					if (wrapped._op === "Failure") exit$3 = wrapped;
					else exit$3 = wrapped.effect_instruction_i0;
					joinOrder.push(fiber);
					fibers.delete(fiber);
					pushResult(exit$3, index);
					if (results.length === target) resume$1(succeed$9(getOrElse$5(exitCollectAll(collectExits(), { parallel: true }), () => exitVoid$1)));
					else if (residual.length + results.length === target) {
						const exits = collectExits();
						const requests = residual.map((blocked$2) => blocked$2.effect_instruction_i0).reduce(par);
						resume$1(succeed$9(blocked$1(requests, forEachConcurrentDiscard([getOrElse$5(exitCollectAll(exits, { parallel: true }), () => exitVoid$1), ...residual.map((blocked$2) => blocked$2.effect_instruction_i1)], (i) => i, batching, true, n))));
					} else next();
				});
			}
		};
		for (let i = 0; i < fibersCount; i++) next();
	}));
	return asVoid$3(onExit$2(flatten$3(restore(join$1(processingFiber))), exitMatch({
		onFailure: (cause$2) => {
			onInterruptSignal();
			const target$1 = residual.length + 1;
			const concurrency = Math.min(typeof n === "number" ? n : residual.length, residual.length);
			const toPop = Array.from(residual);
			return async_((cb) => {
				const exits = [];
				let count = 0;
				let index = 0;
				const check$1 = (index$1, hitNext) => (exit$3) => {
					exits[index$1] = exit$3;
					count++;
					if (count === target$1) cb(exitSucceed$1(exitFailCause$1(cause$2)));
					if (toPop.length > 0 && hitNext) next();
				};
				const next = () => {
					runFiber(toPop.pop(), true).addObserver(check$1(index, true));
					index++;
				};
				processingFiber.addObserver(check$1(index, false));
				index++;
				for (let i = 0; i < concurrency; i++) next();
			});
		},
		onSuccess: () => forEachSequential(joinOrder, (f$1) => f$1.inheritAll)
	})));
})));
const forEachParN = (self, n, f, batching) => suspend$3(() => {
	const as$4 = fromIterable$10(self);
	const array$3 = new Array(as$4.length);
	const fn = (a, i) => map$8(f(a, i), (b) => array$3[i] = b);
	return zipRight$3(forEachConcurrentDiscard(as$4, fn, batching, false, n), succeed$9(array$3));
});
const fork$2 = (self) => withFiberRuntime$1((state, status$2) => succeed$9(unsafeFork$1(self, state, status$2.runtimeFlags)));
const forkDaemon$1 = (self) => forkWithScopeOverride(self, globalScope);
const forkWithErrorHandler$1 = /* @__PURE__ */ dual(2, (self, handler) => fork$2(onError$1(self, (cause$2) => {
	const either$4 = failureOrCause(cause$2);
	switch (either$4._tag) {
		case "Left": return handler(either$4.left);
		case "Right": return failCause$8(either$4.right);
	}
})));
/** @internal */
const unsafeFork$1 = (effect, parentFiber, parentRuntimeFlags, overrideScope = null) => {
	const childFiber = unsafeMakeChildFiber(effect, parentFiber, parentRuntimeFlags, overrideScope);
	childFiber.resume(effect);
	return childFiber;
};
/** @internal */
const unsafeForkUnstarted = (effect, parentFiber, parentRuntimeFlags, overrideScope = null) => {
	return unsafeMakeChildFiber(effect, parentFiber, parentRuntimeFlags, overrideScope);
};
/** @internal */
const unsafeMakeChildFiber = (effect, parentFiber, parentRuntimeFlags, overrideScope = null) => {
	const childId = unsafeMake$7();
	const parentFiberRefs = parentFiber.getFiberRefs();
	const childFiberRefs = forkAs$1(parentFiberRefs, childId);
	const childFiber = new FiberRuntime(childId, childFiberRefs, parentRuntimeFlags);
	const childContext = getOrDefault$1(childFiberRefs, currentContext);
	const supervisor = childFiber.currentSupervisor;
	supervisor.onStart(childContext, effect, some$4(parentFiber), childFiber);
	childFiber.addObserver((exit$3) => supervisor.onEnd(exit$3, childFiber));
	(overrideScope !== null ? overrideScope : pipe(parentFiber.getFiberRef(currentForkScopeOverride), getOrElse$5(() => parentFiber.scope()))).add(parentRuntimeFlags, childFiber);
	return childFiber;
};
const forkWithScopeOverride = (self, scopeOverride) => withFiberRuntime$1((parentFiber, parentStatus) => succeed$9(unsafeFork$1(self, parentFiber, parentStatus.runtimeFlags, scopeOverride)));
const mergeAll$2 = /* @__PURE__ */ dual((args$1) => isFunction(args$1[2]), (elements, zero$1, f, options) => matchSimple(options?.concurrency, () => fromIterable$10(elements).reduce((acc, a, i) => zipWith$4(acc, a, (acc$1, a$1) => f(acc$1, a$1, i)), succeed$9(zero$1)), () => flatMap$4(make$21(zero$1), (acc) => flatMap$4(forEach$1(elements, (effect, i) => flatMap$4(effect, (a) => update$2(acc, (b) => f(b, a, i))), options), () => get$1(acc)))));
const partition$1 = /* @__PURE__ */ dual((args$1) => isIterable(args$1[0]), (elements, f, options) => pipe(forEach$1(elements, (a, i) => either$1(f(a, i)), options), map$8((chunk$2) => partitionMap(chunk$2, identity))));
const validateAll$1 = /* @__PURE__ */ dual((args$1) => isIterable(args$1[0]), (elements, f, options) => flatMap$4(partition$1(elements, f, {
	concurrency: options?.concurrency,
	batching: options?.batching,
	concurrentFinalizers: options?.concurrentFinalizers
}), ([es, bs]) => isNonEmptyArray(es) ? fail$8(es) : options?.discard ? void_$4 : succeed$9(bs)));
const raceAll$1 = (all$6) => withFiberRuntime$1((state, status$2) => async_((resume$1) => {
	const fibers = /* @__PURE__ */ new Set();
	let winner;
	let failures$1 = empty$27;
	const interruptAll$2 = () => {
		for (const fiber of fibers) fiber.unsafeInterruptAsFork(state.id());
	};
	let latch = false;
	let empty$33 = true;
	for (const self of all$6) {
		empty$33 = false;
		const fiber = unsafeFork$1(interruptible$2(self), state, status$2.runtimeFlags);
		fibers.add(fiber);
		fiber.addObserver((exit$3) => {
			fibers.delete(fiber);
			if (!winner) if (exit$3._tag === "Success") {
				latch = true;
				winner = fiber;
				failures$1 = empty$27;
				interruptAll$2();
			} else failures$1 = parallel$2(exit$3.cause, failures$1);
			if (latch && fibers.size === 0) resume$1(winner ? zipRight$3(inheritAll$1(winner), winner.unsafePoll()) : failCause$8(failures$1));
		});
		if (winner) break;
	}
	if (empty$33) return resume$1(dieSync$2(() => new IllegalArgumentException(`Received an empty collection of effects`)));
	latch = true;
	return interruptAllAs$1(fibers, state.id());
}));
const reduceEffect$1 = /* @__PURE__ */ dual((args$1) => isIterable(args$1[0]) && !isEffect$1(args$1[0]), (elements, zero$1, f, options) => matchSimple(options?.concurrency, () => fromIterable$10(elements).reduce((acc, a, i) => zipWith$4(acc, a, (acc$1, a$1) => f(acc$1, a$1, i)), zero$1), () => suspend$3(() => pipe(mergeAll$2([zero$1, ...elements], none$7(), (acc, elem, i) => {
	switch (acc._tag) {
		case "None": return some$4(elem);
		case "Some": return some$4(f(acc.value, elem, i));
	}
}, options), map$8((option$2) => {
	switch (option$2._tag) {
		case "None": throw new Error("BUG: Effect.reduceEffect - please report an issue at https://github.com/Effect-TS/effect/issues");
		case "Some": return option$2.value;
	}
})))));
const parallelFinalizers$1 = (self) => contextWithEffect$1((context$2) => match$10(getOption(context$2, scopeTag), {
	onNone: () => self,
	onSome: (scope$2) => {
		switch (scope$2.strategy._tag) {
			case "Parallel": return self;
			case "Sequential":
			case "ParallelN": return flatMap$4(scopeFork(scope$2, parallel), (inner) => scopeExtend(self, inner));
		}
	}
}));
const parallelNFinalizers = (parallelism) => (self) => contextWithEffect$1((context$2) => match$10(getOption(context$2, scopeTag), {
	onNone: () => self,
	onSome: (scope$2) => {
		if (scope$2.strategy._tag === "ParallelN" && scope$2.strategy.parallelism === parallelism) return self;
		return flatMap$4(scopeFork(scope$2, parallelN(parallelism)), (inner) => scopeExtend(self, inner));
	}
}));
const finalizersMask$1 = (strategy) => (self) => finalizersMaskInternal(strategy, true)(self);
const finalizersMaskInternal = (strategy, concurrentFinalizers) => (self) => contextWithEffect$1((context$2) => match$10(getOption(context$2, scopeTag), {
	onNone: () => self(identity),
	onSome: (scope$2) => {
		if (concurrentFinalizers === true) {
			const patch$11 = strategy._tag === "Parallel" ? parallelFinalizers$1 : strategy._tag === "Sequential" ? sequentialFinalizers$1 : parallelNFinalizers(strategy.parallelism);
			switch (scope$2.strategy._tag) {
				case "Parallel": return patch$11(self(parallelFinalizers$1));
				case "Sequential": return patch$11(self(sequentialFinalizers$1));
				case "ParallelN": return patch$11(self(parallelNFinalizers(scope$2.strategy.parallelism)));
			}
		} else return self(identity);
	}
}));
const scopeWith$1 = (f) => flatMap$4(scopeTag, f);
/** @internal */
const scopedWith$1 = (f) => flatMap$4(scopeMake(), (scope$2) => onExit$2(f(scope$2), (exit$3) => scope$2.close(exit$3)));
const scopedEffect = (effect) => flatMap$4(scopeMake(), (scope$2) => scopeUse(effect, scope$2));
const sequentialFinalizers$1 = (self) => contextWithEffect$1((context$2) => match$10(getOption(context$2, scopeTag), {
	onNone: () => self,
	onSome: (scope$2) => {
		switch (scope$2.strategy._tag) {
			case "Sequential": return self;
			case "Parallel":
			case "ParallelN": return flatMap$4(scopeFork(scope$2, sequential), (inner) => scopeExtend(self, inner));
		}
	}
}));
const tagMetricsScoped$1 = (key, value) => labelMetricsScoped$1([make$16(key, value)]);
const labelMetricsScoped$1 = (labels) => fiberRefLocallyScopedWith(currentMetricLabels, (old) => union$8(old, labels));
const using$1 = /* @__PURE__ */ dual(2, (self, use$1) => scopedWith$1((scope$2) => flatMap$4(scopeExtend(self, scope$2), use$1)));
/** @internal */
const validate$1 = /* @__PURE__ */ dual((args$1) => isEffect$1(args$1[1]), (self, that, options) => validateWith$1(self, that, (a, b) => [a, b], options));
/** @internal */
const validateWith$1 = /* @__PURE__ */ dual((args$1) => isEffect$1(args$1[1]), (self, that, f, options) => flatten$3(zipWithOptions(exit$2(self), exit$2(that), (ea, eb) => exitZipWith(ea, eb, {
	onSuccess: f,
	onFailure: (ca, cb) => options?.concurrent ? parallel$2(ca, cb) : sequential$2(ca, cb)
}), options)));
const validateFirst$1 = /* @__PURE__ */ dual((args$1) => isIterable(args$1[0]), (elements, f, options) => flip$1(forEach$1(elements, (a, i) => flip$1(f(a, i)), options)));
const withClockScoped$1 = (c) => fiberRefLocallyScopedWith(currentServices, add$1(clockTag, c));
const withRandomScoped$1 = (value) => fiberRefLocallyScopedWith(currentServices, add$1(randomTag, value));
const withConfigProviderScoped$1 = (provider) => fiberRefLocallyScopedWith(currentServices, add$1(configProviderTag, provider));
const withEarlyRelease$1 = (self) => scopeWith$1((parent) => flatMap$4(scopeFork(parent, sequential$1), (child) => pipe(self, scopeExtend(child), map$8((value) => [fiberIdWith$1((fiberId$2) => scopeClose(child, exitInterrupt$1(fiberId$2))), value]))));
/** @internal */
const zipOptions = /* @__PURE__ */ dual((args$1) => isEffect$1(args$1[1]), (self, that, options) => zipWithOptions(self, that, (a, b) => [a, b], options));
/** @internal */
const zipLeftOptions = /* @__PURE__ */ dual((args$1) => isEffect$1(args$1[1]), (self, that, options) => {
	if (options?.concurrent !== true && (options?.batching === void 0 || options.batching === false)) return zipLeft$3(self, that);
	return zipWithOptions(self, that, (a, _) => a, options);
});
/** @internal */
const zipRightOptions = /* @__PURE__ */ dual((args$1) => isEffect$1(args$1[1]), (self, that, options) => {
	if (options?.concurrent !== true && (options?.batching === void 0 || options.batching === false)) return zipRight$3(self, that);
	return zipWithOptions(self, that, (_, b) => b, options);
});
/** @internal */
const zipWithOptions = /* @__PURE__ */ dual((args$1) => isEffect$1(args$1[1]), (self, that, f, options) => map$8(all$2([self, that], {
	concurrency: options?.concurrent ? 2 : 1,
	batching: options?.batching,
	concurrentFinalizers: options?.concurrentFinalizers
}), ([a, a2]) => f(a, a2)));
const withRuntimeFlagsScoped = (update$5) => {
	if (update$5 === empty$15) return void_$4;
	return pipe(runtimeFlags, flatMap$4((runtimeFlags$1) => {
		const updatedRuntimeFlags = patch$4(runtimeFlags$1, update$5);
		const revertRuntimeFlags = diff$3(updatedRuntimeFlags, runtimeFlags$1);
		return pipe(updateRuntimeFlags(update$5), zipRight$3(addFinalizer$2(() => updateRuntimeFlags(revertRuntimeFlags))), asVoid$3);
	}), uninterruptible$1);
};
/** @internal */
const scopeTag = /* @__PURE__ */ GenericTag("effect/Scope");
const scope$1 = scopeTag;
const scopeUnsafeAddFinalizer = (scope$2, fin) => {
	if (scope$2.state._tag === "Open") scope$2.state.finalizers.set({}, fin);
};
const ScopeImplProto = {
	[ScopeTypeId$1]: ScopeTypeId$1,
	[CloseableScopeTypeId$1]: CloseableScopeTypeId$1,
	pipe() {
		return pipeArguments(this, arguments);
	},
	fork(strategy) {
		return sync$3(() => {
			const newScope = scopeUnsafeMake(strategy);
			if (this.state._tag === "Closed") {
				newScope.state = this.state;
				return newScope;
			}
			const key = {};
			const fin = (exit$3) => newScope.close(exit$3);
			this.state.finalizers.set(key, fin);
			scopeUnsafeAddFinalizer(newScope, (_) => sync$3(() => {
				if (this.state._tag === "Open") this.state.finalizers.delete(key);
			}));
			return newScope;
		});
	},
	close(exit$3) {
		return suspend$3(() => {
			if (this.state._tag === "Closed") return void_$4;
			const finalizers = Array.from(this.state.finalizers.values()).reverse();
			this.state = {
				_tag: "Closed",
				exit: exit$3
			};
			if (finalizers.length === 0) return void_$4;
			return isSequential$1(this.strategy) ? pipe(forEachSequential(finalizers, (fin) => exit$2(fin(exit$3))), flatMap$4((results) => pipe(exitCollectAll(results), map$15(exitAsVoid), getOrElse$5(() => exitVoid$1)))) : isParallel$1(this.strategy) ? pipe(forEachParUnbounded(finalizers, (fin) => exit$2(fin(exit$3)), false), flatMap$4((results) => pipe(exitCollectAll(results, { parallel: true }), map$15(exitAsVoid), getOrElse$5(() => exitVoid$1)))) : pipe(forEachParN(finalizers, this.strategy.parallelism, (fin) => exit$2(fin(exit$3)), false), flatMap$4((results) => pipe(exitCollectAll(results, { parallel: true }), map$15(exitAsVoid), getOrElse$5(() => exitVoid$1))));
		});
	},
	addFinalizer(fin) {
		return suspend$3(() => {
			if (this.state._tag === "Closed") return fin(this.state.exit);
			this.state.finalizers.set({}, fin);
			return void_$4;
		});
	}
};
const scopeUnsafeMake = (strategy = sequential$1) => {
	const scope$2 = Object.create(ScopeImplProto);
	scope$2.strategy = strategy;
	scope$2.state = {
		_tag: "Open",
		finalizers: /* @__PURE__ */ new Map()
	};
	return scope$2;
};
const scopeMake = (strategy = sequential$1) => sync$3(() => scopeUnsafeMake(strategy));
const scopeExtend = /* @__PURE__ */ dual(2, (effect, scope$2) => mapInputContext$1(effect, merge$4(make$36(scopeTag, scope$2))));
const scopeUse = /* @__PURE__ */ dual(2, (effect, scope$2) => pipe(effect, scopeExtend(scope$2), onExit$2((exit$3) => scope$2.close(exit$3))));
/** @internal */
const fiberRefUnsafeMakeSupervisor = (initial) => fiberRefUnsafeMakePatch(initial, {
	differ,
	fork: empty$5
});
const fiberRefLocallyScoped = /* @__PURE__ */ dual(2, (self, value) => asVoid$3(acquireRelease$1(flatMap$4(fiberRefGet(self), (oldValue) => as$3(fiberRefSet(self, value), oldValue)), (oldValue) => fiberRefSet(self, oldValue))));
const fiberRefLocallyScopedWith = /* @__PURE__ */ dual(2, (self, f) => fiberRefGetWith(self, (a) => fiberRefLocallyScoped(self, f(a))));
/** @internal */
const currentRuntimeFlags = /* @__PURE__ */ fiberRefUnsafeMakeRuntimeFlags(none$5);
/** @internal */
const currentSupervisor = /* @__PURE__ */ fiberRefUnsafeMakeSupervisor(none$2);
const fiberAwaitAll = (fibers) => forEach$1(fibers, _await$2);
/** @internal */
const fiberAll = (fibers) => {
	return {
		...CommitPrototype,
		commit() {
			return join$1(this);
		},
		[FiberTypeId$1]: fiberVariance,
		id: () => fromIterable$10(fibers).reduce((id$2, fiber) => combine$9(id$2, fiber.id()), none$6),
		await: exit$2(forEachParUnbounded(fibers, (fiber) => flatten$3(fiber.await), false)),
		children: map$8(forEachParUnbounded(fibers, (fiber) => fiber.children, false), flatten$6),
		inheritAll: forEachSequentialDiscard(fibers, (fiber) => fiber.inheritAll),
		poll: map$8(forEachSequential(fibers, (fiber) => fiber.poll), reduceRight$3(some$4(exitSucceed$1(new Array())), (optionB, optionA) => {
			switch (optionA._tag) {
				case "None": return none$7();
				case "Some": switch (optionB._tag) {
					case "None": return none$7();
					case "Some": return some$4(exitZipWith(optionA.value, optionB.value, {
						onSuccess: (a, chunk$2) => [a, ...chunk$2],
						onFailure: parallel$2
					}));
				}
			}
		})),
		interruptAsFork: (fiberId$2) => forEachSequentialDiscard(fibers, (fiber) => fiber.interruptAsFork(fiberId$2))
	};
};
const fiberInterruptFork = (self) => asVoid$3(forkDaemon$1(interruptFiber(self)));
const fiberJoinAll = (fibers) => join$1(fiberAll(fibers));
const fiberScoped = (self) => acquireRelease$1(succeed$9(self), interruptFiber);
/** @internal */
const raceWith$1 = /* @__PURE__ */ dual(3, (self, other, options) => raceFibersWith(self, other, {
	onSelfWin: (winner, loser) => flatMap$4(winner.await, (exit$3) => {
		switch (exit$3._tag) {
			case OP_SUCCESS: return flatMap$4(winner.inheritAll, () => options.onSelfDone(exit$3, loser));
			case OP_FAILURE: return options.onSelfDone(exit$3, loser);
		}
	}),
	onOtherWin: (winner, loser) => flatMap$4(winner.await, (exit$3) => {
		switch (exit$3._tag) {
			case OP_SUCCESS: return flatMap$4(winner.inheritAll, () => options.onOtherDone(exit$3, loser));
			case OP_FAILURE: return options.onOtherDone(exit$3, loser);
		}
	})
}));
/** @internal */
const disconnect$1 = (self) => uninterruptibleMask$2((restore) => fiberIdWith$1((fiberId$2) => flatMap$4(forkDaemon$1(restore(self)), (fiber) => pipe(restore(join$1(fiber)), onInterrupt$1(() => pipe(fiber, interruptAsFork$1(fiberId$2)))))));
/** @internal */
const race$1 = /* @__PURE__ */ dual(2, (self, that) => fiberIdWith$1((parentFiberId) => raceWith$1(self, that, {
	onSelfDone: (exit$3, right$2) => exitMatchEffect(exit$3, {
		onFailure: (cause$2) => pipe(join$1(right$2), mapErrorCause$2((cause2) => parallel$2(cause$2, cause2))),
		onSuccess: (value) => pipe(right$2, interruptAsFiber(parentFiberId), as$3(value))
	}),
	onOtherDone: (exit$3, left$2) => exitMatchEffect(exit$3, {
		onFailure: (cause$2) => pipe(join$1(left$2), mapErrorCause$2((cause2) => parallel$2(cause2, cause$2))),
		onSuccess: (value) => pipe(left$2, interruptAsFiber(parentFiberId), as$3(value))
	})
})));
/** @internal */
const raceFibersWith = /* @__PURE__ */ dual(3, (self, other, options) => withFiberRuntime$1((parentFiber, parentStatus) => {
	const parentRuntimeFlags = parentStatus.runtimeFlags;
	const raceIndicator = make$34(true);
	const leftFiber = unsafeMakeChildFiber(self, parentFiber, parentRuntimeFlags, options.selfScope);
	const rightFiber = unsafeMakeChildFiber(other, parentFiber, parentRuntimeFlags, options.otherScope);
	return async_((cb) => {
		leftFiber.addObserver(() => completeRace(leftFiber, rightFiber, options.onSelfWin, raceIndicator, cb));
		rightFiber.addObserver(() => completeRace(rightFiber, leftFiber, options.onOtherWin, raceIndicator, cb));
		leftFiber.startFork(self);
		rightFiber.startFork(other);
	}, combine$9(leftFiber.id(), rightFiber.id()));
}));
const completeRace = (winner, loser, cont, ab, cb) => {
	if (compareAndSet(true, false)(ab)) cb(cont(winner, loser));
};
/** @internal */
const ensuring$1 = /* @__PURE__ */ dual(2, (self, finalizer) => uninterruptibleMask$2((restore) => matchCauseEffect$2(restore(self), {
	onFailure: (cause1) => matchCauseEffect$2(finalizer, {
		onFailure: (cause2) => failCause$8(sequential$2(cause1, cause2)),
		onSuccess: () => failCause$8(cause1)
	}),
	onSuccess: (a) => as$3(finalizer, a)
})));
/** @internal */
const invokeWithInterrupt = (self, entries$2, onInterrupt$2) => fiberIdWith$1((id$2) => flatMap$4(flatMap$4(forkDaemon$1(interruptible$2(self)), (processing) => async_((cb) => {
	const counts = entries$2.map((_) => _.listeners.count);
	const checkDone = () => {
		if (counts.every((count) => count === 0)) {
			if (entries$2.every((_) => {
				if (_.result.state.current._tag === "Pending") return true;
				else if (_.result.state.current._tag === "Done" && exitIsExit(_.result.state.current.effect) && _.result.state.current.effect._tag === "Failure" && isInterrupted$1(_.result.state.current.effect.cause)) return true;
				else return false;
			})) {
				cleanup.forEach((f) => f());
				onInterrupt$2?.();
				cb(interruptFiber(processing));
			}
		}
	};
	processing.addObserver((exit$3) => {
		cleanup.forEach((f) => f());
		cb(exit$3);
	});
	const cleanup = entries$2.map((r, i) => {
		const observer = (count) => {
			counts[i] = count;
			checkDone();
		};
		r.listeners.addObserver(observer);
		return () => r.listeners.removeObserver(observer);
	});
	checkDone();
	return sync$3(() => {
		cleanup.forEach((f) => f());
	});
})), () => suspend$3(() => {
	const residual = entries$2.flatMap((entry) => {
		if (!entry.state.completed) return [entry];
		return [];
	});
	return forEachSequentialDiscard(residual, (entry) => complete$3(entry.request, exitInterrupt$1(id$2)));
})));
/** @internal */
const interruptWhenPossible$1 = /* @__PURE__ */ dual(2, (self, all$6) => fiberRefGetWith(currentRequestMap, (map$17) => suspend$3(() => {
	const entries$2 = fromIterable$10(all$6).flatMap((_) => map$17.has(_) ? [map$17.get(_)] : []);
	return invokeWithInterrupt(self, entries$2);
})));
/** @internal */
const makeSpanScoped$1 = (name, options) => {
	options = addSpanStackTrace(options);
	return uninterruptible$1(withFiberRuntime$1((fiber) => {
		const scope$2 = unsafeGet$1(fiber.getFiberRef(currentContext), scopeTag);
		const span$1 = unsafeMakeSpan(fiber, name, options);
		const timingEnabled = fiber.getFiberRef(currentTracerTimingEnabled);
		const clock_ = get$7(fiber.getFiberRef(currentServices), clockTag);
		return as$3(scopeAddFinalizerExit(scope$2, (exit$3) => endSpan(span$1, exit$3, clock_, timingEnabled)), span$1);
	}));
};
const withTracerScoped$1 = (value) => fiberRefLocallyScopedWith(currentServices, add$1(tracerTag, value));
/** @internal */
const withSpanScoped$1 = function() {
	const dataFirst = typeof arguments[0] !== "string";
	const name = dataFirst ? arguments[1] : arguments[0];
	const options = addSpanStackTrace(dataFirst ? arguments[2] : arguments[1]);
	if (dataFirst) {
		const self = arguments[0];
		return flatMap$4(makeSpanScoped$1(name, addSpanStackTrace(options)), (span$1) => provideService$1(self, spanTag, span$1));
	}
	return (self) => flatMap$4(makeSpanScoped$1(name, addSpanStackTrace(options)), (span$1) => provideService$1(self, spanTag, span$1));
};

//#endregion
//#region ../../node_modules/.bun/effect@3.17.14/node_modules/effect/dist/esm/internal/schedule/interval.js
/** @internal */
const IntervalSymbolKey = "effect/ScheduleInterval";
/** @internal */
const IntervalTypeId$1 = /* @__PURE__ */ Symbol.for(IntervalSymbolKey);
/** @internal */
const empty$4 = {
	[IntervalTypeId$1]: IntervalTypeId$1,
	startMillis: 0,
	endMillis: 0
};
/** @internal */
const make$9 = (startMillis, endMillis) => {
	if (startMillis > endMillis) return empty$4;
	return {
		[IntervalTypeId$1]: IntervalTypeId$1,
		startMillis,
		endMillis
	};
};
/** @internal */
const lessThan$3 = /* @__PURE__ */ dual(2, (self, that) => min$1(self, that) === self);
/** @internal */
const min$1 = /* @__PURE__ */ dual(2, (self, that) => {
	if (self.endMillis <= that.startMillis) return self;
	if (that.endMillis <= self.startMillis) return that;
	if (self.startMillis < that.startMillis) return self;
	if (that.startMillis < self.startMillis) return that;
	if (self.endMillis <= that.endMillis) return self;
	return that;
});
/** @internal */
const max$3 = /* @__PURE__ */ dual(2, (self, that) => min$1(self, that) === self ? that : self);
/** @internal */
const isEmpty$2 = (self) => {
	return self.startMillis >= self.endMillis;
};
/** @internal */
const isNonEmpty$4 = (self) => {
	return !isEmpty$2(self);
};
/** @internal */
const intersect$4 = /* @__PURE__ */ dual(2, (self, that) => {
	const start$2 = Math.max(self.startMillis, that.startMillis);
	const end$2 = Math.min(self.endMillis, that.endMillis);
	return make$9(start$2, end$2);
});
/** @internal */
const size$1 = (self) => {
	return millis(self.endMillis - self.startMillis);
};
/** @internal */
const union$3 = /* @__PURE__ */ dual(2, (self, that) => {
	const start$2 = Math.max(self.startMillis, that.startMillis);
	const end$2 = Math.min(self.endMillis, that.endMillis);
	return start$2 < end$2 ? none$7() : some$4(make$9(start$2, end$2));
});
/** @internal */
const after$1 = (startMilliseconds) => {
	return make$9(startMilliseconds, Number.POSITIVE_INFINITY);
};
/** @internal */
const before$1 = (endMilliseconds) => {
	return make$9(Number.NEGATIVE_INFINITY, endMilliseconds);
};

//#endregion
//#region ../../node_modules/.bun/effect@3.17.14/node_modules/effect/dist/esm/ScheduleInterval.js
/**
* @since 2.0.0
* @category symbols
*/
const IntervalTypeId = IntervalTypeId$1;
/**
* Constructs a new interval from the two specified endpoints. If the start
* endpoint greater than the end endpoint, then a zero size interval will be
* returned.
*
* @since 2.0.0
* @category constructors
*/
const make$8 = make$9;
/**
* An `Interval` of zero-width.
*
* @since 2.0.0
* @category constructors
*/
const empty$3 = empty$4;
/**
* Returns `true` if this `Interval` is less than `that` interval, `false`
* otherwise.
*
* @since 2.0.0
* @category ordering
*/
const lessThan$2 = lessThan$3;
/**
* Returns the minimum of two `Interval`s.
*
* @since 2.0.0
* @category ordering
*/
const min = min$1;
/**
* Returns the maximum of two `Interval`s.
*
* @since 2.0.0
* @category ordering
*/
const max$2 = max$3;
/**
* Returns `true` if the specified `Interval` is empty, `false` otherwise.
*
* @since 2.0.0
* @category ordering
*/
const isEmpty$1 = isEmpty$2;
/**
* Returns `true` if the specified `Interval` is non-empty, `false` otherwise.
*
* @since 2.0.0
* @category ordering
*/
const isNonEmpty$3 = isNonEmpty$4;
/**
* Computes a new `Interval` which is the intersection of this `Interval` and
* that `Interval`.
*
* @since 2.0.0
* @category ordering
*/
const intersect$3 = intersect$4;
/**
* Calculates the size of the `Interval` as the `Duration` from the start of the
* interval to the end of the interval.
*
* @since 2.0.0
* @category getters
*/
const size = size$1;
/**
* Computes a new `Interval` which is the union of this `Interval` and that
* `Interval` as a `Some`, otherwise returns `None` if the two intervals cannot
* form a union.
*
* @since 2.0.0
* @category utils
*/
const union$2 = union$3;
/**
* Construct an `Interval` that includes all time equal to and after the
* specified start time.
*
* @since 2.0.0
* @category constructors
*/
const after = after$1;
/**
* Construct an `Interval` that includes all time equal to and before the
* specified end time.
*
* @category constructors
* @since 2.0.0
*/
const before = before$1;

//#endregion
//#region ../../node_modules/.bun/effect@3.17.14/node_modules/effect/dist/esm/internal/schedule/intervals.js
/** @internal */
const IntervalsSymbolKey = "effect/ScheduleIntervals";
/** @internal */
const IntervalsTypeId$1 = /* @__PURE__ */ Symbol.for(IntervalsSymbolKey);
/** @internal */
const make$7 = (intervals) => {
	return {
		[IntervalsTypeId$1]: IntervalsTypeId$1,
		intervals
	};
};
/** @internal */
const empty$2 = /* @__PURE__ */ make$7(/* @__PURE__ */ empty$31());
/** @internal */
const fromIterable$1 = (intervals) => Array.from(intervals).reduce((intervals$1, interval) => pipe(intervals$1, union$1(make$7(of$3(interval)))), empty$2);
/** @internal */
const union$1 = /* @__PURE__ */ dual(2, (self, that) => {
	if (!isNonEmpty$5(that.intervals)) return self;
	if (!isNonEmpty$5(self.intervals)) return that;
	if (headNonEmpty(self.intervals).startMillis < headNonEmpty(that.intervals).startMillis) return unionLoop(tailNonEmpty(self.intervals), that.intervals, headNonEmpty(self.intervals), empty$31());
	return unionLoop(self.intervals, tailNonEmpty(that.intervals), headNonEmpty(that.intervals), empty$31());
});
/** @internal */
const unionLoop = (_self, _that, _interval, _acc) => {
	let self = _self;
	let that = _that;
	let interval = _interval;
	let acc = _acc;
	while (isNonEmpty$5(self) || isNonEmpty$5(that)) if (!isNonEmpty$5(self) && isNonEmpty$5(that)) if (interval.endMillis < headNonEmpty(that).startMillis) {
		acc = pipe(acc, prepend$1(interval));
		interval = headNonEmpty(that);
		that = tailNonEmpty(that);
		self = empty$31();
	} else {
		interval = make$8(interval.startMillis, headNonEmpty(that).endMillis);
		that = tailNonEmpty(that);
		self = empty$31();
	}
	else if (isNonEmpty$5(self) && isEmpty$8(that)) if (interval.endMillis < headNonEmpty(self).startMillis) {
		acc = pipe(acc, prepend$1(interval));
		interval = headNonEmpty(self);
		that = empty$31();
		self = tailNonEmpty(self);
	} else {
		interval = make$8(interval.startMillis, headNonEmpty(self).endMillis);
		that = empty$31();
		self = tailNonEmpty(self);
	}
	else if (isNonEmpty$5(self) && isNonEmpty$5(that)) if (headNonEmpty(self).startMillis < headNonEmpty(that).startMillis) if (interval.endMillis < headNonEmpty(self).startMillis) {
		acc = pipe(acc, prepend$1(interval));
		interval = headNonEmpty(self);
		self = tailNonEmpty(self);
	} else {
		interval = make$8(interval.startMillis, headNonEmpty(self).endMillis);
		self = tailNonEmpty(self);
	}
	else if (interval.endMillis < headNonEmpty(that).startMillis) {
		acc = pipe(acc, prepend$1(interval));
		interval = headNonEmpty(that);
		that = tailNonEmpty(that);
	} else {
		interval = make$8(interval.startMillis, headNonEmpty(that).endMillis);
		that = tailNonEmpty(that);
	}
	else throw new Error(getBugErrorMessage("Intervals.unionLoop"));
	return make$7(pipe(acc, prepend$1(interval), reverse$1));
};
/** @internal */
const intersect$2 = /* @__PURE__ */ dual(2, (self, that) => intersectLoop(self.intervals, that.intervals, empty$31()));
/** @internal */
const intersectLoop = (_left, _right, _acc) => {
	let left$2 = _left;
	let right$2 = _right;
	let acc = _acc;
	while (isNonEmpty$5(left$2) && isNonEmpty$5(right$2)) {
		const interval = pipe(headNonEmpty(left$2), intersect$3(headNonEmpty(right$2)));
		const intervals = isEmpty$1(interval) ? acc : pipe(acc, prepend$1(interval));
		if (pipe(headNonEmpty(left$2), lessThan$2(headNonEmpty(right$2)))) left$2 = tailNonEmpty(left$2);
		else right$2 = tailNonEmpty(right$2);
		acc = intervals;
	}
	return make$7(reverse$1(acc));
};
/** @internal */
const start$1 = (self) => {
	return pipe(self.intervals, head$2, getOrElse$5(() => empty$3)).startMillis;
};
/** @internal */
const end$1 = (self) => {
	return pipe(self.intervals, head$2, getOrElse$5(() => empty$3)).endMillis;
};
/** @internal */
const lessThan$1 = /* @__PURE__ */ dual(2, (self, that) => start$1(self) < start$1(that));
/** @internal */
const isNonEmpty$2 = (self) => {
	return isNonEmpty$5(self.intervals);
};
/** @internal */
const max$1 = /* @__PURE__ */ dual(2, (self, that) => lessThan$1(self, that) ? that : self);

//#endregion
//#region ../../node_modules/.bun/effect@3.17.14/node_modules/effect/dist/esm/ScheduleIntervals.js
/**
* @since 2.0.0
* @category symbols
*/
const IntervalsTypeId = IntervalsTypeId$1;
/**
* Creates a new `Intervals` from a `List` of `Interval`s.
*
* @since 2.0.0
* @category constructors
*/
const make$6 = make$7;
/**
* Constructs an empty list of `Interval`s.
*
* @since 2.0.0
* @category constructors
*/
const empty$1 = empty$2;
/**
* Creates `Intervals` from the specified `Iterable<Interval>`.
*
* @since 2.0.0
* @category constructors
*/
const fromIterable = fromIterable$1;
/**
* Computes the union of this `Intervals` and  that `Intervals`
*
* @since 2.0.0
* @category utils
*/
const union = union$1;
/**
* Produces the intersection of this `Intervals` and that `Intervals`.
*
* @since 2.0.0
* @category utils
*/
const intersect$1 = intersect$2;
/**
* The start of the earliest interval in the specified `Intervals`.
*
* @since 2.0.0
* @category getters
*/
const start = start$1;
/**
* The end of the latest interval in the specified `Intervals`.
*
* @since 2.0.0
* @category getters
*/
const end = end$1;
/**
* Returns `true` if the start of this `Intervals` is before the start of that
* `Intervals`, `false` otherwise.
*
* @since 2.0.0
* @category ordering
*/
const lessThan = lessThan$1;
/**
* Returns `true` if this `Intervals` is non-empty, `false` otherwise.
*
* @since 2.0.0
* @category getters
*/
const isNonEmpty$1 = isNonEmpty$2;
/**
* Returns the maximum of the two `Intervals` (i.e. which has the latest start).
*
* @since 2.0.0
* @category ordering
*/
const max = max$1;

//#endregion
//#region ../../node_modules/.bun/effect@3.17.14/node_modules/effect/dist/esm/internal/schedule/decision.js
/** @internal */
const OP_CONTINUE = "Continue";
/** @internal */
const OP_DONE = "Done";
/** @internal */
const _continue$1 = (intervals) => {
	return {
		_tag: OP_CONTINUE,
		intervals
	};
};
/** @internal */
const continueWith$1 = (interval) => {
	return {
		_tag: OP_CONTINUE,
		intervals: make$6(of$3(interval))
	};
};
/** @internal */
const done$3 = { _tag: OP_DONE };
/** @internal */
const isContinue$1 = (self) => {
	return self._tag === OP_CONTINUE;
};
/** @internal */
const isDone$2 = (self) => {
	return self._tag === OP_DONE;
};

//#endregion
//#region ../../node_modules/.bun/effect@3.17.14/node_modules/effect/dist/esm/ScheduleDecision.js
const _continue = _continue$1;
/**
* @since 2.0.0
* @category constructors
*/
const continueWith = continueWith$1;
/**
* @since 2.0.0
* @category constructors
*/
const done$2 = done$3;
/**
* @since 2.0.0
* @category refinements
*/
const isContinue = isContinue$1;
/**
* @since 2.0.0
* @category refinements
*/
const isDone$1 = isDone$2;

//#endregion
//#region ../../node_modules/.bun/effect@3.17.14/node_modules/effect/dist/esm/Scope.js
/**
* A unique identifier for the `Scope` type.
*
* @since 2.0.0
* @category symbols
*/
const ScopeTypeId = ScopeTypeId$1;
/**
* A unique identifier for the `CloseableScope` type.
*
* @since 2.0.0
* @category symbols
*/
const CloseableScopeTypeId = CloseableScopeTypeId$1;
/**
* A tag representing the current `Scope` in the environment.
*
* @since 2.0.0
* @category context
*/
const Scope = scopeTag;
/**
* Adds a finalizer to this scope. The finalizer is guaranteed to be run when
* the scope is closed. Use this when the finalizer does not need to know the
* `Exit` value that the scope is closed with.
*
* @see {@link addFinalizerExit}
*
* @since 2.0.0
* @category utils
*/
const addFinalizer$1 = scopeAddFinalizer;
/**
* Adds a finalizer to this scope. The finalizer receives the `Exit` value
* when the scope is closed, allowing it to perform different actions based
* on the exit status.
*
* @see {@link addFinalizer}
*
* @since 2.0.0
* @category utils
*/
const addFinalizerExit = scopeAddFinalizerExit;
/**
* Closes this scope with the specified exit value, running all finalizers that
* have been added to the scope.
*
* @since 2.0.0
* @category destructors
*/
const close = scopeClose;
/**
* Extends the scope of an `Effect` that requires a scope into this scope.
* It provides this scope to the effect but does not close the scope when the
* effect completes execution. This allows extending a scoped value into a
* larger scope.
*
* @since 2.0.0
* @category utils
*/
const extend = scopeExtend;
/**
* Forks a new child scope with the specified execution strategy. The child scope
* will automatically be closed when this scope is closed.
*
* @since 2.0.0
* @category utils
*/
const fork$1 = scopeFork;
/**
* Provides this closeable scope to an `Effect` that requires a scope,
* guaranteeing that the scope is closed with the result of that effect as
* soon as the effect completes execution, whether by success, failure, or
* interruption.
*
* @since 2.0.0
* @category destructors
*/
const use = scopeUse;
/**
* Creates a new closeable scope where finalizers will run according to the
* specified `ExecutionStrategy`. If no execution strategy is provided, `sequential`
* will be used by default.
*
* @since 2.0.0
* @category constructors
*/
const make$5 = scopeMake;

//#endregion
//#region ../../node_modules/.bun/effect@3.17.14/node_modules/effect/dist/esm/internal/effect/circular.js
/** @internal */
var Semaphore = class {
	permits;
	waiters = /* @__PURE__ */ new Set();
	taken = 0;
	constructor(permits) {
		this.permits = permits;
	}
	get free() {
		return this.permits - this.taken;
	}
	take = (n) => asyncInterrupt((resume$1) => {
		if (this.free < n) {
			const observer = () => {
				if (this.free < n) return;
				this.waiters.delete(observer);
				this.taken += n;
				resume$1(succeed$9(n));
			};
			this.waiters.add(observer);
			return sync$3(() => {
				this.waiters.delete(observer);
			});
		}
		this.taken += n;
		return resume$1(succeed$9(n));
	});
	updateTaken = (f) => withFiberRuntime$1((fiber) => {
		this.taken = f(this.taken);
		if (this.waiters.size > 0) fiber.getFiberRef(currentScheduler).scheduleTask(() => {
			const iter = this.waiters.values();
			let item = iter.next();
			while (item.done === false && this.free > 0) {
				item.value();
				item = iter.next();
			}
		}, fiber.getFiberRef(currentSchedulingPriority));
		return succeed$9(this.free);
	});
	release = (n) => this.updateTaken((taken) => taken - n);
	releaseAll = /* @__PURE__ */ this.updateTaken((_) => 0);
	withPermits = (n) => (self) => uninterruptibleMask$2((restore) => flatMap$4(restore(this.take(n)), (permits) => ensuring$1(restore(self), this.release(permits))));
	withPermitsIfAvailable = (n) => (self) => uninterruptibleMask$2((restore) => suspend$3(() => {
		if (this.free < n) return succeedNone$1;
		this.taken += n;
		return ensuring$1(restore(asSome$1(self)), this.release(n));
	}));
};
/** @internal */
const unsafeMakeSemaphore$1 = (permits) => new Semaphore(permits);
/** @internal */
const makeSemaphore$1 = (permits) => sync$3(() => unsafeMakeSemaphore$1(permits));
var Latch = class extends Class$2 {
	isOpen;
	waiters = [];
	scheduled = false;
	constructor(isOpen) {
		super();
		this.isOpen = isOpen;
	}
	commit() {
		return this.await;
	}
	unsafeSchedule(fiber) {
		if (this.scheduled || this.waiters.length === 0) return void_$4;
		this.scheduled = true;
		fiber.currentScheduler.scheduleTask(this.flushWaiters, fiber.getFiberRef(currentSchedulingPriority));
		return void_$4;
	}
	flushWaiters = () => {
		this.scheduled = false;
		const waiters = this.waiters;
		this.waiters = [];
		for (let i = 0; i < waiters.length; i++) waiters[i](exitVoid$1);
	};
	open = /* @__PURE__ */ withFiberRuntime$1((fiber) => {
		if (this.isOpen) return void_$4;
		this.isOpen = true;
		return this.unsafeSchedule(fiber);
	});
	unsafeOpen() {
		if (this.isOpen) return;
		this.isOpen = true;
		this.flushWaiters();
	}
	release = /* @__PURE__ */ withFiberRuntime$1((fiber) => {
		if (this.isOpen) return void_$4;
		return this.unsafeSchedule(fiber);
	});
	await = /* @__PURE__ */ asyncInterrupt((resume$1) => {
		if (this.isOpen) return resume$1(void_$4);
		this.waiters.push(resume$1);
		return sync$3(() => {
			const index = this.waiters.indexOf(resume$1);
			if (index !== -1) this.waiters.splice(index, 1);
		});
	});
	unsafeClose() {
		this.isOpen = false;
	}
	close = /* @__PURE__ */ sync$3(() => {
		this.isOpen = false;
	});
	whenOpen = (self) => {
		return zipRight$3(this.await, self);
	};
};
/** @internal */
const unsafeMakeLatch$1 = (open) => new Latch(open ?? false);
/** @internal */
const makeLatch$1 = (open) => sync$3(() => unsafeMakeLatch$1(open));
/** @internal */
const awaitAllChildren$1 = (self) => ensuringChildren$1(self, fiberAwaitAll);
/** @internal */
const cached$1 = /* @__PURE__ */ dual(2, (self, timeToLive) => map$8(cachedInvalidateWithTTL$1(self, timeToLive), (tuple$2) => tuple$2[0]));
/** @internal */
const cachedInvalidateWithTTL$1 = /* @__PURE__ */ dual(2, (self, timeToLive) => {
	const duration = decode$3(timeToLive);
	return flatMap$4(context$1(), (env) => map$8(makeSynchronized(none$7()), (cache) => [provideContext$1(getCachedValue(self, duration, cache), env), invalidateCache(cache)]));
});
/** @internal */
const computeCachedValue = (self, timeToLive, start$2) => {
	const timeToLiveMillis = toMillis(decode$3(timeToLive));
	return pipe(deferredMake(), tap$1((deferred) => intoDeferred$1(self, deferred)), map$8((deferred) => some$4([start$2 + timeToLiveMillis, deferred])));
};
/** @internal */
const getCachedValue = (self, timeToLive, cache) => uninterruptibleMask$2((restore) => pipe(clockWith$1((clock$2) => clock$2.currentTimeMillis), flatMap$4((time) => updateSomeAndGetEffectSynchronized(cache, (option$2) => {
	switch (option$2._tag) {
		case "None": return some$4(computeCachedValue(self, timeToLive, time));
		case "Some": {
			const [end$2] = option$2.value;
			return end$2 - time <= 0 ? some$4(computeCachedValue(self, timeToLive, time)) : none$7();
		}
	}
})), flatMap$4((option$2) => isNone$2(option$2) ? dieMessage$1("BUG: Effect.cachedInvalidate - please report an issue at https://github.com/Effect-TS/effect/issues") : restore(deferredAwait(option$2.value[1])))));
/** @internal */
const invalidateCache = (cache) => set$2(cache, none$7());
/** @internal */
const ensuringChild$1 = /* @__PURE__ */ dual(2, (self, f) => ensuringChildren$1(self, (children$2) => f(fiberAll(children$2))));
/** @internal */
const ensuringChildren$1 = /* @__PURE__ */ dual(2, (self, children$2) => flatMap$4(track, (supervisor) => pipe(supervised$1(self, supervisor), ensuring$1(flatMap$4(supervisor.value, children$2)))));
/** @internal */
const forkAll$1 = /* @__PURE__ */ dual((args$1) => isIterable(args$1[0]), (effects, options) => options?.discard ? forEachSequentialDiscard(effects, fork$2) : map$8(forEachSequential(effects, fork$2), fiberAll));
/** @internal */
const forkIn$1 = /* @__PURE__ */ dual(2, (self, scope$2) => withFiberRuntime$1((parent, parentStatus) => {
	const scopeImpl = scope$2;
	const fiber = unsafeFork$1(self, parent, parentStatus.runtimeFlags, globalScope);
	if (scopeImpl.state._tag === "Open") {
		const finalizer = () => fiberIdWith$1((fiberId$2) => equals(fiberId$2, fiber.id()) ? void_$4 : asVoid$3(interruptFiber(fiber)));
		const key = {};
		scopeImpl.state.finalizers.set(key, finalizer);
		fiber.addObserver(() => {
			if (scopeImpl.state._tag === "Closed") return;
			scopeImpl.state.finalizers.delete(key);
		});
	} else fiber.unsafeInterruptAsFork(parent.id());
	return succeed$9(fiber);
}));
/** @internal */
const forkScoped$1 = (self) => scopeWith$1((scope$2) => forkIn$1(self, scope$2));
/** @internal */
const fromFiber$1 = (fiber) => join$1(fiber);
/** @internal */
const fromFiberEffect$1 = (fiber) => suspend$3(() => flatMap$4(fiber, join$1));
const memoKeySymbol = /* @__PURE__ */ Symbol.for("effect/Effect/memoizeFunction.key");
var Key = class {
	a;
	eq;
	[memoKeySymbol] = memoKeySymbol;
	constructor(a, eq) {
		this.a = a;
		this.eq = eq;
	}
	[symbol](that) {
		if (hasProperty(that, memoKeySymbol)) if (this.eq) return this.eq(this.a, that.a);
		else return equals(this.a, that.a);
		return false;
	}
	[symbol$1]() {
		return this.eq ? 0 : cached$2(this, hash(this.a));
	}
};
/** @internal */
const cachedFunction$1 = (f, eq) => {
	return pipe(sync$3(() => empty$8()), flatMap$4(makeSynchronized), map$8((ref) => (a) => pipe(ref.modifyEffect((map$17) => {
		const result = pipe(map$17, get(new Key(a, eq)));
		if (isNone$2(result)) return pipe(deferredMake(), tap$1((deferred) => pipe(diffFiberRefs$1(f(a)), intoDeferred$1(deferred), fork$2)), map$8((deferred) => [deferred, pipe(map$17, set(new Key(a, eq), deferred))]));
		return succeed$9([result.value, map$17]);
	}), flatMap$4(deferredAwait), flatMap$4(([patch$11, b]) => pipe(patchFiberRefs$1(patch$11), as$3(b))))));
};
/** @internal */
const raceFirst$1 = /* @__PURE__ */ dual(2, (self, that) => pipe(exit$2(self), race$1(exit$2(that)), (effect) => flatten$3(effect)));
/** @internal */
const supervised$1 = /* @__PURE__ */ dual(2, (self, supervisor) => {
	return fiberRefLocallyWith(currentSupervisor, (s) => s.zip(supervisor))(self);
});
/** @internal */
const timeout$1 = /* @__PURE__ */ dual(2, (self, duration) => timeoutFail$1(self, {
	onTimeout: () => timeoutExceptionFromDuration(duration),
	duration
}));
/** @internal */
const timeoutFail$1 = /* @__PURE__ */ dual(2, (self, { duration, onTimeout }) => flatten$3(timeoutTo$1(self, {
	onTimeout: () => failSync$2(onTimeout),
	onSuccess: succeed$9,
	duration
})));
/** @internal */
const timeoutFailCause$1 = /* @__PURE__ */ dual(2, (self, { duration, onTimeout }) => flatten$3(timeoutTo$1(self, {
	onTimeout: () => failCauseSync$2(onTimeout),
	onSuccess: succeed$9,
	duration
})));
/** @internal */
const timeoutOption$1 = /* @__PURE__ */ dual(2, (self, duration) => timeoutTo$1(self, {
	duration,
	onSuccess: some$4,
	onTimeout: none$7
}));
/** @internal */
const timeoutTo$1 = /* @__PURE__ */ dual(2, (self, { duration, onSuccess, onTimeout }) => fiberIdWith$1((parentFiberId) => uninterruptibleMask$2((restore) => raceFibersWith(restore(self), interruptible$2(sleep$1(duration)), {
	onSelfWin: (winner, loser) => flatMap$4(winner.await, (exit$3) => {
		if (exit$3._tag === "Success") return flatMap$4(winner.inheritAll, () => as$3(interruptAsFiber(loser, parentFiberId), onSuccess(exit$3.value)));
		else return flatMap$4(interruptAsFiber(loser, parentFiberId), () => exitFailCause$1(exit$3.cause));
	}),
	onOtherWin: (winner, loser) => flatMap$4(winner.await, (exit$3) => {
		if (exit$3._tag === "Success") return flatMap$4(winner.inheritAll, () => as$3(interruptAsFiber(loser, parentFiberId), onTimeout()));
		else return flatMap$4(interruptAsFiber(loser, parentFiberId), () => exitFailCause$1(exit$3.cause));
	}),
	otherScope: globalScope
}))));
/** @internal */
const SynchronizedSymbolKey = "effect/Ref/SynchronizedRef";
/** @internal */
const SynchronizedTypeId = /* @__PURE__ */ Symbol.for(SynchronizedSymbolKey);
/** @internal */
const synchronizedVariance = { _A: (_) => _ };
/** @internal */
var SynchronizedImpl = class extends Class$2 {
	ref;
	withLock;
	[SynchronizedTypeId] = synchronizedVariance;
	[RefTypeId$1] = refVariance;
	[TypeId$7] = TypeId$7;
	constructor(ref, withLock) {
		super();
		this.ref = ref;
		this.withLock = withLock;
		this.get = get$2(this.ref);
	}
	get;
	commit() {
		return this.get;
	}
	modify(f) {
		return this.modifyEffect((a) => succeed$9(f(a)));
	}
	modifyEffect(f) {
		return this.withLock(pipe(flatMap$4(get$2(this.ref), f), flatMap$4(([b, a]) => as$3(set$2(this.ref, a), b))));
	}
};
/** @internal */
const makeSynchronized = (value) => sync$3(() => unsafeMakeSynchronized(value));
/** @internal */
const unsafeMakeSynchronized = (value) => {
	const ref = unsafeMake$4(value);
	const sem = unsafeMakeSemaphore$1(1);
	return new SynchronizedImpl(ref, sem.withPermits(1));
};
/** @internal */
const updateSomeAndGetEffectSynchronized = /* @__PURE__ */ dual(2, (self, pf) => self.modifyEffect((value) => {
	const result = pf(value);
	switch (result._tag) {
		case "None": return succeed$9([value, value]);
		case "Some": return map$8(result.value, (a) => [a, a]);
	}
}));
/** @internal */
const zipFiber = /* @__PURE__ */ dual(2, (self, that) => zipWithFiber(self, that, (a, b) => [a, b]));
/** @internal */
const zipLeftFiber = /* @__PURE__ */ dual(2, (self, that) => zipWithFiber(self, that, (a, _) => a));
/** @internal */
const zipRightFiber = /* @__PURE__ */ dual(2, (self, that) => zipWithFiber(self, that, (_, b) => b));
/** @internal */
const zipWithFiber = /* @__PURE__ */ dual(3, (self, that, f) => ({
	...CommitPrototype,
	commit() {
		return join$1(this);
	},
	[FiberTypeId$1]: fiberVariance,
	id: () => pipe(self.id(), getOrElse$1(that.id())),
	await: pipe(self.await, flatten$3, zipWithOptions(flatten$3(that.await), f, { concurrent: true }), exit$2),
	children: self.children,
	inheritAll: zipRight$3(that.inheritAll, self.inheritAll),
	poll: zipWith$4(self.poll, that.poll, (optionA, optionB) => pipe(optionA, flatMap$11((exitA) => pipe(optionB, map$15((exitB) => zipWith$3(exitA, exitB, {
		onSuccess: f,
		onFailure: parallel$2
	})))))),
	interruptAsFork: (id$2) => zipRight$3(self.interruptAsFork(id$2), that.interruptAsFork(id$2)),
	pipe() {
		return pipeArguments(this, arguments);
	}
}));
const bindAll$1 = /* @__PURE__ */ dual((args$1) => isEffect$1(args$1[0]), (self, f, options) => flatMap$4(self, (a) => all$2(f(a), options).pipe(map$8((record$1) => Object.assign({}, a, record$1)))));

//#endregion
//#region ../../node_modules/.bun/effect@3.17.14/node_modules/effect/dist/esm/internal/managedRuntime/circular.js
/** @internal */
const TypeId$3 = /* @__PURE__ */ Symbol.for("effect/ManagedRuntime");

//#endregion
//#region ../../node_modules/.bun/effect@3.17.14/node_modules/effect/dist/esm/internal/opCodes/layer.js
/** @internal */
const OP_FRESH = "Fresh";
/** @internal */
const OP_SUSPEND = "Suspend";
/** @internal */
const OP_ZIP_WITH = "ZipWith";

//#endregion
//#region ../../node_modules/.bun/effect@3.17.14/node_modules/effect/dist/esm/Fiber.js
/**
* @since 2.0.0
* @category symbols
*/
const FiberTypeId = FiberTypeId$1;
/**
* @since 2.0.0
* @category symbols
*/
const RuntimeFiberTypeId = RuntimeFiberTypeId$1;
/**
* @since 2.0.0
* @category instances
*/
const Order = Order$1;
/**
* Returns `true` if the specified value is a `Fiber`, `false` otherwise.
*
* @since 2.0.0
* @category refinements
*/
const isFiber = isFiber$1;
/**
* Returns `true` if the specified `Fiber` is a `RuntimeFiber`, `false`
* otherwise.
*
* @since 2.0.0
* @category refinements
*/
const isRuntimeFiber = isRuntimeFiber$1;
/**
* The identity of the fiber.
*
* @since 2.0.0
* @category getters
*/
const id = id$1;
const _await$1 = _await$2;
/**
* Awaits on all fibers to be completed, successfully or not.
*
* @since 2.0.0
* @category destructors
*/
const awaitAll = fiberAwaitAll;
/**
* Retrieves the immediate children of the fiber.
*
* @since 2.0.0
* @category getters
*/
const children = children$1;
/**
* Collects all fibers into a single fiber producing an in-order list of the
* results.
*
* @since 2.0.0
* @category constructors
*/
const all$1 = fiberAll;
/**
* A fiber that is done with the specified `Exit` value.
*
* @since 2.0.0
* @category constructors
*/
const done$1 = done$4;
/**
* @since 2.0.0
* @category destructors
*/
const dump = dump$1;
/**
* @since 2.0.0
* @category destructors
*/
const dumpAll = dumpAll$1;
/**
* A fiber that has already failed with the specified value.
*
* @since 2.0.0
* @category constructors
*/
const fail$4 = fail$6;
/**
* Creates a `Fiber` that has already failed with the specified cause.
*
* @since 2.0.0
* @category constructors
*/
const failCause$3 = failCause$5;
/**
* Lifts an `Effect` into a `Fiber`.
*
* @since 2.0.0
* @category conversions
*/
const fromEffect = fromEffect$2;
/**
* Gets the current fiber if one is running.
*
* @since 2.0.0
* @category utilities
*/
const getCurrentFiber = getCurrentFiber$1;
/**
* Inherits values from all `FiberRef` instances into current fiber. This
* will resume immediately.
*
* @since 2.0.0
* @category destructors
*/
const inheritAll = inheritAll$1;
/**
* Interrupts the fiber from whichever fiber is calling this method. If the
* fiber has already exited, the returned effect will resume immediately.
* Otherwise, the effect will resume when the fiber exits.
*
* @since 2.0.0
* @category interruption
*/
const interrupt$2 = interruptFiber;
/**
* Constructrs a `Fiber` that is already interrupted.
*
* @since 2.0.0
* @category constructors
*/
const interrupted = interrupted$1;
/**
* Interrupts the fiber as if interrupted from the specified fiber. If the
* fiber has already exited, the returned effect will resume immediately.
* Otherwise, the effect will resume when the fiber exits.
*
* @since 2.0.0
* @category interruption
*/
const interruptAs = interruptAsFiber;
/**
* Interrupts the fiber as if interrupted from the specified fiber. If the
* fiber has already exited, the returned effect will resume immediately.
* Otherwise, the effect will resume when the fiber exits.
*
* @since 2.0.0
* @category interruption
*/
const interruptAsFork = interruptAsFork$1;
/**
* Interrupts all fibers, awaiting their interruption.
*
* @since 2.0.0
* @category interruption
*/
const interruptAll = interruptAll$1;
/**
* Interrupts all fibers as by the specified fiber, awaiting their
* interruption.
*
* @since 2.0.0
* @category interruption
*/
const interruptAllAs = interruptAllAs$1;
/**
* Interrupts the fiber from whichever fiber is calling this method. The
* interruption will happen in a separate daemon fiber, and the returned
* effect will always resume immediately without waiting.
*
* @since 2.0.0
* @category interruption
*/
const interruptFork = fiberInterruptFork;
/**
* Joins the fiber, which suspends the joining fiber until the result of the
* fiber has been determined. Attempting to join a fiber that has erred will
* result in a catchable error. Joining an interrupted fiber will result in an
* "inner interruption" of this fiber, unlike interruption triggered by
* another fiber, "inner interruption" can be caught and recovered.
*
* @since 2.0.0
* @category destructors
*/
const join = join$1;
/**
* Joins all fibers, awaiting their _successful_ completion. Attempting to
* join a fiber that has erred will result in a catchable error, _if_ that
* error does not result from interruption.
*
* @since 2.0.0
* @category destructors
*/
const joinAll = fiberJoinAll;
/**
* Maps over the value the Fiber computes.
*
* @since 2.0.0
* @category mapping
*/
const map$3 = map$5;
/**
* Effectually maps over the value the fiber computes.
*
* @since 2.0.0
* @category mapping
*/
const mapEffect$1 = mapEffect$2;
/**
* Passes the success of this fiber to the specified callback, and continues
* with the fiber that it returns.
*
* @since 2.0.0
* @category mapping
*/
const mapFiber = mapFiber$1;
/**
* Folds over the `Fiber` or `RuntimeFiber`.
*
* @since 2.0.0
* @category folding
*/
const match$1 = match$2;
/**
* A fiber that never fails or succeeds.
*
* @since 2.0.0
* @category constructors
*/
const never$1 = never$2;
/**
* Returns a fiber that prefers `this` fiber, but falls back to the `that` one
* when `this` one fails. Interrupting the returned fiber will interrupt both
* fibers, sequentially, from left to right.
*
* @since 2.0.0
* @category alternatives
*/
const orElse$2 = orElse$3;
/**
* Returns a fiber that prefers `this` fiber, but falls back to the `that` one
* when `this` one fails. Interrupting the returned fiber will interrupt both
* fibers, sequentially, from left to right.
*
* @since 2.0.0
* @category alternatives
*/
const orElseEither = orElseEither$2;
/**
* Tentatively observes the fiber, but returns immediately if it is not
* already done.
*
* @since 2.0.0
* @category getters
*/
const poll$2 = poll$3;
/**
* Pretty-prints a `RuntimeFiber`.
*
* @since 2.0.0
* @category destructors
*/
const pretty = pretty$1;
/**
* Returns a chunk containing all root fibers.
*
* @since 2.0.0
* @category constructors
*/
const roots = roots$1;
/**
* Returns a chunk containing all root fibers.
*
* @since 2.0.0
* @category constructors
*/
const unsafeRoots = unsafeRoots$1;
/**
* Converts this fiber into a scoped effect. The fiber is interrupted when the
* scope is closed.
*
* @since 2.0.0
* @category destructors
*/
const scoped$1 = fiberScoped;
/**
* Returns the `FiberStatus` of a `RuntimeFiber`.
*
* @since 2.0.0
* @category getters
*/
const status = status$1;
/**
* Returns a fiber that has already succeeded with the specified value.
*
* @since 2.0.0
* @category constructors
*/
const succeed$4 = succeed$6;
const void_ = void_$1;
/**
* Zips this fiber and the specified fiber together, producing a tuple of
* their output.
*
* @since 2.0.0
* @category zipping
*/
const zip$1 = zipFiber;
/**
* Same as `zip` but discards the output of that `Fiber`.
*
* @since 2.0.0
* @category zipping
*/
const zipLeft$1 = zipLeftFiber;
/**
* Same as `zip` but discards the output of this `Fiber`.
*
* @since 2.0.0
* @category zipping
*/
const zipRight$1 = zipRightFiber;
/**
* Zips this fiber with the specified fiber, combining their results using the
* specified combiner function. Both joins and interruptions are performed in
* sequential order from left to right.
*
* @since 2.0.0
* @category zipping
*/
const zipWith$2 = zipWithFiber;

//#endregion
//#region ../../node_modules/.bun/effect@3.17.14/node_modules/effect/dist/esm/internal/runtime.js
const makeDual = (f) => function() {
	if (arguments.length === 1) {
		const runtime$4 = arguments[0];
		return (effect, ...args$1) => f(runtime$4, effect, ...args$1);
	}
	return f.apply(this, arguments);
};
/** @internal */
const unsafeFork = /* @__PURE__ */ makeDual((runtime$4, self, options) => {
	const fiberId$2 = unsafeMake$7();
	const fiberRefUpdates = [[currentContext, [[fiberId$2, runtime$4.context]]]];
	if (options?.scheduler) fiberRefUpdates.push([currentScheduler, [[fiberId$2, options.scheduler]]]);
	let fiberRefs$3 = updateManyAs(runtime$4.fiberRefs, {
		entries: fiberRefUpdates,
		forkAs: fiberId$2
	});
	if (options?.updateRefs) fiberRefs$3 = options.updateRefs(fiberRefs$3, fiberId$2);
	const fiberRuntime = new FiberRuntime(fiberId$2, fiberRefs$3, runtime$4.runtimeFlags);
	let effect = self;
	if (options?.scope) effect = flatMap$4(fork$1(options.scope, sequential$1), (closeableScope) => zipRight$3(scopeAddFinalizer(closeableScope, fiberIdWith$1((id$2) => equals(id$2, fiberRuntime.id()) ? void_$4 : interruptAsFiber(fiberRuntime, id$2))), onExit$2(self, (exit$3) => close(closeableScope, exit$3))));
	const supervisor = fiberRuntime.currentSupervisor;
	if (supervisor !== none$2) {
		supervisor.onStart(runtime$4.context, effect, none$7(), fiberRuntime);
		fiberRuntime.addObserver((exit$3) => supervisor.onEnd(exit$3, fiberRuntime));
	}
	globalScope.add(runtime$4.runtimeFlags, fiberRuntime);
	if (options?.immediate === false) fiberRuntime.resume(effect);
	else fiberRuntime.start(effect);
	return fiberRuntime;
});
/** @internal */
const unsafeRunCallback = /* @__PURE__ */ makeDual((runtime$4, effect, options = {}) => {
	const fiberRuntime = unsafeFork(runtime$4, effect, options);
	if (options.onExit) fiberRuntime.addObserver((exit$3) => {
		options.onExit(exit$3);
	});
	return (id$2, cancelOptions) => unsafeRunCallback(runtime$4)(pipe(fiberRuntime, interruptAs(id$2 ?? none$6)), {
		...cancelOptions,
		onExit: cancelOptions?.onExit ? (exit$3) => cancelOptions.onExit(flatten$2(exit$3)) : void 0
	});
});
/** @internal */
const unsafeRunSync = /* @__PURE__ */ makeDual((runtime$4, effect) => {
	const result = unsafeRunSyncExit(runtime$4)(effect);
	if (result._tag === "Failure") throw fiberFailure(result.effect_instruction_i0);
	return result.effect_instruction_i0;
});
var AsyncFiberExceptionImpl = class extends Error {
	fiber;
	_tag = "AsyncFiberException";
	constructor(fiber) {
		super(`Fiber #${fiber.id().id} cannot be resolved synchronously. This is caused by using runSync on an effect that performs async work`);
		this.fiber = fiber;
		this.name = this._tag;
		this.stack = this.message;
	}
};
const asyncFiberException = (fiber) => {
	const limit = Error.stackTraceLimit;
	Error.stackTraceLimit = 0;
	const error = new AsyncFiberExceptionImpl(fiber);
	Error.stackTraceLimit = limit;
	return error;
};
/** @internal */
const FiberFailureId = /* @__PURE__ */ Symbol.for("effect/Runtime/FiberFailure");
/** @internal */
const FiberFailureCauseId = /* @__PURE__ */ Symbol.for("effect/Runtime/FiberFailure/Cause");
var FiberFailureImpl = class extends Error {
	[FiberFailureId];
	[FiberFailureCauseId];
	constructor(cause$2) {
		const head$4 = prettyErrors(cause$2)[0];
		super(head$4?.message || "An error has occurred");
		this[FiberFailureId] = FiberFailureId;
		this[FiberFailureCauseId] = cause$2;
		this.name = head$4 ? `(FiberFailure) ${head$4.name}` : "FiberFailure";
		if (head$4?.stack) this.stack = head$4.stack;
	}
	toJSON() {
		return {
			_id: "FiberFailure",
			cause: this[FiberFailureCauseId].toJSON()
		};
	}
	toString() {
		return "(FiberFailure) " + pretty$2(this[FiberFailureCauseId], { renderErrorCause: true });
	}
	[NodeInspectSymbol]() {
		return this.toString();
	}
};
/** @internal */
const fiberFailure = (cause$2) => {
	const limit = Error.stackTraceLimit;
	Error.stackTraceLimit = 0;
	const error = new FiberFailureImpl(cause$2);
	Error.stackTraceLimit = limit;
	return error;
};
const fastPath = (effect) => {
	const op = effect;
	switch (op._op) {
		case "Failure":
		case "Success": return op;
		case "Left": return exitFail(op.left);
		case "Right": return exitSucceed$1(op.right);
		case "Some": return exitSucceed$1(op.value);
		case "None": return exitFail(NoSuchElementException());
	}
};
/** @internal */
const unsafeRunSyncExit = /* @__PURE__ */ makeDual((runtime$4, effect) => {
	const op = fastPath(effect);
	if (op) return op;
	const scheduler = new SyncScheduler();
	const fiberRuntime = unsafeFork(runtime$4)(effect, { scheduler });
	scheduler.flush();
	const result = fiberRuntime.unsafePoll();
	if (result) return result;
	return exitDie$1(capture(asyncFiberException(fiberRuntime), currentSpanFromFiber(fiberRuntime)));
});
/** @internal */
const unsafeRunPromise = /* @__PURE__ */ makeDual((runtime$4, effect, options) => unsafeRunPromiseExit(runtime$4, effect, options).then((result) => {
	switch (result._tag) {
		case OP_SUCCESS: return result.effect_instruction_i0;
		case OP_FAILURE: throw fiberFailure(result.effect_instruction_i0);
	}
}));
/** @internal */
const unsafeRunPromiseExit = /* @__PURE__ */ makeDual((runtime$4, effect, options) => new Promise((resolve) => {
	const op = fastPath(effect);
	if (op) resolve(op);
	const fiber = unsafeFork(runtime$4)(effect);
	fiber.addObserver((exit$3) => {
		resolve(exit$3);
	});
	if (options?.signal !== void 0) if (options.signal.aborted) fiber.unsafeInterruptAsFork(fiber.id());
	else options.signal.addEventListener("abort", () => {
		fiber.unsafeInterruptAsFork(fiber.id());
	}, { once: true });
}));
/** @internal */
var RuntimeImpl = class {
	context;
	runtimeFlags;
	fiberRefs;
	constructor(context$2, runtimeFlags$1, fiberRefs$3) {
		this.context = context$2;
		this.runtimeFlags = runtimeFlags$1;
		this.fiberRefs = fiberRefs$3;
	}
	pipe() {
		return pipeArguments(this, arguments);
	}
};
/** @internal */
const make$4 = (options) => new RuntimeImpl(options.context, options.runtimeFlags, options.fiberRefs);
/** @internal */
const runtime$1 = () => withFiberRuntime$1((state, status$2) => succeed$9(new RuntimeImpl(state.getFiberRef(currentContext), status$2.runtimeFlags, state.getFiberRefs())));
/** @internal */
const defaultRuntimeFlags = /* @__PURE__ */ make$28(Interruption, CooperativeYielding, RuntimeMetrics);
/** @internal */
const defaultRuntime = /* @__PURE__ */ make$4({
	context: /* @__PURE__ */ empty$25(),
	runtimeFlags: defaultRuntimeFlags,
	fiberRefs: /* @__PURE__ */ empty$11()
});
/** @internal */
const unsafeRunEffect = /* @__PURE__ */ unsafeRunCallback(defaultRuntime);
/** @internal */
const unsafeForkEffect = /* @__PURE__ */ unsafeFork(defaultRuntime);
/** @internal */
const unsafeRunPromiseEffect = /* @__PURE__ */ unsafeRunPromise(defaultRuntime);
/** @internal */
const unsafeRunPromiseExitEffect = /* @__PURE__ */ unsafeRunPromiseExit(defaultRuntime);
/** @internal */
const unsafeRunSyncEffect = /* @__PURE__ */ unsafeRunSync(defaultRuntime);
/** @internal */
const unsafeRunSyncExitEffect = /* @__PURE__ */ unsafeRunSyncExit(defaultRuntime);
/** @internal */
const asyncEffect$1 = (register) => suspend$3(() => {
	let cleanup = void 0;
	return flatMap$4(deferredMake(), (deferred) => flatMap$4(runtime$1(), (runtime$4) => uninterruptibleMask$2((restore) => zipRight$3(fork$2(restore(matchCauseEffect$2(register((cb) => unsafeRunCallback(runtime$4)(intoDeferred$1(cb, deferred))), {
		onFailure: (cause$2) => deferredFailCause(deferred, cause$2),
		onSuccess: (cleanup_) => {
			cleanup = cleanup_;
			return void_$4;
		}
	}))), restore(onInterrupt$1(deferredAwait(deferred), () => cleanup ?? void_$4))))));
});

//#endregion
//#region ../../node_modules/.bun/effect@3.17.14/node_modules/effect/dist/esm/internal/synchronizedRef.js
/** @internal */
const modifyEffect = /* @__PURE__ */ dual(2, (self, f) => self.modifyEffect(f));

//#endregion
//#region ../../node_modules/.bun/effect@3.17.14/node_modules/effect/dist/esm/internal/layer.js
/** @internal */
const LayerSymbolKey = "effect/Layer";
/** @internal */
const LayerTypeId = /* @__PURE__ */ Symbol.for(LayerSymbolKey);
const layerVariance = {
	_RIn: (_) => _,
	_E: (_) => _,
	_ROut: (_) => _
};
/** @internal */
const proto = {
	[LayerTypeId]: layerVariance,
	pipe() {
		return pipeArguments(this, arguments);
	}
};
/** @internal */
const MemoMapTypeIdKey = "effect/Layer/MemoMap";
/** @internal */
const MemoMapTypeId = /* @__PURE__ */ Symbol.for(MemoMapTypeIdKey);
/** @internal */
const CurrentMemoMap = /* @__PURE__ */ Reference()("effect/Layer/CurrentMemoMap", { defaultValue: () => unsafeMakeMemoMap() });
/** @internal */
const isLayer = (u) => hasProperty(u, LayerTypeId);
/** @internal */
const isFresh = (self) => {
	return self._op_layer === OP_FRESH;
};
/** @internal */
var MemoMapImpl = class {
	ref;
	[MemoMapTypeId];
	constructor(ref) {
		this.ref = ref;
		this[MemoMapTypeId] = MemoMapTypeId;
	}
	/**
	* Checks the memo map to see if a layer exists. If it is, immediately
	* returns it. Otherwise, obtains the layer, stores it in the memo map,
	* and adds a finalizer to the `Scope`.
	*/
	getOrElseMemoize(layer, scope$2) {
		return pipe(modifyEffect(this.ref, (map$17) => {
			const inMap = map$17.get(layer);
			if (inMap !== void 0) {
				const [acquire, release] = inMap;
				const cached$3 = pipe(acquire, flatMap$4(([patch$11, b]) => pipe(patchFiberRefs$1(patch$11), as$3(b))), onExit$2(exitMatch({
					onFailure: () => void_$4,
					onSuccess: () => scopeAddFinalizerExit(scope$2, release)
				})));
				return succeed$9([cached$3, map$17]);
			}
			return pipe(make$22(0), flatMap$4((observers) => pipe(deferredMake(), flatMap$4((deferred) => pipe(make$22(() => void_$4), map$8((finalizerRef) => {
				const resource = uninterruptibleMask$2((restore) => pipe(scopeMake(), flatMap$4((innerScope) => pipe(restore(flatMap$4(makeBuilder(layer, innerScope, true), (f) => diffFiberRefs$1(f(this)))), exit$2, flatMap$4((exit$3) => {
					switch (exit$3._tag) {
						case OP_FAILURE: return pipe(deferredFailCause(deferred, exit$3.effect_instruction_i0), zipRight$3(scopeClose(innerScope, exit$3)), zipRight$3(failCause$8(exit$3.effect_instruction_i0)));
						case OP_SUCCESS: return pipe(set$2(finalizerRef, (exit$4) => pipe(scopeClose(innerScope, exit$4), whenEffect$1(modify$1(observers, (n) => [n === 1, n - 1])), asVoid$3)), zipRight$3(update$3(observers, (n) => n + 1)), zipRight$3(scopeAddFinalizerExit(scope$2, (exit$4) => pipe(sync$3(() => map$17.delete(layer)), zipRight$3(get$2(finalizerRef)), flatMap$4((finalizer) => finalizer(exit$4))))), zipRight$3(deferredSucceed(deferred, exit$3.effect_instruction_i0)), as$3(exit$3.effect_instruction_i0[1]));
					}
				})))));
				const memoized = [pipe(deferredAwait(deferred), onExit$2(exitMatchEffect({
					onFailure: () => void_$4,
					onSuccess: () => update$3(observers, (n) => n + 1)
				}))), (exit$3) => pipe(get$2(finalizerRef), flatMap$4((finalizer) => finalizer(exit$3)))];
				return [resource, isFresh(layer) ? map$17 : map$17.set(layer, memoized)];
			}))))));
		}), flatten$3);
	}
};
/** @internal */
const makeMemoMap = /* @__PURE__ */ suspend$3(() => map$8(makeSynchronized(/* @__PURE__ */ new Map()), (ref) => new MemoMapImpl(ref)));
/** @internal */
const unsafeMakeMemoMap = () => new MemoMapImpl(unsafeMakeSynchronized(/* @__PURE__ */ new Map()));
/** @internal */
const buildWithScope = /* @__PURE__ */ dual(2, (self, scope$2) => flatMap$4(makeMemoMap, (memoMap) => buildWithMemoMap(self, memoMap, scope$2)));
/** @internal */
const buildWithMemoMap = /* @__PURE__ */ dual(3, (self, memoMap, scope$2) => flatMap$4(makeBuilder(self, scope$2), (run) => provideService$1(run(memoMap), CurrentMemoMap, memoMap)));
const makeBuilder = (self, scope$2, inMemoMap = false) => {
	const op = self;
	switch (op._op_layer) {
		case "Locally": return sync$3(() => (memoMap) => op.f(memoMap.getOrElseMemoize(op.self, scope$2)));
		case "ExtendScope": return sync$3(() => (memoMap) => scopeWith$1((scope$3) => memoMap.getOrElseMemoize(op.layer, scope$3)));
		case "Fold": return sync$3(() => (memoMap) => pipe(memoMap.getOrElseMemoize(op.layer, scope$2), matchCauseEffect$2({
			onFailure: (cause$2) => memoMap.getOrElseMemoize(op.failureK(cause$2), scope$2),
			onSuccess: (value) => memoMap.getOrElseMemoize(op.successK(value), scope$2)
		})));
		case "Fresh": return sync$3(() => (_) => pipe(op.layer, buildWithScope(scope$2)));
		case "FromEffect": return inMemoMap ? sync$3(() => (_) => op.effect) : sync$3(() => (memoMap) => memoMap.getOrElseMemoize(self, scope$2));
		case "Provide": return sync$3(() => (memoMap) => pipe(memoMap.getOrElseMemoize(op.first, scope$2), flatMap$4((env) => pipe(memoMap.getOrElseMemoize(op.second, scope$2), provideContext$1(env)))));
		case "Scoped": return inMemoMap ? sync$3(() => (_) => scopeExtend(op.effect, scope$2)) : sync$3(() => (memoMap) => memoMap.getOrElseMemoize(self, scope$2));
		case "Suspend": return sync$3(() => (memoMap) => memoMap.getOrElseMemoize(op.evaluate(), scope$2));
		case "ProvideMerge": return sync$3(() => (memoMap) => pipe(memoMap.getOrElseMemoize(op.first, scope$2), zipWith$4(memoMap.getOrElseMemoize(op.second, scope$2), op.zipK)));
		case "ZipWith": return sync$3(() => (memoMap) => pipe(memoMap.getOrElseMemoize(op.first, scope$2), zipWithOptions(memoMap.getOrElseMemoize(op.second, scope$2), op.zipK, { concurrent: true })));
	}
};
/** @internal */
const merge$1 = /* @__PURE__ */ dual(2, (self, that) => zipWith$1(self, that, (a, b) => merge$4(a, b)));
/** @internal */
const mergeAll$1 = (...layers) => {
	let final = layers[0];
	for (let i = 1; i < layers.length; i++) final = merge$1(final, layers[i]);
	return final;
};
/** @internal */
const suspend$1 = (evaluate$1) => {
	const suspend$4 = Object.create(proto);
	suspend$4._op_layer = OP_SUSPEND;
	suspend$4.evaluate = evaluate$1;
	return suspend$4;
};
/** @internal */
const zipWith$1 = /* @__PURE__ */ dual(3, (self, that, f) => suspend$1(() => {
	const zipWith$6 = Object.create(proto);
	zipWith$6._op_layer = OP_ZIP_WITH;
	zipWith$6.first = self;
	zipWith$6.second = that;
	zipWith$6.zipK = f;
	return zipWith$6;
}));
const provideSomeLayer = /* @__PURE__ */ dual(2, (self, layer) => scopedWith$1((scope$2) => flatMap$4(buildWithScope(layer, scope$2), (context$2) => provideSomeContext(self, context$2))));
const provideSomeRuntime = /* @__PURE__ */ dual(2, (self, rt) => {
	const patchRefs = diff$1(defaultRuntime.fiberRefs, rt.fiberRefs);
	const patchFlags = diff$3(defaultRuntime.runtimeFlags, rt.runtimeFlags);
	return uninterruptibleMask$2((restore) => withFiberRuntime$1((fiber) => {
		const oldContext = fiber.getFiberRef(currentContext);
		const oldRefs = fiber.getFiberRefs();
		const newRefs = patch$1(fiber.id(), oldRefs)(patchRefs);
		const oldFlags = fiber.currentRuntimeFlags;
		const newFlags = patch$4(patchFlags)(oldFlags);
		const rollbackRefs = diff$1(newRefs, oldRefs);
		const rollbackFlags = diff$3(newFlags, oldFlags);
		fiber.setFiberRefs(newRefs);
		fiber.currentRuntimeFlags = newFlags;
		return ensuring$1(provideSomeContext(restore(self), merge$4(oldContext, rt.context)), withFiberRuntime$1((fiber$1) => {
			fiber$1.setFiberRefs(patch$1(fiber$1.id(), fiber$1.getFiberRefs())(rollbackRefs));
			fiber$1.currentRuntimeFlags = patch$4(rollbackFlags)(fiber$1.currentRuntimeFlags);
			return void_$4;
		}));
	}));
});
/** @internal */
const effect_provide = /* @__PURE__ */ dual(2, (self, source) => {
	if (Array.isArray(source)) return provideSomeLayer(self, mergeAll$1(...source));
	else if (isLayer(source)) return provideSomeLayer(self, source);
	else if (isContext(source)) return provideSomeContext(self, source);
	else if (TypeId$3 in source) return flatMap$4(source.runtimeEffect, (rt) => provideSomeRuntime(self, rt));
	else return provideSomeRuntime(self, source);
});

//#endregion
//#region ../../node_modules/.bun/effect@3.17.14/node_modules/effect/dist/esm/internal/console.js
/** @internal */
const console$2 = /* @__PURE__ */ map$8(/* @__PURE__ */ fiberRefGet(currentServices), /* @__PURE__ */ get$7(consoleTag));
/** @internal */
const consoleWith$1 = (f) => fiberRefGetWith(currentServices, (services) => f(get$7(services, consoleTag)));
/** @internal */
const withConsole$1 = /* @__PURE__ */ dual(2, (effect, value) => fiberRefLocallyWith(effect, currentServices, add$1(consoleTag, value)));
/** @internal */
const withConsoleScoped$1 = (console$3) => fiberRefLocallyScopedWith(currentServices, add$1(consoleTag, console$3));

//#endregion
//#region ../../node_modules/.bun/effect@3.17.14/node_modules/effect/dist/esm/internal/schedule.js
/** @internal */
const ScheduleSymbolKey = "effect/Schedule";
/** @internal */
const ScheduleTypeId = /* @__PURE__ */ Symbol.for(ScheduleSymbolKey);
/** @internal */
const isSchedule = (u) => hasProperty(u, ScheduleTypeId);
/** @internal */
const ScheduleDriverSymbolKey = "effect/ScheduleDriver";
/** @internal */
const ScheduleDriverTypeId = /* @__PURE__ */ Symbol.for(ScheduleDriverSymbolKey);
/** @internal */
const defaultIterationMetadata = {
	start: 0,
	now: 0,
	input: void 0,
	output: void 0,
	elapsed: zero,
	elapsedSincePrevious: zero,
	recurrence: 0
};
/** @internal */
const CurrentIterationMetadata = /* @__PURE__ */ Reference()("effect/Schedule/CurrentIterationMetadata", { defaultValue: () => defaultIterationMetadata });
const scheduleVariance = {
	_Out: (_) => _,
	_In: (_) => _,
	_R: (_) => _
};
const scheduleDriverVariance = {
	_Out: (_) => _,
	_In: (_) => _,
	_R: (_) => _
};
/** @internal */
var ScheduleImpl = class {
	initial;
	step;
	[ScheduleTypeId] = scheduleVariance;
	constructor(initial, step$3) {
		this.initial = initial;
		this.step = step$3;
	}
	pipe() {
		return pipeArguments(this, arguments);
	}
};
/** @internal */
const updateInfo = (iterationMetaRef, now, input, output) => update$3(iterationMetaRef, (prev) => prev.recurrence === 0 ? {
	now,
	input,
	output,
	recurrence: prev.recurrence + 1,
	elapsed: zero,
	elapsedSincePrevious: zero,
	start: now
} : {
	now,
	input,
	output,
	recurrence: prev.recurrence + 1,
	elapsed: millis(now - prev.start),
	elapsedSincePrevious: millis(now - prev.now),
	start: prev.start
});
/** @internal */
var ScheduleDriverImpl = class {
	schedule;
	ref;
	[ScheduleDriverTypeId] = scheduleDriverVariance;
	constructor(schedule$1, ref) {
		this.schedule = schedule$1;
		this.ref = ref;
	}
	get state() {
		return map$8(get$2(this.ref), (tuple$2) => tuple$2[1]);
	}
	get last() {
		return flatMap$4(get$2(this.ref), ([element, _]) => {
			switch (element._tag) {
				case "None": return failSync$2(() => new NoSuchElementException());
				case "Some": return succeed$9(element.value);
			}
		});
	}
	iterationMeta = /* @__PURE__ */ unsafeMake$4(defaultIterationMetadata);
	get reset() {
		return set$2(this.ref, [none$7(), this.schedule.initial]).pipe(zipLeft$3(set$2(this.iterationMeta, defaultIterationMetadata)));
	}
	next(input) {
		return pipe(map$8(get$2(this.ref), (tuple$2) => tuple$2[1]), flatMap$4((state) => pipe(currentTimeMillis, flatMap$4((now) => pipe(suspend$3(() => this.schedule.step(now, input, state)), flatMap$4(([state$1, out, decision]) => {
			const setState = set$2(this.ref, [some$4(out), state$1]);
			if (isDone$1(decision)) return setState.pipe(zipRight$3(fail$8(none$7())));
			const millis$1 = start(decision.intervals) - now;
			if (millis$1 <= 0) return setState.pipe(zipRight$3(updateInfo(this.iterationMeta, now, input, out)), as$3(out));
			const duration = millis(millis$1);
			return pipe(setState, zipRight$3(updateInfo(this.iterationMeta, now, input, out)), zipRight$3(sleep$1(duration)), as$3(out));
		}))))));
	}
};
/** @internal */
const makeWithState = (initial, step$3) => new ScheduleImpl(initial, step$3);
/** @internal */
const asVoid$1 = (self) => map$2(self, constVoid);
/** @internal */
const check = /* @__PURE__ */ dual(2, (self, test) => checkEffect(self, (input, out) => sync$3(() => test(input, out))));
/** @internal */
const checkEffect = /* @__PURE__ */ dual(2, (self, test) => makeWithState(self.initial, (now, input, state) => flatMap$4(self.step(now, input, state), ([state$1, out, decision]) => {
	if (isDone$1(decision)) return succeed$9([
		state$1,
		out,
		done$2
	]);
	return map$8(test(input, out), (cont) => cont ? [
		state$1,
		out,
		decision
	] : [
		state$1,
		out,
		done$2
	]);
})));
/** @internal */
const driver = (self) => pipe(make$22([none$7(), self.initial]), map$8((ref) => new ScheduleDriverImpl(self, ref)));
/** @internal */
const intersect = /* @__PURE__ */ dual(2, (self, that) => intersectWith(self, that, intersect$1));
/** @internal */
const intersectWith = /* @__PURE__ */ dual(3, (self, that, f) => makeWithState([self.initial, that.initial], (now, input, state) => pipe(zipWith$4(self.step(now, input, state[0]), that.step(now, input, state[1]), (a, b) => [a, b]), flatMap$4(([[lState, out, lDecision], [rState, out2, rDecision]]) => {
	if (isContinue(lDecision) && isContinue(rDecision)) return intersectWithLoop(self, that, input, lState, out, lDecision.intervals, rState, out2, rDecision.intervals, f);
	return succeed$9([
		[lState, rState],
		[out, out2],
		done$2
	]);
}))));
/** @internal */
const intersectWithLoop = (self, that, input, lState, out, lInterval, rState, out2, rInterval, f) => {
	const combined = f(lInterval, rInterval);
	if (isNonEmpty$1(combined)) return succeed$9([
		[lState, rState],
		[out, out2],
		_continue(combined)
	]);
	if (pipe(lInterval, lessThan(rInterval))) return flatMap$4(self.step(end(lInterval), input, lState), ([lState$1, out$1, decision]) => {
		if (isDone$1(decision)) return succeed$9([
			[lState$1, rState],
			[out$1, out2],
			done$2
		]);
		return intersectWithLoop(self, that, input, lState$1, out$1, decision.intervals, rState, out2, rInterval, f);
	});
	return flatMap$4(that.step(end(rInterval), input, rState), ([rState$1, out2$1, decision]) => {
		if (isDone$1(decision)) return succeed$9([
			[lState, rState$1],
			[out, out2$1],
			done$2
		]);
		return intersectWithLoop(self, that, input, lState, out, lInterval, rState$1, out2$1, decision.intervals, f);
	});
};
/** @internal */
const map$2 = /* @__PURE__ */ dual(2, (self, f) => mapEffect(self, (out) => sync$3(() => f(out))));
/** @internal */
const mapEffect = /* @__PURE__ */ dual(2, (self, f) => makeWithState(self.initial, (now, input, state) => flatMap$4(self.step(now, input, state), ([state$1, out, decision]) => map$8(f(out), (out2) => [
	state$1,
	out2,
	decision
]))));
/** @internal */
const passthrough = (self) => makeWithState(self.initial, (now, input, state) => pipe(self.step(now, input, state), map$8(([state$1, _, decision]) => [
	state$1,
	input,
	decision
])));
/** @internal */
const recurs = (n) => whileOutput(forever$1, (out) => out < n);
/** @internal */
const unfold = (initial, f) => makeWithState(initial, (now, _, state) => sync$3(() => [
	f(state),
	state,
	continueWith(after(now))
]));
/** @internal */
const untilInputEffect = /* @__PURE__ */ dual(2, (self, f) => checkEffect(self, (input, _) => negate$1(f(input))));
/** @internal */
const whileInputEffect = /* @__PURE__ */ dual(2, (self, f) => checkEffect(self, (input, _) => f(input)));
/** @internal */
const whileOutput = /* @__PURE__ */ dual(2, (self, f) => check(self, (_, out) => f(out)));
const ScheduleDefectTypeId = /* @__PURE__ */ Symbol.for("effect/Schedule/ScheduleDefect");
var ScheduleDefect = class {
	error;
	[ScheduleDefectTypeId];
	constructor(error) {
		this.error = error;
		this[ScheduleDefectTypeId] = ScheduleDefectTypeId;
	}
};
const isScheduleDefect = (u) => hasProperty(u, ScheduleDefectTypeId);
const scheduleDefectWrap = (self) => catchAll$1(self, (e) => die$3(new ScheduleDefect(e)));
/** @internal */
const scheduleDefectRefailCause = (cause$2) => match$10(find(cause$2, (_) => isDieType(_) && isScheduleDefect(_.defect) ? some$4(_.defect) : none$7()), {
	onNone: () => cause$2,
	onSome: (error) => fail$9(error.error)
});
/** @internal */
const scheduleDefectRefail = (effect) => catchAllCause$1(effect, (cause$2) => failCause$8(scheduleDefectRefailCause(cause$2)));
/** @internal */
const repeat_Effect = /* @__PURE__ */ dual(2, (self, schedule$1) => repeatOrElse_Effect(self, schedule$1, (e, _) => fail$8(e)));
/** @internal */
const repeat_combined = /* @__PURE__ */ dual(2, (self, options) => {
	if (isSchedule(options)) return repeat_Effect(self, options);
	const base = options.schedule ?? passthrough(forever$1);
	const withWhile = options.while ? whileInputEffect(base, (a) => {
		const applied = options.while(a);
		if (typeof applied === "boolean") return succeed$9(applied);
		return scheduleDefectWrap(applied);
	}) : base;
	const withUntil = options.until ? untilInputEffect(withWhile, (a) => {
		const applied = options.until(a);
		if (typeof applied === "boolean") return succeed$9(applied);
		return scheduleDefectWrap(applied);
	}) : withWhile;
	const withTimes = options.times ? intersect(withUntil, recurs(options.times)).pipe(map$2((intersectionPair) => intersectionPair[0])) : withUntil;
	return scheduleDefectRefail(repeat_Effect(self, withTimes));
});
/** @internal */
const repeatOrElse_Effect = /* @__PURE__ */ dual(3, (self, schedule$1, orElse$6) => flatMap$4(driver(schedule$1), (driver$1) => matchEffect$2(self, {
	onFailure: (error) => orElse$6(error, none$7()),
	onSuccess: (value) => repeatOrElseEffectLoop(provideServiceEffect$1(self, CurrentIterationMetadata, get$2(driver$1.iterationMeta)), driver$1, (error, option$2) => provideServiceEffect$1(orElse$6(error, option$2), CurrentIterationMetadata, get$2(driver$1.iterationMeta)), value)
})));
/** @internal */
const repeatOrElseEffectLoop = (self, driver$1, orElse$6, value) => matchEffect$2(driver$1.next(value), {
	onFailure: () => orDie$1(driver$1.last),
	onSuccess: (b) => matchEffect$2(self, {
		onFailure: (error) => orElse$6(error, some$4(b)),
		onSuccess: (value$1) => repeatOrElseEffectLoop(self, driver$1, orElse$6, value$1)
	})
});
/** @internal */
const retry_Effect = /* @__PURE__ */ dual(2, (self, policy) => retryOrElse_Effect(self, policy, (e, _) => fail$8(e)));
/** @internal */
const retry_combined = /* @__PURE__ */ dual(2, (self, options) => {
	if (isSchedule(options)) return retry_Effect(self, options);
	return scheduleDefectRefail(retry_Effect(self, fromRetryOptions(options)));
});
/** @internal */
const fromRetryOptions = (options) => {
	const base = options.schedule ?? forever$1;
	const withWhile = options.while ? whileInputEffect(base, (e) => {
		const applied = options.while(e);
		if (typeof applied === "boolean") return succeed$9(applied);
		return scheduleDefectWrap(applied);
	}) : base;
	const withUntil = options.until ? untilInputEffect(withWhile, (e) => {
		const applied = options.until(e);
		if (typeof applied === "boolean") return succeed$9(applied);
		return scheduleDefectWrap(applied);
	}) : withWhile;
	return options.times ? intersect(withUntil, recurs(options.times)) : withUntil;
};
/** @internal */
const retryOrElse_Effect = /* @__PURE__ */ dual(3, (self, policy, orElse$6) => flatMap$4(driver(policy), (driver$1) => retryOrElse_EffectLoop(provideServiceEffect$1(self, CurrentIterationMetadata, get$2(driver$1.iterationMeta)), driver$1, (e, out) => provideServiceEffect$1(orElse$6(e, out), CurrentIterationMetadata, get$2(driver$1.iterationMeta)))));
/** @internal */
const retryOrElse_EffectLoop = (self, driver$1, orElse$6) => {
	return catchAll$1(self, (e) => matchEffect$2(driver$1.next(e), {
		onFailure: () => pipe(driver$1.last, orDie$1, flatMap$4((out) => orElse$6(e, out))),
		onSuccess: () => retryOrElse_EffectLoop(self, driver$1, orElse$6)
	}));
};
/** @internal */
const schedule_Effect = /* @__PURE__ */ dual(2, (self, schedule$1) => scheduleFrom_Effect(self, void 0, schedule$1));
/** @internal */
const scheduleFrom_Effect = /* @__PURE__ */ dual(3, (self, initial, schedule$1) => flatMap$4(driver(schedule$1), (driver$1) => scheduleFrom_EffectLoop(provideServiceEffect$1(self, CurrentIterationMetadata, get$2(driver$1.iterationMeta)), initial, driver$1)));
/** @internal */
const scheduleFrom_EffectLoop = (self, initial, driver$1) => matchEffect$2(driver$1.next(initial), {
	onFailure: () => orDie$1(driver$1.last),
	onSuccess: () => flatMap$4(self, (a) => scheduleFrom_EffectLoop(self, a, driver$1))
});
/** @internal */
const forever$1 = /* @__PURE__ */ unfold(0, (n) => n + 1);
/** @internal */
const once$1 = /* @__PURE__ */ asVoid$1(/* @__PURE__ */ recurs(1));
/** @internal */
const scheduleForked$1 = /* @__PURE__ */ dual(2, (self, schedule$1) => forkScoped$1(schedule_Effect(self, schedule$1)));

//#endregion
//#region ../../node_modules/.bun/effect@3.17.14/node_modules/effect/dist/esm/internal/executionPlan.js
/** @internal */
const withExecutionPlan$1 = /* @__PURE__ */ dual(2, (effect, plan) => suspend$3(() => {
	let i = 0;
	let result;
	return flatMap$4(whileLoop$2({
		while: () => i < plan.steps.length && (result === void 0 || isLeft(result)),
		body: () => {
			const step$3 = plan.steps[i];
			let nextEffect = effect_provide(effect, step$3.provide);
			if (result) {
				let attempted = false;
				const wrapped = nextEffect;
				nextEffect = suspend$3(() => {
					if (attempted) return wrapped;
					attempted = true;
					return result;
				});
				nextEffect = scheduleDefectRefail(retry_Effect(nextEffect, scheduleFromStep(step$3, false)));
			} else {
				const schedule$1 = scheduleFromStep(step$3, true);
				nextEffect = schedule$1 ? scheduleDefectRefail(retry_Effect(nextEffect, schedule$1)) : nextEffect;
			}
			return either$1(nextEffect);
		},
		step: (either$4) => {
			result = either$4;
			i++;
		}
	}), () => result);
}));
/** @internal */
const scheduleFromStep = (step$3, first$2) => {
	if (!first$2) return fromRetryOptions({
		schedule: step$3.schedule ? step$3.schedule : step$3.attempts ? void 0 : once$1,
		times: step$3.attempts,
		while: step$3.while
	});
	else if (step$3.attempts === 1 || !(step$3.schedule || step$3.attempts)) return;
	return fromRetryOptions({
		schedule: step$3.schedule,
		while: step$3.while,
		times: step$3.attempts ? step$3.attempts - 1 : void 0
	});
};

//#endregion
//#region ../../node_modules/.bun/effect@3.17.14/node_modules/effect/dist/esm/Deferred.js
/**
* @since 2.0.0
* @category symbols
*/
const DeferredTypeId = DeferredTypeId$1;
/**
* Creates a new `Deferred`.
*
* @since 2.0.0
* @category constructors
*/
const make$3 = deferredMake;
/**
* Creates a new `Deferred` from the specified `FiberId`.
*
* @since 2.0.0
* @category constructors
*/
const makeAs = deferredMakeAs;
const _await = deferredAwait;
/**
* Completes the deferred with the result of the specified effect. If the
* deferred has already been completed, the method will produce false.
*
* Note that `Deferred.completeWith` will be much faster, so consider using
* that if you do not need to memoize the result of the specified effect.
*
* @since 2.0.0
* @category utils
*/
const complete$2 = deferredComplete;
/**
* Completes the deferred with the result of the specified effect. If the
* deferred has already been completed, the method will produce false.
*
* @since 2.0.0
* @category utils
*/
const completeWith = deferredCompleteWith;
/**
* Exits the `Deferred` with the specified `Exit` value, which will be
* propagated to all fibers waiting on the value of the `Deferred`.
*
* @since 2.0.0
* @category utils
*/
const done = deferredDone;
/**
* Fails the `Deferred` with the specified error, which will be propagated to
* all fibers waiting on the value of the `Deferred`.
*
* @since 2.0.0
* @category utils
*/
const fail$3 = deferredFail;
/**
* Fails the `Deferred` with the specified error, which will be propagated to
* all fibers waiting on the value of the `Deferred`.
*
* @since 2.0.0
* @category utils
*/
const failSync$1 = deferredFailSync;
/**
* Fails the `Deferred` with the specified `Cause`, which will be propagated to
* all fibers waiting on the value of the `Deferred`.
*
* @since 2.0.0
* @category utils
*/
const failCause$2 = deferredFailCause;
/**
* Fails the `Deferred` with the specified `Cause`, which will be propagated to
* all fibers waiting on the value of the `Deferred`.
*
* @since 2.0.0
* @category utils
*/
const failCauseSync$1 = deferredFailCauseSync;
/**
* Kills the `Deferred` with the specified defect, which will be propagated to
* all fibers waiting on the value of the `Deferred`.
*
* @since 2.0.0
* @category utils
*/
const die$1 = deferredDie;
/**
* Kills the `Deferred` with the specified defect, which will be propagated to
* all fibers waiting on the value of the `Deferred`.
*
* @since 2.0.0
* @category utils
*/
const dieSync$1 = deferredDieSync;
/**
* Completes the `Deferred` with interruption. This will interrupt all fibers
* waiting on the value of the `Deferred` with the `FiberId` of the fiber
* calling this method.
*
* @since 2.0.0
* @category utils
*/
const interrupt$1 = deferredInterrupt;
/**
* Completes the `Deferred` with interruption. This will interrupt all fibers
* waiting on the value of the `Deferred` with the specified `FiberId`.
*
* @since 2.0.0
* @category utils
*/
const interruptWith$1 = deferredInterruptWith;
/**
* Returns `true` if this `Deferred` has already been completed with a value or
* an error, `false` otherwise.
*
* @since 2.0.0
* @category getters
*/
const isDone = deferredIsDone;
/**
* Returns a `Some<Effect<A, E, R>>` from the `Deferred` if this `Deferred` has
* already been completed, `None` otherwise.
*
* @since 2.0.0
* @category getters
*/
const poll$1 = deferredPoll;
/**
* Completes the `Deferred` with the specified value.
*
* @since 2.0.0
* @category utils
*/
const succeed$3 = deferredSucceed;
/**
* Completes the `Deferred` with the specified lazily evaluated value.
*
* @since 2.0.0
* @category utils
*/
const sync$1 = deferredSync;
/**
* Unsafely creates a new `Deferred` from the specified `FiberId`.
*
* @since 2.0.0
* @category unsafe
*/
const unsafeMake = deferredUnsafeMake;
/**
* Unsafely exits the `Deferred` with the specified `Exit` value, which will be
* propagated to all fibers waiting on the value of the `Deferred`.
*
* @since 2.0.0
* @category unsafe
*/
const unsafeDone = deferredUnsafeDone;

//#endregion
//#region ../../node_modules/.bun/effect@3.17.14/node_modules/effect/dist/esm/MutableList.js
const TypeId$2 = /* @__PURE__ */ Symbol.for("effect/MutableList");
const MutableListProto = {
	[TypeId$2]: TypeId$2,
	[Symbol.iterator]() {
		let done$8 = false;
		let head$4 = this.head;
		return {
			next() {
				if (done$8) return this.return();
				if (head$4 == null) {
					done$8 = true;
					return this.return();
				}
				const value = head$4.value;
				head$4 = head$4.next;
				return {
					done: done$8,
					value
				};
			},
			return(value) {
				if (!done$8) done$8 = true;
				return {
					done: true,
					value
				};
			}
		};
	},
	toString() {
		return format(this.toJSON());
	},
	toJSON() {
		return {
			_id: "MutableList",
			values: Array.from(this).map(toJSON)
		};
	},
	[NodeInspectSymbol]() {
		return this.toJSON();
	},
	pipe() {
		return pipeArguments(this, arguments);
	}
};
/** @internal */
const makeNode = (value) => ({
	value,
	removed: false,
	prev: void 0,
	next: void 0
});
/**
* Creates an empty `MutableList`.
*
* @since 2.0.0
* @category constructors
*/
const empty = () => {
	const list = Object.create(MutableListProto);
	list.head = void 0;
	list.tail = void 0;
	list._length = 0;
	return list;
};
/**
* Returns `true` if the list contains zero elements, `false`, otherwise.
*
* @since 2.0.0
* @category getters
*/
const isEmpty = (self) => length(self) === 0;
/**
* Returns the length of the list.
*
* @since 2.0.0
* @category getters
*/
const length = (self) => self._length;
/**
* Appends the specified element to the end of the `MutableList`.
*
* @category concatenating
* @since 2.0.0
*/
const append = /* @__PURE__ */ dual(2, (self, value) => {
	const node = makeNode(value);
	if (self.head === void 0) self.head = node;
	if (self.tail === void 0) self.tail = node;
	else {
		self.tail.next = node;
		node.prev = self.tail;
		self.tail = node;
	}
	self._length += 1;
	return self;
});
/**
* Removes the first value from the list and returns it, if it exists.
*
* @since 0.0.1
*/
const shift = (self) => {
	const head$4 = self.head;
	if (head$4 !== void 0) {
		remove(self, head$4);
		return head$4.value;
	}
};
const remove = (self, node) => {
	if (node.removed) return;
	node.removed = true;
	if (node.prev !== void 0 && node.next !== void 0) {
		node.prev.next = node.next;
		node.next.prev = node.prev;
	} else if (node.prev !== void 0) {
		self.tail = node.prev;
		node.prev.next = void 0;
	} else if (node.next !== void 0) {
		self.head = node.next;
		node.next.prev = void 0;
	} else {
		self.tail = void 0;
		self.head = void 0;
	}
	if (self._length > 0) self._length -= 1;
};

//#endregion
//#region ../../node_modules/.bun/effect@3.17.14/node_modules/effect/dist/esm/MutableQueue.js
const TypeId$1 = /* @__PURE__ */ Symbol.for("effect/MutableQueue");
/**
* @since 2.0.0
* @category symbol
*/
const EmptyMutableQueue = /* @__PURE__ */ Symbol.for("effect/mutable/MutableQueue/Empty");
const MutableQueueProto = {
	[TypeId$1]: TypeId$1,
	[Symbol.iterator]() {
		return Array.from(this.queue)[Symbol.iterator]();
	},
	toString() {
		return format(this.toJSON());
	},
	toJSON() {
		return {
			_id: "MutableQueue",
			values: Array.from(this).map(toJSON)
		};
	},
	[NodeInspectSymbol]() {
		return this.toJSON();
	},
	pipe() {
		return pipeArguments(this, arguments);
	}
};
const make$2 = (capacity) => {
	const queue = Object.create(MutableQueueProto);
	queue.queue = empty();
	queue.capacity = capacity;
	return queue;
};
/**
* Creates a new unbounded `MutableQueue`.
*
* @since 2.0.0
* @category constructors
*/
const unbounded = () => make$2(void 0);
/**
* Offers an element to the queue.
*
* Returns whether the enqueue was successful or not.
*
* @since 2.0.0
*/
const offer = /* @__PURE__ */ dual(2, (self, value) => {
	const queueLength = length(self.queue);
	if (self.capacity !== void 0 && queueLength === self.capacity) return false;
	append(value)(self.queue);
	return true;
});
/**
* Dequeues an element from the queue.
*
* Returns either an element from the queue, or the `def` param.
*
* **Note**: if there is no meaningful default for your type, you can always
* use `poll(MutableQueue.EmptyMutableQueue)`.
*
* @since 2.0.0
*/
const poll = /* @__PURE__ */ dual(2, (self, def) => {
	if (isEmpty(self.queue)) return def;
	return shift(self.queue);
});

//#endregion
//#region ../../node_modules/.bun/effect@3.17.14/node_modules/effect/dist/esm/internal/cache.js
/** @internal */
const complete$1 = (key, exit$3, entryStats, timeToLiveMillis) => struct$1({
	_tag: "Complete",
	key,
	exit: exit$3,
	entryStats,
	timeToLiveMillis
});
/** @internal */
const pending = (key, deferred) => struct$1({
	_tag: "Pending",
	key,
	deferred
});
/** @internal */
const refreshing = (deferred, complete$4) => struct$1({
	_tag: "Refreshing",
	deferred,
	complete: complete$4
});
/** @internal */
const MapKeyTypeId = /* @__PURE__ */ Symbol.for("effect/Cache/MapKey");
var MapKeyImpl = class {
	current;
	[MapKeyTypeId] = MapKeyTypeId;
	previous = void 0;
	next = void 0;
	constructor(current) {
		this.current = current;
	}
	[symbol$1]() {
		return pipe(hash(this.current), combine$11(hash(this.previous)), combine$11(hash(this.next)), cached$2(this));
	}
	[symbol](that) {
		if (this === that) return true;
		return isMapKey(that) && equals(this.current, that.current) && equals(this.previous, that.previous) && equals(this.next, that.next);
	}
};
/** @internal */
const makeMapKey = (current) => new MapKeyImpl(current);
/** @internal */
const isMapKey = (u) => hasProperty(u, MapKeyTypeId);
var KeySetImpl = class {
	head = void 0;
	tail = void 0;
	add(key) {
		if (key !== this.tail) if (this.tail === void 0) {
			this.head = key;
			this.tail = key;
		} else {
			const previous = key.previous;
			const next = key.next;
			if (next !== void 0) {
				key.next = void 0;
				if (previous !== void 0) {
					previous.next = next;
					next.previous = previous;
				} else {
					this.head = next;
					this.head.previous = void 0;
				}
			}
			this.tail.next = key;
			key.previous = this.tail;
			this.tail = key;
		}
	}
	remove() {
		const key = this.head;
		if (key !== void 0) {
			const next = key.next;
			if (next !== void 0) {
				key.next = void 0;
				this.head = next;
				this.head.previous = void 0;
			} else {
				this.head = void 0;
				this.tail = void 0;
			}
		}
		return key;
	}
};
/** @internal */
const makeKeySet = () => new KeySetImpl();
/**
* Constructs a new `CacheState` from the specified values.
*
* @internal
*/
const makeCacheState = (map$17, keys$5, accesses, updating, hits, misses) => ({
	map: map$17,
	keys: keys$5,
	accesses,
	updating,
	hits,
	misses
});
/**
* Constructs an initial cache state.
*
* @internal
*/
const initialCacheState = () => makeCacheState(empty$8(), makeKeySet(), unbounded(), make$34(false), 0, 0);
/** @internal */
const CacheSymbolKey = "effect/Cache";
/** @internal */
const CacheTypeId = /* @__PURE__ */ Symbol.for(CacheSymbolKey);
const cacheVariance = {
	_Key: (_) => _,
	_Error: (_) => _,
	_Value: (_) => _
};
/** @internal */
const ConsumerCacheSymbolKey = "effect/ConsumerCache";
/** @internal */
const ConsumerCacheTypeId = /* @__PURE__ */ Symbol.for(ConsumerCacheSymbolKey);
const consumerCacheVariance = {
	_Key: (_) => _,
	_Error: (_) => _,
	_Value: (_) => _
};
/** @internal */
const makeCacheStats = (options) => options;
/** @internal */
const makeEntryStats = (loadedMillis) => ({ loadedMillis });
var CacheImpl = class {
	capacity;
	context;
	fiberId;
	lookup;
	timeToLive;
	[CacheTypeId] = cacheVariance;
	[ConsumerCacheTypeId] = consumerCacheVariance;
	cacheState;
	constructor(capacity, context$2, fiberId$2, lookup, timeToLive) {
		this.capacity = capacity;
		this.context = context$2;
		this.fiberId = fiberId$2;
		this.lookup = lookup;
		this.timeToLive = timeToLive;
		this.cacheState = initialCacheState();
	}
	get(key) {
		return map$8(this.getEither(key), merge$6);
	}
	get cacheStats() {
		return sync$3(() => makeCacheStats({
			hits: this.cacheState.hits,
			misses: this.cacheState.misses,
			size: size$4(this.cacheState.map)
		}));
	}
	getOption(key) {
		return suspend$3(() => match$10(get(this.cacheState.map, key), {
			onNone: () => {
				const mapKey = makeMapKey(key);
				this.trackAccess(mapKey);
				this.trackMiss();
				return succeed$9(none$7());
			},
			onSome: (value) => this.resolveMapValue(value)
		}));
	}
	getOptionComplete(key) {
		return suspend$3(() => match$10(get(this.cacheState.map, key), {
			onNone: () => {
				const mapKey = makeMapKey(key);
				this.trackAccess(mapKey);
				this.trackMiss();
				return succeed$9(none$7());
			},
			onSome: (value) => this.resolveMapValue(value, true)
		}));
	}
	contains(key) {
		return sync$3(() => has$2(this.cacheState.map, key));
	}
	entryStats(key) {
		return sync$3(() => {
			const option$2 = get(this.cacheState.map, key);
			if (isSome(option$2)) switch (option$2.value._tag) {
				case "Complete": {
					const loaded = option$2.value.entryStats.loadedMillis;
					return some$4(makeEntryStats(loaded));
				}
				case "Pending": return none$7();
				case "Refreshing": {
					const loaded = option$2.value.complete.entryStats.loadedMillis;
					return some$4(makeEntryStats(loaded));
				}
			}
			return none$7();
		});
	}
	getEither(key) {
		return suspend$3(() => {
			const k = key;
			let mapKey = void 0;
			let deferred = void 0;
			let value = getOrUndefined(get(this.cacheState.map, k));
			if (value === void 0) {
				deferred = unsafeMake(this.fiberId);
				mapKey = makeMapKey(k);
				if (has$2(this.cacheState.map, k)) value = getOrUndefined(get(this.cacheState.map, k));
				else set(this.cacheState.map, k, pending(mapKey, deferred));
			}
			if (value === void 0) {
				this.trackAccess(mapKey);
				this.trackMiss();
				return map$8(this.lookupValueOf(key, deferred), right);
			} else return flatMap$4(this.resolveMapValue(value), match$10({
				onNone: () => this.getEither(key),
				onSome: (value$1) => succeed$9(left(value$1))
			}));
		});
	}
	invalidate(key) {
		return sync$3(() => {
			remove$2(this.cacheState.map, key);
		});
	}
	invalidateWhen(key, when$2) {
		return sync$3(() => {
			const value = get(this.cacheState.map, key);
			if (isSome(value) && value.value._tag === "Complete") {
				if (value.value.exit._tag === "Success") {
					if (when$2(value.value.exit.value)) remove$2(this.cacheState.map, key);
				}
			}
		});
	}
	get invalidateAll() {
		return sync$3(() => {
			this.cacheState.map = empty$8();
		});
	}
	refresh(key) {
		return clockWith$1((clock$2) => suspend$3(() => {
			const k = key;
			const deferred = unsafeMake(this.fiberId);
			let value = getOrUndefined(get(this.cacheState.map, k));
			if (value === void 0) if (has$2(this.cacheState.map, k)) value = getOrUndefined(get(this.cacheState.map, k));
			else set(this.cacheState.map, k, pending(makeMapKey(k), deferred));
			if (value === void 0) return asVoid$3(this.lookupValueOf(key, deferred));
			else switch (value._tag) {
				case "Complete":
					if (this.hasExpired(clock$2, value.timeToLiveMillis)) {
						const found = getOrUndefined(get(this.cacheState.map, k));
						if (equals(found, value)) remove$2(this.cacheState.map, k);
						return asVoid$3(this.get(key));
					}
					return pipe(this.lookupValueOf(key, deferred), when$1(() => {
						const current = getOrUndefined(get(this.cacheState.map, k));
						if (equals(current, value)) {
							const mapValue = refreshing(deferred, value);
							set(this.cacheState.map, k, mapValue);
							return true;
						}
						return false;
					}), asVoid$3);
				case "Pending": return _await(value.deferred);
				case "Refreshing": return _await(value.deferred);
			}
		}));
	}
	set(key, value) {
		return clockWith$1((clock$2) => sync$3(() => {
			const now = clock$2.unsafeCurrentTimeMillis();
			const k = key;
			const lookupResult = succeed$7(value);
			const mapValue = complete$1(makeMapKey(k), lookupResult, makeEntryStats(now), now + toMillis(decode$3(this.timeToLive(lookupResult))));
			set(this.cacheState.map, k, mapValue);
		}));
	}
	get size() {
		return sync$3(() => {
			return size$4(this.cacheState.map);
		});
	}
	get values() {
		return sync$3(() => {
			const values$6 = [];
			for (const entry of this.cacheState.map) if (entry[1]._tag === "Complete" && entry[1].exit._tag === "Success") values$6.push(entry[1].exit.value);
			return values$6;
		});
	}
	get entries() {
		return sync$3(() => {
			const values$6 = [];
			for (const entry of this.cacheState.map) if (entry[1]._tag === "Complete" && entry[1].exit._tag === "Success") values$6.push([entry[0], entry[1].exit.value]);
			return values$6;
		});
	}
	get keys() {
		return sync$3(() => {
			const keys$5 = [];
			for (const entry of this.cacheState.map) if (entry[1]._tag === "Complete" && entry[1].exit._tag === "Success") keys$5.push(entry[0]);
			return keys$5;
		});
	}
	resolveMapValue(value, ignorePending = false) {
		return clockWith$1((clock$2) => {
			switch (value._tag) {
				case "Complete":
					this.trackAccess(value.key);
					if (this.hasExpired(clock$2, value.timeToLiveMillis)) {
						remove$2(this.cacheState.map, value.key.current);
						return succeed$9(none$7());
					}
					this.trackHit();
					return map$8(value.exit, some$4);
				case "Pending":
					this.trackAccess(value.key);
					this.trackHit();
					if (ignorePending) return succeed$9(none$7());
					return map$8(_await(value.deferred), some$4);
				case "Refreshing":
					this.trackAccess(value.complete.key);
					this.trackHit();
					if (this.hasExpired(clock$2, value.complete.timeToLiveMillis)) {
						if (ignorePending) return succeed$9(none$7());
						return map$8(_await(value.deferred), some$4);
					}
					return map$8(value.complete.exit, some$4);
			}
		});
	}
	trackHit() {
		this.cacheState.hits = this.cacheState.hits + 1;
	}
	trackMiss() {
		this.cacheState.misses = this.cacheState.misses + 1;
	}
	trackAccess(key) {
		offer(this.cacheState.accesses, key);
		if (compareAndSet(this.cacheState.updating, false, true)) {
			let loop$2 = true;
			while (loop$2) {
				const key$1 = poll(this.cacheState.accesses, EmptyMutableQueue);
				if (key$1 === EmptyMutableQueue) loop$2 = false;
				else this.cacheState.keys.add(key$1);
			}
			let size$9 = size$4(this.cacheState.map);
			loop$2 = size$9 > this.capacity;
			while (loop$2) {
				const key$1 = this.cacheState.keys.remove();
				if (key$1 !== void 0) {
					if (has$2(this.cacheState.map, key$1.current)) {
						remove$2(this.cacheState.map, key$1.current);
						size$9 = size$9 - 1;
						loop$2 = size$9 > this.capacity;
					}
				} else loop$2 = false;
			}
			set$4(this.cacheState.updating, false);
		}
	}
	hasExpired(clock$2, timeToLiveMillis) {
		return clock$2.unsafeCurrentTimeMillis() > timeToLiveMillis;
	}
	lookupValueOf(input, deferred) {
		return clockWith$1((clock$2) => suspend$3(() => {
			const key = input;
			return pipe(this.lookup(input), provideContext$1(this.context), exit$2, flatMap$4((exit$3) => {
				const now = clock$2.unsafeCurrentTimeMillis();
				const stats = makeEntryStats(now);
				const value = complete$1(makeMapKey(key), exit$3, stats, now + toMillis(decode$3(this.timeToLive(exit$3))));
				set(this.cacheState.map, key, value);
				return zipRight$3(done(deferred, exit$3), exit$3);
			}), onInterrupt$1(() => zipRight$3(interrupt$1(deferred), sync$3(() => {
				remove$2(this.cacheState.map, key);
			}))));
		}));
	}
};
/** @internal */
const unsafeMakeWith = (capacity, lookup, timeToLive) => new CacheImpl(capacity, empty$25(), none$1, lookup, (exit$3) => decode$3(timeToLive(exit$3)));

//#endregion
//#region ../../node_modules/.bun/effect@3.17.14/node_modules/effect/dist/esm/internal/query.js
/** @internal */
const currentCache = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentCache"), () => fiberRefUnsafeMake(unsafeMakeWith(65536, () => map$8(deferredMake(), (handle) => ({
	listeners: new Listeners(),
	handle
})), () => seconds(60))));
/** @internal */
const currentCacheEnabled = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentCacheEnabled"), () => fiberRefUnsafeMake(false));
/** @internal */
const fromRequest = (request$1, dataSource) => flatMap$4(isEffect$1(dataSource) ? dataSource : succeed$9(dataSource), (ds) => fiberIdWith$1((id$2) => {
	const proxy = new Proxy(request$1, {});
	return fiberRefGetWith(currentCacheEnabled, (cacheEnabled) => {
		if (cacheEnabled) {
			const cached$3 = fiberRefGetWith(currentCache, (cache) => flatMap$4(cache.getEither(proxy), (orNew) => {
				switch (orNew._tag) {
					case "Left":
						if (orNew.left.listeners.interrupted) return flatMap$4(cache.invalidateWhen(proxy, (entry) => entry.handle === orNew.left.handle), () => cached$3);
						orNew.left.listeners.increment();
						return uninterruptibleMask$2((restore) => flatMap$4(exit$2(blocked$1(empty$14, restore(deferredAwait(orNew.left.handle)))), (exit$3) => {
							orNew.left.listeners.decrement();
							return exit$3;
						}));
					case "Right":
						orNew.right.listeners.increment();
						return uninterruptibleMask$2((restore) => flatMap$4(exit$2(blocked$1(single(ds, makeEntry$1({
							request: proxy,
							result: orNew.right.handle,
							listeners: orNew.right.listeners,
							ownerId: id$2,
							state: { completed: false }
						})), restore(deferredAwait(orNew.right.handle)))), () => {
							orNew.right.listeners.decrement();
							return deferredAwait(orNew.right.handle);
						}));
				}
			}));
			return cached$3;
		}
		const listeners = new Listeners();
		listeners.increment();
		return flatMap$4(deferredMake(), (ref) => ensuring$1(blocked$1(single(ds, makeEntry$1({
			request: proxy,
			result: ref,
			listeners,
			ownerId: id$2,
			state: { completed: false }
		})), deferredAwait(ref)), sync$3(() => listeners.decrement())));
	});
}));
/** @internal */
const cacheRequest = (request$1, result) => {
	return fiberRefGetWith(currentCacheEnabled, (cacheEnabled) => {
		if (cacheEnabled) return fiberRefGetWith(currentCache, (cache) => flatMap$4(cache.getEither(request$1), (orNew) => {
			switch (orNew._tag) {
				case "Left": return void_$4;
				case "Right": return deferredComplete(orNew.right.handle, result);
			}
		}));
		return void_$4;
	});
};
/** @internal */
const withRequestCaching$1 = /* @__PURE__ */ dual(2, (self, strategy) => fiberRefLocally(self, currentCacheEnabled, strategy));
/** @internal */
const withRequestCache$1 = /* @__PURE__ */ dual(2, (self, cache) => fiberRefLocally(self, currentCache, cache));

//#endregion
//#region ../../node_modules/.bun/effect@3.17.14/node_modules/effect/dist/esm/Request.js
/**
* @since 2.0.0
* @category symbols
*/
const RequestTypeId = RequestTypeId$1;
/**
* Returns `true` if the specified value is a `Request`, `false` otherwise.
*
* @since 2.0.0
* @category refinements
*/
const isRequest = isRequest$1;
/**
* Constructs a new `Request`.
*
* @since 2.0.0
* @category constructors
*/
const of = of$1;
/**
* Constructs a new `Request`.
*
* @since 2.0.0
* @category constructors
*/
const tagged = tagged$1;
/**
* Provides a constructor for a Request Class.
*
* @example
* ```ts
* import { Request } from "effect"
*
* type Success = string
* type Error = never
*
* class MyRequest extends Request.Class<Success, Error, {
*   readonly id: string
* }> {}
* ```
*
* @since 2.0.0
* @category constructors
*/
const Class = Class$1;
/**
* Provides a Tagged constructor for a Request Class.
*
* @example
* ```ts
* import { Request } from "effect"
*
* type Success = string
* type Error = never
*
* class MyRequest extends Request.TaggedClass("MyRequest")<Success, Error, {
*   readonly name: string
* }> {}
* ```
*
* @since 2.0.0
* @category constructors
*/
const TaggedClass = TaggedClass$1;
/**
* Complete a `Request` with the specified result.
*
* @since 2.0.0
* @category request completion
*/
const complete = complete$3;
/**
* Interrupts the child effect when requests are no longer needed
*
* @since 2.0.0
* @category request completion
*/
const interruptWhenPossible = interruptWhenPossible$1;
/**
* Complete a `Request` with the specified effectful computation, failing the
* request with the error from the effect workflow if it fails, and completing
* the request with the value of the effect workflow if it succeeds.
*
* @since 2.0.0
* @category request completion
*/
const completeEffect = completeEffect$1;
/**
* Complete a `Request` with the specified error.
*
* @since 2.0.0
* @category request completion
*/
const fail$2 = fail$5;
/**
* Complete a `Request` with the specified cause.
*
* @since 2.0.0
* @category request completion
*/
const failCause$1 = failCause$4;
/**
* Complete a `Request` with the specified value.
*
* @since 2.0.0
* @category request completion
*/
const succeed$2 = succeed$5;
/**
* @since 2.0.0
* @category guards
*/
const isEntry = isEntry$1;
/**
* @since 2.0.0
* @category constructors
*/
const makeEntry = makeEntry$1;

//#endregion
//#region ../../node_modules/.bun/effect@3.17.14/node_modules/effect/dist/esm/Effect.js
/**
* @since 2.0.0
* @category Symbols
*/
const EffectTypeId = EffectTypeId$2;
/**
* Checks if a given value is an `Effect` value.
*
* **When to Use**
*
* This function can be useful for checking the type of a value before
* attempting to operate on it as an `Effect` value. For example, you could use
* `Effect.isEffect` to check the type of a value before using it as an argument
* to a function that expects an `Effect` value.
*
* @since 2.0.0
* @category Guards
*/
const isEffect = isEffect$1;
/**
* Returns an effect that caches its result for a specified `Duration`,
* known as "timeToLive" (TTL).
*
* **Details**
*
* This function is used to cache the result of an effect for a specified amount
* of time. This means that the first time the effect is evaluated, its result
* is computed and stored.
*
* If the effect is evaluated again within the specified `timeToLive`, the
* cached result will be used, avoiding recomputation.
*
* After the specified duration has passed, the cache expires, and the effect
* will be recomputed upon the next evaluation.
*
* **When to Use**
*
* Use this function when you have an effect that involves costly operations or
* computations, and you want to avoid repeating them within a short time frame.
*
* It's ideal for scenarios where the result of an effect doesn't change
* frequently and can be reused for a specified duration.
*
* By caching the result, you can improve efficiency and reduce unnecessary
* computations, especially in performance-critical applications.
*
* **Example**
*
* ```ts
* import { Effect, Console } from "effect"
*
* let i = 1
* const expensiveTask = Effect.promise<string>(() => {
*   console.log("expensive task...")
*   return new Promise((resolve) => {
*     setTimeout(() => {
*       resolve(`result ${i++}`)
*     }, 100)
*   })
* })
*
* const program = Effect.gen(function* () {
*   const cached = yield* Effect.cachedWithTTL(expensiveTask, "150 millis")
*   yield* cached.pipe(Effect.andThen(Console.log))
*   yield* cached.pipe(Effect.andThen(Console.log))
*   yield* Effect.sleep("100 millis")
*   yield* cached.pipe(Effect.andThen(Console.log))
* })
*
* Effect.runFork(program)
* // Output:
* // expensive task...
* // result 1
* // result 1
* // expensive task...
* // result 2
* ```
*
* @see {@link cached} for a similar function that caches the result
* indefinitely.
* @see {@link cachedInvalidateWithTTL} for a similar function that includes an
* additional effect for manually invalidating the cached value.
*
* @since 2.0.0
* @category Caching
*/
const cachedWithTTL = cached$1;
/**
* Caches an effect's result for a specified duration and allows manual
* invalidation before expiration.
*
* **Details**
*
* This function behaves similarly to {@link cachedWithTTL} by caching the
* result of an effect for a specified period of time. However, it introduces an
* additional feature: it provides an effect that allows you to manually
* invalidate the cached result before it naturally expires.
*
* This gives you more control over the cache, allowing you to refresh the
* result when needed, even if the original cache has not yet expired.
*
* Once the cache is invalidated, the next time the effect is evaluated, the
* result will be recomputed, and the cache will be refreshed.
*
* **When to Use**
*
* Use this function when you have an effect whose result needs to be cached for
* a certain period, but you also want the option to refresh the cache manually
* before the expiration time.
*
* This is useful when you need to ensure that the cached data remains valid for
* a certain period but still want to invalidate it if the underlying data
* changes or if you want to force a recomputation.
*
* **Example**
*
* ```ts
* import { Effect, Console } from "effect"
*
* let i = 1
* const expensiveTask = Effect.promise<string>(() => {
*   console.log("expensive task...")
*   return new Promise((resolve) => {
*     setTimeout(() => {
*       resolve(`result ${i++}`)
*     }, 100)
*   })
* })
*
* const program = Effect.gen(function* () {
*   const [cached, invalidate] = yield* Effect.cachedInvalidateWithTTL(
*     expensiveTask,
*     "1 hour"
*   )
*   yield* cached.pipe(Effect.andThen(Console.log))
*   yield* cached.pipe(Effect.andThen(Console.log))
*   yield* invalidate
*   yield* cached.pipe(Effect.andThen(Console.log))
* })
*
* Effect.runFork(program)
* // Output:
* // expensive task...
* // result 1
* // result 1
* // expensive task...
* // result 2
* ```
*
* @see {@link cached} for a similar function that caches the result
* indefinitely.
* @see {@link cachedWithTTL} for a similar function that caches the result for
* a specified duration but does not include an effect for manual invalidation.
*
* @since 2.0.0
* @category Caching
*/
const cachedInvalidateWithTTL = cachedInvalidateWithTTL$1;
/**
* Returns an effect that lazily computes a result and caches it for subsequent
* evaluations.
*
* **Details**
*
* This function wraps an effect and ensures that its result is computed only
* once. Once the result is computed, it is cached, meaning that subsequent
* evaluations of the same effect will return the cached result without
* re-executing the logic.
*
* **When to Use**
*
* Use this function when you have an expensive or time-consuming operation that
* you want to avoid repeating. The first evaluation will compute the result,
* and all following evaluations will immediately return the cached value,
* improving performance and reducing unnecessary work.
*
* **Example**
*
* ```ts
* import { Effect, Console } from "effect"
*
* let i = 1
* const expensiveTask = Effect.promise<string>(() => {
*   console.log("expensive task...")
*   return new Promise((resolve) => {
*     setTimeout(() => {
*       resolve(`result ${i++}`)
*     }, 100)
*   })
* })
*
* const program = Effect.gen(function* () {
*   console.log("non-cached version:")
*   yield* expensiveTask.pipe(Effect.andThen(Console.log))
*   yield* expensiveTask.pipe(Effect.andThen(Console.log))
*   console.log("cached version:")
*   const cached = yield* Effect.cached(expensiveTask)
*   yield* cached.pipe(Effect.andThen(Console.log))
*   yield* cached.pipe(Effect.andThen(Console.log))
* })
*
* Effect.runFork(program)
* // Output:
* // non-cached version:
* // expensive task...
* // result 1
* // expensive task...
* // result 2
* // cached version:
* // expensive task...
* // result 3
* // result 3
* ```
*
* @see {@link cachedWithTTL} for a similar function that includes a
* time-to-live duration for the cached value.
* @see {@link cachedInvalidateWithTTL} for a similar function that includes an
* additional effect for manually invalidating the cached value.
*
* @since 2.0.0
* @category Caching
*/
const cached = memoize;
/**
* Returns a memoized version of a function with effects, reusing results for
* the same inputs.
*
* **Details**
*
* This function creates a memoized version of a given function that performs an
* effect. Memoization ensures that once a result is computed for a specific
* input, it is stored and reused for subsequent calls with the same input,
* reducing the need to recompute the result.
*
* The function can optionally take an `Equivalence` parameter to
* determine how inputs are compared for caching purposes.
*
* **When to Use**
*
* Use this function when you have a function that performs an effect and you
* want to avoid recomputing the result for the same input multiple times.
*
* It's ideal for functions that produce deterministic results based on their
* inputs, and you want to improve performance by caching the output.
*
* This is particularly useful in scenarios where the function involves
* expensive calculations or operations that should be avoided after the first
* execution with the same parameters.
*
* **Example**
*
* ```ts
* import { Effect, Random } from "effect"
*
* const program = Effect.gen(function* () {
*   const randomNumber = (n: number) => Random.nextIntBetween(1, n)
*   console.log("non-memoized version:")
*   console.log(yield* randomNumber(10))
*   console.log(yield* randomNumber(10))
*
*   console.log("memoized version:")
*   const memoized = yield* Effect.cachedFunction(randomNumber)
*   console.log(yield* memoized(10))
*   console.log(yield* memoized(10))
* })
*
* Effect.runFork(program)
* // Example Output:
* // non-memoized version:
* // 2
* // 8
* // memoized version:
* // 5
* // 5
* ```
*
* @since 2.0.0
* @category Caching
*/
const cachedFunction = cachedFunction$1;
/**
* Returns an effect that executes only once, regardless of how many times it's
* called.
*
* **Details**
*
* This function ensures that a specific effect is executed only a single time,
* no matter how many times it is invoked. The result of the effect will be
* cached, and subsequent calls to the effect will immediately return the cached
* result without re-executing the original logic.
*
* **When to Use**
*
* Use this function when you need to perform a task only once, regardless of
* how many times the effect is triggered. It's particularly useful when you
* have initialization tasks, logging, or other one-time actions that should not
* be repeated. This can help optimize performance and avoid redundant actions.
*
* **Example**
*
* ```ts
* import { Effect, Console } from "effect"
*
* const program = Effect.gen(function* () {
*   const task1 = Console.log("task1")
*   yield* Effect.repeatN(task1, 2)
*   const task2 = yield* Effect.once(Console.log("task2"))
*   yield* Effect.repeatN(task2, 2)
* })
*
* Effect.runFork(program)
* // Output:
* // task1
* // task1
* // task1
* // task2
* ```
*
* @since 2.0.0
* @category Caching
*/
const once = once$2;
/**
* Combines multiple effects into one, returning results based on the input
* structure.
*
* **Details**
*
* Use this function when you need to run multiple effects and combine their
* results into a single output. It supports tuples, iterables, structs, and
* records, making it flexible for different input types.
*
* For instance, if the input is a tuple:
*
* ```ts skip-type-checking
* //         ┌─── a tuple of effects
* //         ▼
* Effect.all([effect1, effect2, ...])
* ```
*
* the effects are executed sequentially, and the result is a new effect
* containing the results as a tuple. The results in the tuple match the order
* of the effects passed to `Effect.all`.
*
* **Concurrency**
*
* You can control the execution order (e.g., sequential vs. concurrent) using
* the `concurrency` option.
*
* **Short-Circuiting Behavior**
*
* This function stops execution on the first error it encounters, this is
* called "short-circuiting". If any effect in the collection fails, the
* remaining effects will not run, and the error will be propagated. To change
* this behavior, you can use the `mode` option, which allows all effects to run
* and collect results as `Either` or `Option`.
*
* **The `mode` option**
*
* The `{ mode: "either" }` option changes the behavior of `Effect.all` to
* ensure all effects run, even if some fail. Instead of stopping on the first
* failure, this mode collects both successes and failures, returning an array
* of `Either` instances where each result is either a `Right` (success) or a
* `Left` (failure).
*
* Similarly, the `{ mode: "validate" }` option uses `Option` to indicate
* success or failure. Each effect returns `None` for success and `Some` with
* the error for failure.
*
* **Example** (Combining Effects in Tuples)
*
* ```ts
* import { Effect, Console } from "effect"
*
* const tupleOfEffects = [
*   Effect.succeed(42).pipe(Effect.tap(Console.log)),
*   Effect.succeed("Hello").pipe(Effect.tap(Console.log))
* ] as const
*
* //      ┌─── Effect<[number, string], never, never>
* //      ▼
* const resultsAsTuple = Effect.all(tupleOfEffects)
*
* Effect.runPromise(resultsAsTuple).then(console.log)
* // Output:
* // 42
* // Hello
* // [ 42, 'Hello' ]
* ```
*
* **Example** (Combining Effects in Iterables)
*
* ```ts
* import { Effect, Console } from "effect"
*
* const iterableOfEffects: Iterable<Effect.Effect<number>> = [1, 2, 3].map(
*   (n) => Effect.succeed(n).pipe(Effect.tap(Console.log))
* )
*
* //      ┌─── Effect<number[], never, never>
* //      ▼
* const resultsAsArray = Effect.all(iterableOfEffects)
*
* Effect.runPromise(resultsAsArray).then(console.log)
* // Output:
* // 1
* // 2
* // 3
* // [ 1, 2, 3 ]
* ```
*
* **Example** (Combining Effects in Structs)
*
* ```ts
* import { Effect, Console } from "effect"
*
* const structOfEffects = {
*   a: Effect.succeed(42).pipe(Effect.tap(Console.log)),
*   b: Effect.succeed("Hello").pipe(Effect.tap(Console.log))
* }
*
* //      ┌─── Effect<{ a: number; b: string; }, never, never>
* //      ▼
* const resultsAsStruct = Effect.all(structOfEffects)
*
* Effect.runPromise(resultsAsStruct).then(console.log)
* // Output:
* // 42
* // Hello
* // { a: 42, b: 'Hello' }
* ```
*
* **Example** (Combining Effects in Records)
*
* ```ts
* import { Effect, Console } from "effect"
*
* const recordOfEffects: Record<string, Effect.Effect<number>> = {
*   key1: Effect.succeed(1).pipe(Effect.tap(Console.log)),
*   key2: Effect.succeed(2).pipe(Effect.tap(Console.log))
* }
*
* //      ┌─── Effect<{ [x: string]: number; }, never, never>
* //      ▼
* const resultsAsRecord = Effect.all(recordOfEffects)
*
* Effect.runPromise(resultsAsRecord).then(console.log)
* // Output:
* // 1
* // 2
* // { key1: 1, key2: 2 }
* ```
*
* **Example** (Short-Circuiting Behavior)
*
* ```ts
* import { Effect, Console } from "effect"
*
* const program = Effect.all([
*   Effect.succeed("Task1").pipe(Effect.tap(Console.log)),
*   Effect.fail("Task2: Oh no!").pipe(Effect.tap(Console.log)),
*   // Won't execute due to earlier failure
*   Effect.succeed("Task3").pipe(Effect.tap(Console.log))
* ])
*
* Effect.runPromiseExit(program).then(console.log)
* // Output:
* // Task1
* // {
* //   _id: 'Exit',
* //   _tag: 'Failure',
* //   cause: { _id: 'Cause', _tag: 'Fail', failure: 'Task2: Oh no!' }
* // }
* ```
*
* **Example** (Collecting Results with `mode: "either"`)
*
* ```ts
* import { Effect, Console } from "effect"
*
* const effects = [
*   Effect.succeed("Task1").pipe(Effect.tap(Console.log)),
*   Effect.fail("Task2: Oh no!").pipe(Effect.tap(Console.log)),
*   Effect.succeed("Task3").pipe(Effect.tap(Console.log))
* ]
*
* const program = Effect.all(effects, { mode: "either" })
*
* Effect.runPromiseExit(program).then(console.log)
* // Output:
* // Task1
* // Task3
* // {
* //   _id: 'Exit',
* //   _tag: 'Success',
* //   value: [
* //     { _id: 'Either', _tag: 'Right', right: 'Task1' },
* //     { _id: 'Either', _tag: 'Left', left: 'Task2: Oh no!' },
* //     { _id: 'Either', _tag: 'Right', right: 'Task3' }
* //   ]
* // }
* ```
*
* **Example** (Collecting Results with `mode: "validate"`)
*
* ```ts
* import { Effect, Console } from "effect"
*
* const effects = [
*   Effect.succeed("Task1").pipe(Effect.tap(Console.log)),
*   Effect.fail("Task2: Oh no!").pipe(Effect.tap(Console.log)),
*   Effect.succeed("Task3").pipe(Effect.tap(Console.log))
* ]
*
* const program = Effect.all(effects, { mode: "validate" })
*
* Effect.runPromiseExit(program).then((result) => console.log("%o", result))
* // Output:
* // Task1
* // Task3
* // {
* //   _id: 'Exit',
* //   _tag: 'Failure',
* //   cause: {
* //     _id: 'Cause',
* //     _tag: 'Fail',
* //     failure: [
* //       { _id: 'Option', _tag: 'None' },
* //       { _id: 'Option', _tag: 'Some', value: 'Task2: Oh no!' },
* //       { _id: 'Option', _tag: 'None' }
* //     ]
* //   }
* // }
* ```
*
* @see {@link forEach} for iterating over elements and applying an effect.
* @see {@link allWith} for a data-last version of this function.
*
* @since 2.0.0
* @category Collecting
*/
const all = all$2;
/**
* A data-last version of {@link all}, designed for use in pipelines.
*
* **When to Use**
*
* This function enables you to combine multiple effects and customize execution
* options such as concurrency levels. This version is useful in functional
* pipelines where you first define your data and then apply operations to it.
*
* **Example**
*
* ```ts
* import { Effect, pipe } from "effect"
*
* const task1 = Effect.succeed(1).pipe(
*   Effect.delay("200 millis"),
*   Effect.tap(Effect.log("task1 done"))
* )
*
* const task2 = Effect.succeed("hello").pipe(
*   Effect.delay("100 millis"),
*   Effect.tap(Effect.log("task2 done"))
* )
*
* const program = pipe(
*   [task1, task2],
*   // Run both effects concurrently using the concurrent option
*   Effect.allWith({ concurrency: 2 })
* )
*
* Effect.runPromise(program).then(console.log)
* // Output:
* // timestamp=... level=INFO fiber=#3 message="task2 done"
* // timestamp=... level=INFO fiber=#2 message="task1 done"
* // [ 1, 'hello' ]
* ```
*
* @since 2.0.0
* @category Collecting
*/
const allWith = allWith$1;
/**
* Evaluates and runs each effect in the iterable, collecting only the
* successful results while discarding failures.
*
* **Details**
*
* This function function processes an iterable of effects and runs each one. If
* an effect is successful, its result is collected; if it fails, the result is
* discarded. This ensures that only successful outcomes are kept.
*
* **Options**
*
* The function also allows you to customize how the effects are handled by
* specifying options such as concurrency, batching, and how finalizers behave.
* These options provide flexibility in running the effects concurrently or
* adjusting other execution details.
*
* **Example**
*
* ```ts
* import { Effect } from "effect"
*
* const tasks = [
*   Effect.succeed(1),
*   Effect.fail("Error 1"),
*   Effect.succeed(2),
*   Effect.fail("Error 2")
* ]
*
* const program = Effect.gen(function*() {
*   const successfulResults = yield* Effect.allSuccesses(tasks)
*   console.log(successfulResults)
* })
*
* Effect.runFork(program)
* // Output: [1, 2]
*
* ```
*
* @since 2.0.0
* @category Collecting
*/
const allSuccesses = allSuccesses$1;
/**
* Drops elements until the effectful predicate returns `true`.
*
* **Details**
*
* This function processes a collection of elements and uses an effectful
* predicate to determine when to stop dropping elements. It drops elements from
* the beginning of the collection until the predicate returns `true`.
*
* The predicate is a function that takes an element and its index in the
* collection and returns an effect that evaluates to a boolean.
*
* Once the predicate returns `true`, the remaining elements of the collection
* are returned.
*
* **Note**: The first element for which the predicate returns `true` is also
* dropped.
*
* **When to Use**
*
* This function allows you to conditionally skip over a part of the collection
* based on some criteria defined in the predicate.
*
* **Example**
*
* ```ts
* import { Effect } from "effect"
*
* const numbers = [1, 2, 3, 4, 5, 6]
* const predicate = (n: number, i: number) => Effect.succeed(n > 3)
*
* const program = Effect.gen(function*() {
*   const result = yield* Effect.dropUntil(numbers, predicate)
*   console.log(result)
* })
*
* Effect.runFork(program)
* // Output: [5, 6]
* ```
*
* @see {@link dropWhile} for a similar function that drops elements while the
* predicate returns `true`.
*
* @since 2.0.0
* @category Collecting
*/
const dropUntil = dropUntil$1;
/**
* Drops elements as long as the predicate returns `true`.
*
* **Details**
*
* This function processes a collection of elements and uses a predicate to
* decide whether to drop an element.
*
* The predicate is a function that takes an element and its index, and it
* returns an effect that evaluates to a boolean.
*
* As long as the predicate returns `true`, elements will continue to be dropped
* from the collection.
*
* Once the predicate returns `false`, the remaining elements are kept.
*
* **When to Use**
*
* This function allows you to discard elements from the start of a collection
* based on a condition, and only keep the rest when the condition no longer
* holds.
*
* **Example**
*
* ```ts
* import { Effect } from "effect"
*
* const numbers = [1, 2, 3, 4, 5, 6]
* const predicate = (n: number, i: number) => Effect.succeed(n <= 3)
*
* const program = Effect.gen(function*() {
*   const result = yield* Effect.dropWhile(numbers, predicate)
*   console.log(result)
* })
*
* Effect.runFork(program)
* // Output: [4, 5, 6]
* ```
*
* @see {@link dropUntil} for a similar function that drops elements until the
* predicate returns `true`.
*
* @since 2.0.0
* @category Collecting
*/
const dropWhile = dropWhile$1;
/**
* Takes elements from a collection until the effectful predicate returns
* `true`.
*
* **Details**
*
* This function processes a collection of elements and uses an effectful
* predicate to decide when to stop taking elements. The elements are taken from
* the beginning of the collection until the predicate returns `true`.
*
* The predicate is a function that takes an element and its index in the
* collection, and returns an effect that resolves to a boolean.
*
* Once the predicate returns `true`, the remaining elements of the collection
* are discarded, and the function stops taking more elements.
*
* **Note**: The first element for which the predicate returns `true` is also
* included in the result.
*
* **When to Use**
*
* Use this function when you want to conditionally take elements from a
* collection based on a dynamic condition. For example, you may want to collect
* numbers from a list until a certain threshold is reached, or gather items
* until a specific condition is met.
*
* **Example**
*
* ```ts
* import { Effect } from "effect"
*
* const numbers = [1, 2, 3, 4, 5, 6]
* const predicate = (n: number, i: number) => Effect.succeed(n > 3)
*
* const program = Effect.gen(function*() {
*   const result = yield* Effect.takeUntil(numbers, predicate)
*   console.log(result)
* })
*
* Effect.runFork(program)
* // Output: [ 1, 2, 3, 4 ]
* ```
*
* @see {@link takeWhile} for a similar function that takes elements while the
* predicate returns `true`.
*
* @since 2.0.0
* @category Collecting
*/
const takeUntil = takeUntil$1;
/**
* Takes elements as long as the predicate returns `true`.
*
* **Details**
*
* This function processes a collection of elements and uses a predicate to
* decide whether to take an element.
*
* The predicate is a function that takes an element and its index, and it
* returns an effect that evaluates to a boolean.
*
* As long as the predicate returns `true`, elements will continue to be taken
* from the collection.
*
* Once the predicate returns `false`, the remaining elements are discarded.
*
* **Example**
*
* ```ts
* import { Effect } from "effect"
*
* const numbers = [1, 2, 3, 4, 5, 6]
* const predicate = (n: number, i: number) => Effect.succeed(n <= 3)
*
* const program = Effect.gen(function*() {
*   const result = yield* Effect.takeWhile(numbers, predicate)
*   console.log(result)
* })
*
* Effect.runFork(program)
* // Output: [1, 2, 3]
* ```
*
* @see {@link takeUntil} for a similar function that takes elements until the predicate returns `true`.
*
* @since 2.0.0
* @category Collecting
*/
const takeWhile = takeWhile$1;
/**
* Determines whether all elements of the iterable satisfy the effectful
* predicate.
*
* **Details**
*
* This function checks whether every element in a given collection (an
* iterable) satisfies a condition defined by an effectful predicate.
*
* The predicate is a function that takes an element and its index, and it
* returns an effect that evaluates to a boolean.
*
* The function will process each element and return `true` if all elements
* satisfy the predicate; otherwise, it returns `false`.
*
* **When to Use**
*
* This function is useful when you need to verify that all items in a
* collection meet certain criteria, even when the evaluation of each item
* involves effects, such as asynchronous checks or complex computations.
*
* **Example**
*
* ```ts
* import { Effect } from "effect"
*
* const numbers = [2, 4, 6, 8]
* const predicate = (n: number, i: number) => Effect.succeed(n % 2 === 0)
*
* const program = Effect.gen(function*() {
*   const allEven = yield* Effect.every(numbers, predicate)
*   console.log(allEven)
* })
*
* Effect.runFork(program)
* // Output: true
* ```
*
* @see {@link exists} for a similar function that returns a boolean indicating
* whether **any** element satisfies the predicate.
*
* @since 2.0.0
* @category Condition Checking
*/
const every = every$1;
/**
* Determines whether any element of the iterable satisfies the effectual
* predicate.
*
* **Details**
*
* This function checks whether any element in a given collection (an iterable)
* satisfies a condition defined by an effectful predicate.
*
* The predicate is a function that takes an element and its index, and it
* returns an effect that evaluates to a boolean.
*
* The function will process each element, and if any element satisfies the
* predicate (returns `true`), the function will immediately return `true`.
*
* If none of the elements satisfy the condition, it will return `false`.
*
* **When to Use**
*
* This function allows you to quickly check for a condition in a collection
* without having to manually iterate over it.
*
* **Example**
*
* ```ts
* import { Effect } from "effect"
*
* const numbers = [1, 2, 3, 4]
* const predicate = (n: number, i: number) => Effect.succeed(n > 2)
*
* const program = Effect.gen(function*() {
*   const hasLargeNumber = yield* Effect.exists(numbers, predicate)
*   console.log(hasLargeNumber)
* })
*
* Effect.runFork(program)
* // Output: true
* ```
*
* @see {@link every} for a similar function that checks if **all** elements
* satisfy the predicate.
*
* @since 2.0.0
* @category Condition Checking
*/
const exists = exists$1;
/**
* Filters an iterable using the specified effectful predicate.
*
* **Details**
*
* This function filters a collection (an iterable) by applying an effectful
* predicate.
*
* The predicate is a function that takes an element and its index, and it
* returns an effect that evaluates to a boolean.
*
* The function processes each element in the collection and keeps only those
* that satisfy the condition defined by the predicate.
*
* **Options**
*
* You can also adjust the behavior with options such as concurrency, batching,
* or whether to negate the condition.
*
* **When to Use**
*
* This function allows you to selectively keep or remove elements based on a
* condition that may involve asynchronous or side-effect-causing operations.
*
* **Example**
*
* ```ts
* import { Effect } from "effect"
*
* const numbers = [1, 2, 3, 4, 5]
* const predicate = (n: number, i: number) => Effect.succeed(n % 2 === 0)
*
* const program = Effect.gen(function*() {
*   const result = yield* Effect.filter(numbers, predicate)
*   console.log(result)
* })
*
* Effect.runFork(program)
* // Output: [2, 4]
* ```
*
* @since 2.0.0
* @category Filtering
*/
const filter$1 = filter$2;
/**
* Filters and maps elements sequentially in one operation.
*
* This function processes each element one by one. It applies a function that
* returns an `Option` to each element. If the function returns `Some`, the
* element is kept; if it returns `None`, the element is removed. The operation
* is done sequentially for each element.
*
* **Example**
*
* ```ts
* import { Console, Effect, Option } from "effect"
*
* const task = (n: number) =>
*   Effect.succeed(n).pipe(
*     Effect.delay(1000 - (n * 100)),
*     Effect.tap(Console.log(`task${n} done`))
*   )
*
* const program = Effect.filterMap(
*   [task(1), task(2), task(3), task(4)],
*   (n) => n % 2 === 0 ? Option.some(n) : Option.none()
* )
*
* Effect.runPromise(program).then(console.log)
* // Output:
* // task1 done
* // task2 done
* // task3 done
* // task4 done
* // [ 2, 4 ]
* ```
*
* @since 2.0.0
* @category Filtering
*/
const filterMap = filterMap$1;
/**
* Returns the first element that satisfies the effectful predicate.
*
* **Details**
*
* This function processes a collection of elements and applies an effectful
* predicate to each element.
*
* The predicate is a function that takes an element and its index in the
* collection, and it returns an effect that evaluates to a boolean.
*
* The function stops as soon as it finds the first element for which the
* predicate returns `true` and returns that element wrapped in an `Option`.
*
* If no element satisfies the predicate, the result will be `None`.
*
* **When to Use**
*
* This function allows you to efficiently find an element that meets a specific
* condition, even when the evaluation involves effects like asynchronous
* operations or side effects.
*
* **Example**
*
* ```ts
* import { Effect } from "effect"
*
* const numbers = [1, 2, 3, 4, 5]
* const predicate = (n: number, i: number) => Effect.succeed(n > 3)
*
* const program = Effect.gen(function*() {
*   const result = yield* Effect.findFirst(numbers, predicate)
*   console.log(result)
* })
*
* Effect.runFork(program)
* // Output: { _id: 'Option', _tag: 'Some', value: 4 }
* ```
*
* @since 2.0.0
* @category Collecting
*/
const findFirst = findFirst$3;
/**
* Executes an effectful operation for each element in an `Iterable`.
*
* **Details**
*
* This function applies a provided operation to each element in the iterable,
* producing a new effect that returns an array of results.
*
* If any effect fails, the iteration stops immediately (short-circuiting), and
* the error is propagated.
*
* **Concurrency**
*
* The `concurrency` option controls how many operations are performed
* concurrently. By default, the operations are performed sequentially.
*
* **Discarding Results**
*
* If the `discard` option is set to `true`, the intermediate results are not
* collected, and the final result of the operation is `void`.
*
* **Example** (Applying Effects to Iterable Elements)
*
* ```ts
* import { Effect, Console } from "effect"
*
* const result = Effect.forEach([1, 2, 3, 4, 5], (n, index) =>
*   Console.log(`Currently at index ${index}`).pipe(Effect.as(n * 2))
* )
*
* Effect.runPromise(result).then(console.log)
* // Output:
* // Currently at index 0
* // Currently at index 1
* // Currently at index 2
* // Currently at index 3
* // Currently at index 4
* // [ 2, 4, 6, 8, 10 ]
* ```
*
* **Example** (Discarding Results)
*
* ```ts
* import { Effect, Console } from "effect"
*
* // Apply effects but discard the results
* const result = Effect.forEach(
*   [1, 2, 3, 4, 5],
*   (n, index) =>
*     Console.log(`Currently at index ${index}`).pipe(Effect.as(n * 2)),
*   { discard: true }
* )
*
* Effect.runPromise(result).then(console.log)
* // Output:
* // Currently at index 0
* // Currently at index 1
* // Currently at index 2
* // Currently at index 3
* // Currently at index 4
* // undefined
* ```
*
* @see {@link all} for combining multiple effects into one.
*
* @since 2.0.0
* @category Looping
*/
const forEach = forEach$1;
/**
* Returns the first element of the iterable if the collection is non-empty, or
* fails with the error `NoSuchElementException` if the collection is empty.
*
* **When to Use**
*
* This function is useful when you need to retrieve the first item from a
* collection and want to handle the case where the collection might be empty
* without causing an unhandled exception.
*
* **Example**
*
* ```ts
* import { Effect } from "effect"
*
* // Simulate an async operation
* const fetchNumbers = Effect.succeed([1, 2, 3]).pipe(Effect.delay("100 millis"))
*
* const program = Effect.gen(function*() {
*   const firstElement = yield* Effect.head(fetchNumbers)
*   console.log(firstElement)
* })
*
* Effect.runFork(program)
* // Output: 1
* ```
*
* @since 2.0.0
* @category Collecting
*/
const head = head$1;
/**
* Merges an `Iterable<Effect<A, E, R>>` to a single effect.
*
* **Details**
*
* This function takes an iterable of effects and combines them into a single
* effect. It does this by iterating over each effect in the collection and
* applying a function that accumulates results into a "zero" value, which
* starts with an initial value and is updated with each effect's success.
*
* The provided function `f` is called for each element in the iterable,
* allowing you to specify how to combine the results.
*
* **Options**
*
* The function also allows you to customize how the effects are handled by
* specifying options such as concurrency, batching, and how finalizers behave.
* These options provide flexibility in running the effects concurrently or
* adjusting other execution details.
*
* **Example**
*
* ```ts
* import { Effect } from "effect"
*
* const numbers = [Effect.succeed(1), Effect.succeed(2), Effect.succeed(3)]
* const add = (sum: number, value: number, i: number) => sum + value
* const zero = 0
*
* const program = Effect.gen(function*() {
*   const total = yield* Effect.mergeAll(numbers, zero, add)
*   console.log(total)
* })
*
* Effect.runFork(program)
* // Output: 6
* ```
*
* @since 2.0.0
* @category Collecting
*/
const mergeAll = mergeAll$2;
/**
* Processes an iterable and applies an effectful function to each element,
* categorizing the results into successes and failures.
*
* **Details**
*
* This function processes each element in the provided iterable by applying an
* effectful function to it. The results are then categorized into two separate
* lists: one for failures and another for successes. This separation allows you
* to handle the two categories differently. Failures are collected in a list
* without interrupting the processing of the remaining elements, so the
* operation continues even if some elements fail. This is particularly useful
* when you need to handle both successful and failed results separately,
* without stopping the entire process on encountering a failure.
*
* **When to Use**
*
* Use this function when you want to process a collection of items and handle
* errors or failures without interrupting the processing of other items. It's
* useful when you need to distinguish between successful and failed results and
* process them separately, for example, when logging errors while continuing to
* work with valid data. The function ensures that failures are captured, while
* successes are processed normally.
*
* **Example**
*
* ```ts
* import { Effect } from "effect"
*
* //      ┌─── Effect<[string[], number[]], never, never>
* //      ▼
* const program = Effect.partition([0, 1, 2, 3, 4], (n) => {
*   if (n % 2 === 0) {
*     return Effect.succeed(n)
*   } else {
*     return Effect.fail(`${n} is not even`)
*   }
* })
*
* Effect.runPromise(program).then(console.log, console.error)
* // Output:
* // [ [ '1 is not even', '3 is not even' ], [ 0, 2, 4 ] ]
* ```
*
* @see {@link validateAll} for a function that either collects all failures or all successes.
* @see {@link validateFirst} for a function that stops at the first success.
*
* @since 2.0.0
* @category Error Accumulation
*/
const partition = partition$1;
/**
* Reduces an `Iterable<A>` using an effectual function `f`, working
* sequentially from left to right.
*
* **Details**
*
* This function takes an iterable and applies a function `f` to each element in
* the iterable. The function works sequentially, starting with an initial value
* `zero` and then combining it with each element in the collection. The
* provided function `f` is called for each element in the iterable, allowing
* you to accumulate a result based on the current value and the element being
* processed.
*
* **When to Use**
*
* The function is often used for operations like summing a collection of
* numbers or combining results from multiple tasks. It ensures that operations
* are performed one after the other, maintaining the order of the elements.
*
* **Example**
*
* ```ts
* import { Console, Effect } from "effect"
*
* const processOrder = (id: number) =>
*   Effect.succeed({ id, price: 100 * id })
*     .pipe(Effect.tap(() => Console.log(`Order ${id} processed`)), Effect.delay(500 - (id * 100)))
*
* const program = Effect.reduce(
*   [1, 2, 3, 4],
*   0,
*   (acc, id, i) =>
*     processOrder(id)
*       .pipe(Effect.map((order) => acc + order.price))
* )
*
* Effect.runPromise(program).then(console.log)
* // Output:
* // Order 1 processed
* // Order 2 processed
* // Order 3 processed
* // Order 4 processed
* // 1000
* ```
*
* @see {@link reduceWhile} for a similar function that stops the process based on a predicate.
* @see {@link reduceRight} for a similar function that works from right to left.
*
* @since 2.0.0
* @category Collecting
*/
const reduce = reduce$3;
/**
* Reduces an `Iterable<A>` using an effectual function `body`, working
* sequentially from left to right, stopping the process early when the
* predicate `while` is not satisfied.
*
* **Details**
*
* This function processes a collection of elements, applying a function `body`
* to reduce them to a single value, starting from the first element. It checks
* the value of the accumulator against a predicate (`while`). If at any point
* the predicate returns `false`, the reduction stops, and the accumulated
* result is returned.
*
* **When to Use**
*
* Use this function when you need to reduce a collection of elements, but only
* continue the process as long as a certain condition holds true. For example,
* if you want to sum values in a list but stop as soon as the sum exceeds a
* certain threshold, you can use this function.
*
* **Example**
*
* ```ts
* import { Console, Effect } from "effect"
*
* const processOrder = (id: number) =>
*   Effect.succeed({ id, price: 100 * id })
*     .pipe(Effect.tap(() => Console.log(`Order ${id} processed`)), Effect.delay(500 - (id * 100)))
*
* const program = Effect.reduceWhile(
*   [1, 2, 3, 4],
*   0,
*   {
*     body: (acc, id, i) =>
*       processOrder(id)
*         .pipe(Effect.map((order) => acc + order.price)),
*     while: (acc) => acc < 500
*   }
* )
*
* Effect.runPromise(program).then(console.log)
* // Output:
* // Order 1 processed
* // Order 2 processed
* // Order 3 processed
* // 600
* ```
*
* @since 2.0.0
* @category Collecting
*/
const reduceWhile = reduceWhile$1;
/**
* Reduces an `Iterable<A>` using an effectual function `f`, working
* sequentially from right to left.
*
* **Details**
*
* This function takes an iterable and applies a function `f` to each element in
* the iterable. The function works sequentially, starting with an initial value
* `zero` and then combining it with each element in the collection. The
* provided function `f` is called for each element in the iterable, allowing
* you to accumulate a result based on the current value and the element being
* processed.
*
* **When to Use**
*
* The function is often used for operations like summing a collection of
* numbers or combining results from multiple tasks. It ensures that operations
* are performed one after the other, maintaining the order of the elements.
*
* **Example**
*
* ```ts
* import { Console, Effect } from "effect"
*
* const processOrder = (id: number) =>
*   Effect.succeed({ id, price: 100 * id })
*     .pipe(Effect.tap(() => Console.log(`Order ${id} processed`)), Effect.delay(500 - (id * 100)))
*
* const program = Effect.reduceRight(
*   [1, 2, 3, 4],
*   0,
*   (id, acc, i) =>
*     processOrder(id)
*       .pipe(Effect.map((order) => acc + order.price))
* )
*
* Effect.runPromise(program).then(console.log)
* // Output:
* // Order 4 processed
* // Order 3 processed
* // Order 2 processed
* // Order 1 processed
* // 1000
* ```
*
* @see {@link reduce} for a similar function that works from left to right.
*
* @since 2.0.0
* @category Collecting
*/
const reduceRight = reduceRight$1;
/**
* Reduces an `Iterable<Effect<A, E, R>>` to a single effect.
*
* **Details**
*
* This function processes a collection of effects and combines them into one
* single effect. It starts with an initial effect (`zero`) and applies a
* function `f` to each element in the collection.
*
* **Options**
*
* The function also allows you to customize how the effects are handled by
* specifying options such as concurrency, batching, and how finalizers behave.
* These options provide flexibility in running the effects concurrently or
* adjusting other execution details.
*
* **Example**
*
* ```ts
* import { Console, Effect } from "effect"
*
* const processOrder = (id: number) =>
*   Effect.succeed({ id, price: 100 * id })
*     .pipe(Effect.tap(() => Console.log(`Order ${id} processed`)), Effect.delay(500 - (id * 100)))
*
* const program = Effect.reduceEffect(
*   [processOrder(1), processOrder(2), processOrder(3), processOrder(4)],
*   Effect.succeed(0),
*   (acc, order, i) => acc + order.price
* )
*
* Effect.runPromise(program).then(console.log)
* // Output:
* // Order 1 processed
* // Order 2 processed
* // Order 3 processed
* // Order 4 processed
* // 1000
* ```
*
* @since 2.0.0
* @category Collecting
*/
const reduceEffect = reduceEffect$1;
/**
* Replicates the given effect `n` times.
*
* **Details**
*
* This function takes an effect and replicates it a specified number of times
* (`n`). The result is an array of `n` effects, each of which is identical to
* the original effect.
*
* **Example**
*
* ```ts
* import { Console, Effect } from "effect"
*
* const task = Effect.succeed("Hello, World!").pipe(
*   Effect.tap(Console.log)
* )
*
* const program = Effect.gen(function*() {
*   // Replicate the task 3 times
*   const tasks = Effect.replicate(task, 3)
*   for (const t of tasks) {
*     // Run each task
*     yield* t
*   }
* })
*
* Effect.runFork(program)
* // Output:
* // Hello, World!
* // Hello, World!
* // Hello, World!
* ```
*
* @since 2.0.0
*/
const replicate = replicate$1;
/**
* Performs this effect the specified number of times and collects the results.
*
* **Details**
*
* This function repeats an effect multiple times and collects the results into
* an array. You specify how many times to execute the effect, and it runs that
* many times, either in sequence or concurrently depending on the provided
* options.
*
* **Options**
*
* If the `discard` option is set to `true`, the intermediate results are not
* collected, and the final result of the operation is `void`.
*
* The function also allows you to customize how the effects are handled by
* specifying options such as concurrency, batching, and how finalizers behave.
* These options provide flexibility in running the effects concurrently or
* adjusting other execution details.
*
* **Example**
*
* ```ts
* import { Console, Effect } from "effect"
*
* let counter = 0
*
* const task = Effect.sync(() => ++counter).pipe(
*   Effect.tap(() => Console.log(`Task completed`))
* )
*
* const program = Effect.gen(function*() {
*   // Replicate the task 3 times and collect the results
*   const results = yield* Effect.replicateEffect(task, 3)
*   yield* Console.log(`Results: ${results.join(", ")}`)
* })
*
* Effect.runFork(program)
* // Output:
* // Task completed
* // Task completed
* // Task completed
* // Results: 1, 2, 3
* ```
*
* @since 2.0.0
* @category Collecting
*/
const replicateEffect = replicateEffect$1;
/**
* Applies an effectful operation to each element in a collection while
* collecting both successes and failures.
*
* **Details**
*
* This function allows you to apply an effectful operation to every item in a
* collection.
*
* Unlike {@link forEach}, which would stop at the first error, this function
* continues processing all elements, accumulating both successes and failures.
*
* **When to Use**
*
* Use this function when you want to process every item in a collection, even
* if some items fail. This is particularly useful when you need to perform
* operations on all elements without halting due to an error.
*
* Keep in mind that if there are any failures, **all successes will be lost**,
* so this function is not suitable when you need to keep the successful results
* in case of errors.
*
* **Example**
*
* ```ts
* import { Effect, Console } from "effect"
*
* //      ┌─── Effect<number[], [string, ...string[]], never>
* //      ▼
* const program = Effect.validateAll([1, 2, 3, 4, 5], (n) => {
*   if (n < 4) {
*     return Console.log(`item ${n}`).pipe(Effect.as(n))
*   } else {
*     return Effect.fail(`${n} is not less that 4`)
*   }
* })
*
* Effect.runPromiseExit(program).then(console.log)
* // Output:
* // item 1
* // item 2
* // item 3
* // {
* //   _id: 'Exit',
* //   _tag: 'Failure',
* //   cause: {
* //     _id: 'Cause',
* //     _tag: 'Fail',
* //     failure: [ '4 is not less that 4', '5 is not less that 4' ]
* //   }
* // }
* ```
*
* @see {@link forEach} for a similar function that stops at the first error.
* @see {@link partition} when you need to separate successes and failures
* instead of losing successes with errors.
*
* @since 2.0.0
* @category Error Accumulation
*/
const validateAll = validateAll$1;
/**
* This function is similar to {@link validateAll} but with a key difference: it
* returns the first successful result or all errors if none of the operations
* succeed.
*
* **Details**
*
* This function processes a collection of elements and applies an effectful
* operation to each. Unlike {@link validateAll}, which accumulates both
* successes and failures, `Effect.validateFirst` stops and returns the first
* success it encounters. If no success occurs, it returns all accumulated
* errors. This can be useful when you are interested in the first successful
* result and want to avoid processing further once a valid result is found.
*
* **Example**
*
* ```ts
* import { Effect, Console } from "effect"
*
* //      ┌─── Effect<number, string[], never>
* //      ▼
* const program = Effect.validateFirst([1, 2, 3, 4, 5], (n) => {
*   if (n < 4) {
*     return Effect.fail(`${n} is not less that 4`)
*   } else {
*     return Console.log(`item ${n}`).pipe(Effect.as(n))
*   }
* })
*
* Effect.runPromise(program).then(console.log, console.error)
* // Output:
* // item 4
* // 4
* ```
*
* @see {@link validateAll} for a similar function that accumulates all results.
* @see {@link firstSuccessOf} for a similar function that processes multiple
* effects and returns the first successful one or the last error.
*
* @since 2.0.0
* @category Error Accumulation
*/
const validateFirst = validateFirst$1;
/**
* Creates an `Effect` from a callback-based asynchronous function.
*
* **Details**
*
* The `resume` function:
* - Must be called exactly once. Any additional calls will be ignored.
* - Can return an optional `Effect` that will be run if the `Fiber` executing
*   this `Effect` is interrupted. This can be useful in scenarios where you
*   need to handle resource cleanup if the operation is interrupted.
* - Can receive an `AbortSignal` to handle interruption if needed.
*
* The `FiberId` of the fiber that may complete the async callback may also be
* specified using the `blockingOn` argument. This is called the "blocking
* fiber" because it suspends the fiber executing the `async` effect (i.e.
* semantically blocks the fiber from making progress). Specifying this fiber id
* in cases where it is known will improve diagnostics, but not affect the
* behavior of the returned effect.
*
* **When to Use**
*
* Use `Effect.async` when dealing with APIs that use callback-style instead of
* `async/await` or `Promise`.
*
* **Example** (Wrapping a Callback API)
*
* ```ts
* import { Effect } from "effect"
* import * as NodeFS from "node:fs"
*
* const readFile = (filename: string) =>
*   Effect.async<Buffer, Error>((resume) => {
*     NodeFS.readFile(filename, (error, data) => {
*       if (error) {
*         // Resume with a failed Effect if an error occurs
*         resume(Effect.fail(error))
*       } else {
*         // Resume with a succeeded Effect if successful
*         resume(Effect.succeed(data))
*       }
*     })
*   })
*
* //      ┌─── Effect<Buffer, Error, never>
* //      ▼
* const program = readFile("example.txt")
* ```
*
* **Example** (Handling Interruption with Cleanup)
*
* ```ts
* import { Effect, Fiber } from "effect"
* import * as NodeFS from "node:fs"
*
* // Simulates a long-running operation to write to a file
* const writeFileWithCleanup = (filename: string, data: string) =>
*   Effect.async<void, Error>((resume) => {
*     const writeStream = NodeFS.createWriteStream(filename)
*
*     // Start writing data to the file
*     writeStream.write(data)
*
*     // When the stream is finished, resume with success
*     writeStream.on("finish", () => resume(Effect.void))
*
*     // In case of an error during writing, resume with failure
*     writeStream.on("error", (err) => resume(Effect.fail(err)))
*
*     // Handle interruption by returning a cleanup effect
*     return Effect.sync(() => {
*       console.log(`Cleaning up ${filename}`)
*       NodeFS.unlinkSync(filename)
*     })
*   })
*
* const program = Effect.gen(function* () {
*   const fiber = yield* Effect.fork(
*     writeFileWithCleanup("example.txt", "Some long data...")
*   )
*   // Simulate interrupting the fiber after 1 second
*   yield* Effect.sleep("1 second")
*   yield* Fiber.interrupt(fiber) // This will trigger the cleanup
* })
*
* // Run the program
* Effect.runPromise(program)
* // Output:
* // Cleaning up example.txt
* ```
*
* **Example** (Handling Interruption with AbortSignal)
*
* ```ts
* import { Effect, Fiber } from "effect"
*
* // A task that supports interruption using AbortSignal
* const interruptibleTask = Effect.async<void, Error>((resume, signal) => {
*   // Handle interruption
*   signal.addEventListener("abort", () => {
*     console.log("Abort signal received")
*     clearTimeout(timeoutId)
*   })
*
*   // Simulate a long-running task
*   const timeoutId = setTimeout(() => {
*     console.log("Operation completed")
*     resume(Effect.void)
*   }, 2000)
* })
*
* const program = Effect.gen(function* () {
*   const fiber = yield* Effect.fork(interruptibleTask)
*   // Simulate interrupting the fiber after 1 second
*   yield* Effect.sleep("1 second")
*   yield* Fiber.interrupt(fiber)
* })
*
* // Run the program
* Effect.runPromise(program)
* // Output:
* // Abort signal received
* ```
*
* @since 2.0.0
* @category Creating Effects
*/
const async = async_;
/**
* A variant of {@link async} where the registration function may return an `Effect`.
*
* @since 2.0.0
* @category Creating Effects
*/
const asyncEffect = asyncEffect$1;
/**
* Low level constructor that enables for custom stack tracing cutpoints.
*
* It is meant to be called with a bag of instructions that become available in
* the "this" of the effect.
*
* **Example**
*
* ```ts
* import { Effect } from "effect"
*
* const throwingFunction = () => { throw new Error() }
* const blowUp = Effect.custom(throwingFunction, function() {
*   return Effect.succeed(this.effect_instruction_i0())
* })
* ```
*
* @since 2.0.0
* @category Creating Effects
*/
const custom = custom$1;
/**
* @since 2.0.0
* @category Creating Effects
*/
const withFiberRuntime = withFiberRuntime$1;
/**
* Creates an `Effect` that represents a recoverable error.
*
* **When to Use**
*
* Use this function to explicitly signal an error in an `Effect`. The error
* will keep propagating unless it is handled. You can handle the error with
* functions like {@link catchAll} or {@link catchTag}.
*
* **Example** (Creating a Failed Effect)
*
* ```ts
* import { Effect } from "effect"
*
* //      ┌─── Effect<never, Error, never>
* //      ▼
* const failure = Effect.fail(
*   new Error("Operation failed due to network error")
* )
* ```
*
* @see {@link succeed} to create an effect that represents a successful value.
*
* @since 2.0.0
* @category Creating Effects
*/
const fail$1 = fail$8;
/**
* Creates an `Effect` that fails with the specified error, evaluated lazily.
*
* @since 2.0.0
* @category Creating Effects
*/
const failSync = failSync$2;
/**
* Creates an `Effect` that fails with the specified `Cause`.
*
* @since 2.0.0
* @category Creating Effects
*/
const failCause = failCause$8;
/**
* Creates an `Effect` that fails with the specified `Cause`, evaluated lazily.
*
* @since 2.0.0
* @category Creating Effects
*/
const failCauseSync = failCauseSync$2;
/**
* Creates an effect that terminates a fiber with a specified error.
*
* **Details**
*
* This function is used to signal a defect, which represents a critical and
* unexpected error in the code. When invoked, it produces an effect that does
* not handle the error and instead terminates the fiber.
*
* The error channel of the resulting effect is of type `never`, indicating that
* it cannot recover from this failure.
*
* **When to Use**
*
* Use this function when encountering unexpected conditions in your code that
* should not be handled as regular errors but instead represent unrecoverable
* defects.
*
* **Example** (Terminating on Division by Zero with a Specified Error)
*
* ```ts
* import { Effect } from "effect"
*
* const divide = (a: number, b: number) =>
*   b === 0
*     ? Effect.die(new Error("Cannot divide by zero"))
*     : Effect.succeed(a / b)
*
* //      ┌─── Effect<number, never, never>
* //      ▼
* const program = divide(1, 0)
*
* Effect.runPromise(program).catch(console.error)
* // Output:
* // (FiberFailure) Error: Cannot divide by zero
* //   ...stack trace...
* ```
*
* @see {@link dieSync} for a variant that throws a specified error, evaluated
* lazily.
* @see {@link dieMessage} for a variant that throws a `RuntimeException` with a
* message.
*
* @since 2.0.0
* @category Creating Effects
*/
const die = die$3;
/**
* Creates an effect that terminates a fiber with a `RuntimeException`
* containing the specified message.
*
* **Details**
*
* This function is used to signal a defect, representing a critical and
* unexpected error in the code. When invoked, it produces an effect that
* terminates the fiber with a `RuntimeException` carrying the given message.
*
* The resulting effect has an error channel of type `never`, indicating it does
* not handle or recover from the error.
*
* **When to Use**
*
* Use this function when you want to terminate a fiber due to an unrecoverable
* defect and include a clear explanation in the message.
*
* **Example** (Terminating on Division by Zero with a Specified Message)
*
* ```ts
* import { Effect } from "effect"
*
* const divide = (a: number, b: number) =>
*   b === 0
*     ? Effect.dieMessage("Cannot divide by zero")
*     : Effect.succeed(a / b)
*
* //      ┌─── Effect<number, never, never>
* //      ▼
* const program = divide(1, 0)
*
* Effect.runPromise(program).catch(console.error)
* // Output:
* // (FiberFailure) RuntimeException: Cannot divide by zero
* //   ...stack trace...
* ```
*
* @see {@link die} for a variant that throws a specified error.
* @see {@link dieSync} for a variant that throws a specified error, evaluated
* lazily.
*
* @since 2.0.0
* @category Creating Effects
*/
const dieMessage = dieMessage$1;
/**
* Creates an effect that dies with the specified error, evaluated lazily.
*
* **Details**
*
* This function allows you to create an effect that will terminate with a fatal error.
* The error is provided as a lazy argument, meaning it will only be evaluated when the effect runs.
*
* @see {@link die} if you don't need to evaluate the error lazily.
*
* @since 2.0.0
* @category Creating Effects
*/
const dieSync = dieSync$2;
/**
* Provides a way to write effectful code using generator functions, simplifying
* control flow and error handling.
*
* **When to Use**
*
* `Effect.gen` allows you to write code that looks and behaves like synchronous
* code, but it can handle asynchronous tasks, errors, and complex control flow
* (like loops and conditions). It helps make asynchronous code more readable
* and easier to manage.
*
* The generator functions work similarly to `async/await` but with more
* explicit control over the execution of effects. You can `yield*` values from
* effects and return the final result at the end.
*
* **Example**
*
* ```ts
* import { Effect } from "effect"
*
* const addServiceCharge = (amount: number) => amount + 1
*
* const applyDiscount = (
*   total: number,
*   discountRate: number
* ): Effect.Effect<number, Error> =>
*   discountRate === 0
*     ? Effect.fail(new Error("Discount rate cannot be zero"))
*     : Effect.succeed(total - (total * discountRate) / 100)
*
* const fetchTransactionAmount = Effect.promise(() => Promise.resolve(100))
*
* const fetchDiscountRate = Effect.promise(() => Promise.resolve(5))
*
* export const program = Effect.gen(function* () {
*   const transactionAmount = yield* fetchTransactionAmount
*   const discountRate = yield* fetchDiscountRate
*   const discountedAmount = yield* applyDiscount(
*     transactionAmount,
*     discountRate
*   )
*   const finalAmount = addServiceCharge(discountedAmount)
*   return `Final amount to charge: ${finalAmount}`
* })
* ```
*
* @since 2.0.0
* @category Creating Effects
*/
const gen = gen$1;
/**
* An effect that that runs indefinitely and never produces any result. The
* moral equivalent of `while(true) {}`, only without the wasted CPU cycles.
*
* **When to Use**
*
* It could be useful for long-running background tasks or to simulate waiting
* behavior without actually consuming resources. This effect is ideal for cases
* where you want to keep the program alive or in a certain state without
* performing any active work.
*
* @since 2.0.0
* @category Creating Effects
*/
const never = never$3;
/**
* Ensures the `Option` is `None`, returning `void`. Otherwise, raises a
* `NoSuchElementException`.
*
* **Details**
*
* This function checks if the provided `Option` is `None`. If it is, it returns
* an effect that produces no result (i.e., `void`). If the `Option` is not
* `None` (i.e., it contains a value), the function will raise a
* `NoSuchElementException` error.
*
* **When to Use**
*
* This is useful when you want to ensure that a certain value is absent (i.e.,
* `None`) before continuing execution, and to handle cases where the value is
* unexpectedly present.
*
* @since 2.0.0
*/
const none = none$4;
/**
* Creates an `Effect` that represents an asynchronous computation guaranteed to
* succeed.
*
* **Details**
*
* The provided function (`thunk`) returns a `Promise` that should never reject; if it does, the error
* will be treated as a "defect".
*
* This defect is not a standard error but indicates a flaw in the logic that
* was expected to be error-free. You can think of it similar to an unexpected
* crash in the program, which can be further managed or logged using tools like
* {@link catchAllDefect}.
*
* **Interruptions**
*
* An optional `AbortSignal` can be provided to allow for interruption of the
* wrapped `Promise` API.
*
* **When to Use**
*
* Use this function when you are sure the operation will not reject.
*
* **Example** (Delayed Message)
*
* ```ts
* import { Effect } from "effect"
*
* const delay = (message: string) =>
*   Effect.promise<string>(
*     () =>
*       new Promise((resolve) => {
*         setTimeout(() => {
*           resolve(message)
*         }, 2000)
*       })
*   )
*
* //      ┌─── Effect<string, never, never>
* //      ▼
* const program = delay("Async operation completed successfully!")
* ```
*
* @see {@link tryPromise} for a version that can handle failures.
*
* @since 2.0.0
* @category Creating Effects
*/
const promise = promise$1;
/**
* Creates an `Effect` that always succeeds with a given value.
*
* **When to Use**
*
* Use this function when you need an effect that completes successfully with a
* specific value without any errors or external dependencies.
*
* **Example** (Creating a Successful Effect)
*
* ```ts
* import { Effect } from "effect"
*
* // Creating an effect that represents a successful scenario
* //
* //      ┌─── Effect<number, never, never>
* //      ▼
* const success = Effect.succeed(42)
* ```
*
* @see {@link fail} to create an effect that represents a failure.
*
* @since 2.0.0
* @category Creating Effects
*/
const succeed$1 = succeed$9;
/**
* Returns an effect which succeeds with `None`.
*
* **When to Use**
*
* Use this function when you need to represent the absence of a value in your
* code, especially when working with optional data. This can be helpful when
* you want to indicate that no result is available without throwing an error or
* performing additional logic.
*
* @see {@link succeedSome} to create an effect that succeeds with a `Some` value.
*
* @since 2.0.0
* @category Creating Effects
*/
const succeedNone = succeedNone$1;
/**
* Returns an effect which succeeds with the value wrapped in a `Some`.
*
* @see {@link succeedNone} for a similar function that returns `None` when the value is absent.
*
* @since 2.0.0
* @category Creating Effects
*/
const succeedSome = succeedSome$1;
/**
* Delays the creation of an `Effect` until it is actually needed.
*
* **Details**
*
* The `Effect.suspend` function takes a thunk that represents the effect and
* wraps it in a suspended effect. This means the effect will not be created
* until it is explicitly needed, which is helpful in various scenarios:
* - **Lazy Evaluation**: Helps optimize performance by deferring computations,
*   especially when the effect might not be needed, or when its computation is
*   expensive. This also ensures that any side effects or scoped captures are
*   re-executed on each invocation.
* - **Handling Circular Dependencies**: Useful in managing circular
*   dependencies, such as recursive functions that need to avoid eager
*   evaluation to prevent stack overflow.
* - **Unifying Return Types**: Can help TypeScript unify return types in
*   situations where multiple branches of logic return different effects,
*   simplifying type inference.
*
* **When to Use**
*
* Use this function when you need to defer the evaluation of an effect until it
* is required. This is particularly useful for optimizing expensive
* computations, managing circular dependencies, or resolving type inference
* issues.
*
* **Example** (Lazy Evaluation with Side Effects)
*
* ```ts
* import { Effect } from "effect"
*
* let i = 0
*
* const bad = Effect.succeed(i++)
*
* const good = Effect.suspend(() => Effect.succeed(i++))
*
* console.log(Effect.runSync(bad)) // Output: 0
* console.log(Effect.runSync(bad)) // Output: 0
*
* console.log(Effect.runSync(good)) // Output: 1
* console.log(Effect.runSync(good)) // Output: 2
* ```
*
* **Example** (Recursive Fibonacci)
*
* ```ts
* import { Effect } from "effect"
*
* const blowsUp = (n: number): Effect.Effect<number> =>
*   n < 2
*     ? Effect.succeed(1)
*     : Effect.zipWith(blowsUp(n - 1), blowsUp(n - 2), (a, b) => a + b)
*
* console.log(Effect.runSync(blowsUp(32)))
* // crash: JavaScript heap out of memory
*
* const allGood = (n: number): Effect.Effect<number> =>
*   n < 2
*     ? Effect.succeed(1)
*     : Effect.zipWith(
*         Effect.suspend(() => allGood(n - 1)),
*         Effect.suspend(() => allGood(n - 2)),
*         (a, b) => a + b
*       )
*
* console.log(Effect.runSync(allGood(32)))
* // Output: 3524578
* ```
*
* **Example** (Using Effect.suspend to Help TypeScript Infer Types)
*
* ```ts
* import { Effect } from "effect"
*
* //   Without suspend, TypeScript may struggle with type inference.
* //   Inferred type:
* //     (a: number, b: number) =>
* //       Effect<never, Error, never> | Effect<number, never, never>
* const withoutSuspend = (a: number, b: number) =>
*   b === 0
*     ? Effect.fail(new Error("Cannot divide by zero"))
*     : Effect.succeed(a / b)
*
* //   Using suspend to unify return types.
* //   Inferred type:
* //     (a: number, b: number) => Effect<number, Error, never>
* const withSuspend = (a: number, b: number) =>
*   Effect.suspend(() =>
*     b === 0
*       ? Effect.fail(new Error("Cannot divide by zero"))
*       : Effect.succeed(a / b)
*   )
* ```
*
* @since 2.0.0
* @category Creating Effects
*/
const suspend = suspend$3;
/**
* Creates an `Effect` that represents a synchronous side-effectful computation.
*
* **Details**
*
* The provided function (`thunk`) must not throw errors; if it does, the error
* will be treated as a "defect".
*
* This defect is not a standard error but indicates a flaw in the logic that
* was expected to be error-free. You can think of it similar to an unexpected
* crash in the program, which can be further managed or logged using tools like
* {@link catchAllDefect}.
*
* **When to Use**
*
* Use this function when you are sure the operation will not fail.
*
* **Example** (Logging a Message)
*
* ```ts
* import { Effect } from "effect"
*
* const log = (message: string) =>
*   Effect.sync(() => {
*     console.log(message) // side effect
*   })
*
* //      ┌─── Effect<void, never, never>
* //      ▼
* const program = log("Hello, World!")
* ```
*
* @see {@link try_ | try} for a version that can handle failures.
*
* @since 2.0.0
* @category Creating Effects
*/
const sync = sync$3;
const _void = void_$4;
/**
* @since 2.0.0
* @category Creating Effects
*/
const yieldNow = yieldNow$3;
const _catch = _catch$1;
/**
* Handles all errors in an effect by providing a fallback effect.
*
* **Details**
*
* This function catches any errors that may occur during the execution of an
* effect and allows you to handle them by specifying a fallback effect. This
* ensures that the program continues without failing by recovering from errors
* using the provided fallback logic.
*
* **Note**: This function only handles recoverable errors. It will not recover
* from unrecoverable defects.
*
* **Example** (Providing Recovery Logic for Recoverable Errors)
*
* ```ts
* import { Effect, Random } from "effect"
*
* class HttpError {
*   readonly _tag = "HttpError"
* }
*
* class ValidationError {
*   readonly _tag = "ValidationError"
* }
*
* //      ┌─── Effect<string, HttpError | ValidationError, never>
* //      ▼
* const program = Effect.gen(function* () {
*   const n1 = yield* Random.next
*   const n2 = yield* Random.next
*   if (n1 < 0.5) {
*     yield* Effect.fail(new HttpError())
*   }
*   if (n2 < 0.5) {
*     yield* Effect.fail(new ValidationError())
*   }
*   return "some result"
* })
*
* //      ┌─── Effect<string, never, never>
* //      ▼
* const recovered = program.pipe(
*   Effect.catchAll((error) =>
*     Effect.succeed(`Recovering from ${error._tag}`)
*   )
* )
* ```
*
* @see {@link catchAllCause} for a version that can recover from both
* recoverable and unrecoverable errors.
*
* @since 2.0.0
* @category Error handling
*/
const catchAll = catchAll$1;
/**
* Handles both recoverable and unrecoverable errors by providing a recovery
* effect.
*
* **When to Use**
*
* The `catchAllCause` function allows you to handle all errors, including
* unrecoverable defects, by providing a recovery effect. The recovery logic is
* based on the `Cause` of the error, which provides detailed information about
* the failure.
*
* **When to Recover from Defects**
*
* Defects are unexpected errors that typically shouldn't be recovered from, as
* they often indicate serious issues. However, in some cases, such as
* dynamically loaded plugins, controlled recovery might be needed.
*
* **Example** (Recovering from All Errors)
*
* ```ts
* import { Cause, Effect } from "effect"
*
* // Define an effect that may fail with a recoverable or unrecoverable error
* const program = Effect.fail("Something went wrong!")
*
* // Recover from all errors by examining the cause
* const recovered = program.pipe(
*   Effect.catchAllCause((cause) =>
*     Cause.isFailure(cause)
*       ? Effect.succeed("Recovered from a regular error")
*       : Effect.succeed("Recovered from a defect")
*   )
* )
*
* Effect.runPromise(recovered).then(console.log)
* // Output: "Recovered from a regular error"
* ```
*
* @since 2.0.0
* @category Error handling
*/
const catchAllCause = catchAllCause$1;
/**
* Recovers from all defects using a provided recovery function.
*
* **When to Use**
*
* There is no sensible way to recover from defects. This method should be used
* only at the boundary between Effect and an external system, to transmit
* information on a defect for diagnostic or explanatory purposes.
*
* **Details**
*
* `catchAllDefect` allows you to handle defects, which are unexpected errors
* that usually cause the program to terminate. This function lets you recover
* from these defects by providing a function that handles the error. However,
* it does not handle expected errors (like those from {@link fail}) or
* execution interruptions (like those from {@link interrupt}).
*
* **When to Recover from Defects**
*
* Defects are unexpected errors that typically shouldn't be recovered from, as
* they often indicate serious issues. However, in some cases, such as
* dynamically loaded plugins, controlled recovery might be needed.
*
* **Example** (Handling All Defects)
*
* ```ts
* import { Effect, Cause, Console } from "effect"
*
* // Simulating a runtime error
* const task = Effect.dieMessage("Boom!")
*
* const program = Effect.catchAllDefect(task, (defect) => {
*   if (Cause.isRuntimeException(defect)) {
*     return Console.log(
*       `RuntimeException defect caught: ${defect.message}`
*     )
*   }
*   return Console.log("Unknown defect caught.")
* })
*
* // We get an Exit.Success because we caught all defects
* Effect.runPromiseExit(program).then(console.log)
* // Output:
* // RuntimeException defect caught: Boom!
* // {
* //   _id: "Exit",
* //   _tag: "Success",
* //   value: undefined
* // }
* ```
*
* @since 2.0.0
* @category Error handling
*/
const catchAllDefect = catchAllDefect$1;
/**
* Recovers from specific errors based on a predicate.
*
* **When to Use**
*
* `catchIf` works similarly to {@link catchSome}, but it allows you to
* recover from errors by providing a predicate function. If the predicate
* matches the error, the recovery effect is applied. This function doesn't
* alter the error type, so the resulting effect still carries the original
* error type unless a user-defined type guard is used to narrow the type.
*
* **Example** (Catching Specific Errors with a Predicate)
*
* ```ts
* import { Effect, Random } from "effect"
*
* class HttpError {
*   readonly _tag = "HttpError"
* }
*
* class ValidationError {
*   readonly _tag = "ValidationError"
* }
*
* //      ┌─── Effect<string, HttpError | ValidationError, never>
* //      ▼
* const program = Effect.gen(function* () {
*   const n1 = yield* Random.next
*   const n2 = yield* Random.next
*   if (n1 < 0.5) {
*     yield* Effect.fail(new HttpError())
*   }
*   if (n2 < 0.5) {
*     yield* Effect.fail(new ValidationError())
*   }
*   return "some result"
* })
*
* //      ┌─── Effect<string, ValidationError, never>
* //      ▼
* const recovered = program.pipe(
*   Effect.catchIf(
*     // Only handle HttpError errors
*     (error) => error._tag === "HttpError",
*     () => Effect.succeed("Recovering from HttpError")
*   )
* )
* ```
*
* @since 2.0.0
* @category Error handling
*/
const catchIf = catchIf$1;
/**
* Catches and recovers from specific types of errors, allowing you to attempt
* recovery only for certain errors.
*
* **Details**
*
* `catchSome` lets you selectively catch and handle errors of certain
* types by providing a recovery effect for specific errors. If the error
* matches a condition, recovery is attempted; if not, it doesn't affect the
* program. This function doesn't alter the error type, meaning the error type
* remains the same as in the original effect.
*
* **Example** (Handling Specific Errors with Effect.catchSome)
*
* ```ts
* import { Effect, Random, Option } from "effect"
*
* class HttpError {
*   readonly _tag = "HttpError"
* }
*
* class ValidationError {
*   readonly _tag = "ValidationError"
* }
*
* //      ┌─── Effect<string, HttpError | ValidationError, never>
* //      ▼
* const program = Effect.gen(function* () {
*   const n1 = yield* Random.next
*   const n2 = yield* Random.next
*   if (n1 < 0.5) {
*     yield* Effect.fail(new HttpError())
*   }
*   if (n2 < 0.5) {
*     yield* Effect.fail(new ValidationError())
*   }
*   return "some result"
* })
*
* //      ┌─── Effect<string, HttpError | ValidationError, never>
* //      ▼
* const recovered = program.pipe(
*   Effect.catchSome((error) => {
*     // Only handle HttpError errors
*     if (error._tag === "HttpError") {
*       return Option.some(Effect.succeed("Recovering from HttpError"))
*     } else {
*       return Option.none()
*     }
*   })
* )
* ```
*
* @see {@link catchIf} for a version that allows you to recover from errors based on a predicate.
*
* @since 2.0.0
* @category Error handling
*/
const catchSome = catchSome$1;
/**
* Recovers from specific causes using a provided partial function.
*
* @see {@link catchSome} for a version that allows you to recover from errors.
* @see {@link catchSomeDefect} for a version that allows you to recover from defects.
*
* @since 2.0.0
* @category Error handling
*/
const catchSomeCause = catchSomeCause$1;
/**
* Recovers from specific defects using a provided partial function.
*
* **Details**
*
* `catchSomeDefect` allows you to handle specific defects, which are
* unexpected errors that can cause the program to stop. It uses a partial
* function to catch only certain defects and ignores others. The function does
* not handle expected errors (such as those caused by {@link fail}) or
* interruptions in execution (like those caused by {@link interrupt}).
*
* This function provides a way to handle certain types of defects while
* allowing others to propagate and cause failure in the program.
*
* **Note**: There is no sensible way to recover from defects. This method
* should be used only at the boundary between Effect and an external system, to
* transmit information on a defect for diagnostic or explanatory purposes.
*
* **How the Partial Function Works**
*
* The function provided to `catchSomeDefect` acts as a filter and a handler for defects:
* - It receives the defect as an input.
* - If the defect matches a specific condition (e.g., a certain error type), the function returns
*   an `Option.some` containing the recovery logic.
* - If the defect does not match, the function returns `Option.none`, allowing the defect to propagate.
*
* **Example** (Handling Specific Defects)
*
* ```ts
* import { Effect, Cause, Option, Console } from "effect"
*
* // Simulating a runtime error
* const task = Effect.dieMessage("Boom!")
*
* const program = Effect.catchSomeDefect(task, (defect) => {
*   if (Cause.isIllegalArgumentException(defect)) {
*     return Option.some(
*       Console.log(
*         `Caught an IllegalArgumentException defect: ${defect.message}`
*       )
*     )
*   }
*   return Option.none()
* })
*
* // Since we are only catching IllegalArgumentException
* // we will get an Exit.Failure because we simulated a runtime error.
* Effect.runPromiseExit(program).then(console.log)
* // Output:
* // {
* //   _id: 'Exit',
* //   _tag: 'Failure',
* //   cause: {
* //     _id: 'Cause',
* //     _tag: 'Die',
* //     defect: { _tag: 'RuntimeException' }
* //   }
* // }
* ```
*
* @since 2.0.0
* @category Error handling
*/
const catchSomeDefect = catchSomeDefect$1;
/**
* Catches and handles specific errors by their `_tag` field, which is used as a
* discriminator.
*
* **When to Use**
*
* `catchTag` is useful when your errors are tagged with a readonly `_tag` field
* that identifies the error type. You can use this function to handle specific
* error types by matching the `_tag` value. This allows for precise error
* handling, ensuring that only specific errors are caught and handled.
*
* The error type must have a readonly `_tag` field to use `catchTag`. This
* field is used to identify and match errors.
*
* **Example** (Handling Errors by Tag)
*
* ```ts
* import { Effect, Random } from "effect"
*
* class HttpError {
*   readonly _tag = "HttpError"
* }
*
* class ValidationError {
*   readonly _tag = "ValidationError"
* }
*
* //      ┌─── Effect<string, HttpError | ValidationError, never>
* //      ▼
* const program = Effect.gen(function* () {
*   const n1 = yield* Random.next
*   const n2 = yield* Random.next
*   if (n1 < 0.5) {
*     yield* Effect.fail(new HttpError())
*   }
*   if (n2 < 0.5) {
*     yield* Effect.fail(new ValidationError())
*   }
*   return "some result"
* })
*
* //      ┌─── Effect<string, ValidationError, never>
* //      ▼
* const recovered = program.pipe(
*   // Only handle HttpError errors
*   Effect.catchTag("HttpError", (_HttpError) =>
*     Effect.succeed("Recovering from HttpError")
*   )
* )
* ```
*
* @see {@link catchTags} for a version that allows you to handle multiple error
* types at once.
*
* @since 2.0.0
* @category Error handling
*/
const catchTag = catchTag$1;
/**
* Handles multiple errors in a single block of code using their `_tag` field.
*
* **When to Use**
*
* `catchTags` is a convenient way to handle multiple error types at
* once. Instead of using {@link catchTag} multiple times, you can pass an
* object where each key is an error type's `_tag`, and the value is the handler
* for that specific error. This allows you to catch and recover from multiple
* error types in a single call.
*
* The error type must have a readonly `_tag` field to use `catchTag`. This
* field is used to identify and match errors.
*
* **Example** (Handling Multiple Tagged Error Types at Once)
*
* ```ts
* import { Effect, Random } from "effect"
*
* class HttpError {
*   readonly _tag = "HttpError"
* }
*
* class ValidationError {
*   readonly _tag = "ValidationError"
* }
*
* //      ┌─── Effect<string, HttpError | ValidationError, never>
* //      ▼
* const program = Effect.gen(function* () {
*   const n1 = yield* Random.next
*   const n2 = yield* Random.next
*   if (n1 < 0.5) {
*     yield* Effect.fail(new HttpError())
*   }
*   if (n2 < 0.5) {
*     yield* Effect.fail(new ValidationError())
*   }
*   return "some result"
* })
*
* //      ┌─── Effect<string, never, never>
* //      ▼
* const recovered = program.pipe(
*   Effect.catchTags({
*     HttpError: (_HttpError) =>
*       Effect.succeed(`Recovering from HttpError`),
*     ValidationError: (_ValidationError) =>
*       Effect.succeed(`Recovering from ValidationError`)
*   })
* )
* ```
*
* @since 2.0.0
* @category Error handling
*/
const catchTags = catchTags$1;
/**
* Retrieves the cause of a failure in an effect.
*
* **Details**
*
* This function allows you to expose the detailed cause of an effect, which
* includes a more precise representation of failures, such as error messages
* and defects.
*
* **When to Use**
*
* This function is helpful when you need to inspect the cause of a failure in
* an effect, giving you more information than just the error message. It can be
* used to log, handle, or analyze failures in more detail, including
* distinguishing between different types of defects (e.g., runtime exceptions,
* interruptions, etc.).
*
* **Example**
*
* ```ts
* import { Effect, Console } from "effect"
*
* //      ┌─── Effect<number, string, never>
* //      ▼
* const program = Effect.fail("Oh uh!").pipe(Effect.as(2))
*
* //      ┌─── Effect<void, never, never>
* //      ▼
* const recovered = Effect.gen(function* () {
*   const cause = yield* Effect.cause(program)
*   yield* Console.log(cause)
* })
* ```
*
* @since 2.0.0
* @category Error handling
*/
const cause = cause$1;
/**
* Runs an effect repeatedly until it succeeds, ignoring errors.
*
* **Details**
*
* This function takes an effect and runs it repeatedly until the effect
* successfully completes. If the effect fails, it will ignore the error and
* retry the operation. This is useful when you need to perform a task that may
* fail occasionally, but you want to keep trying until it eventually succeeds.
* It works by repeatedly executing the effect until it no longer throws an
* error.
*
* **When to Use**
*
* Use this function when you want to retry an operation multiple times until it
* succeeds. It is helpful in cases where the operation may fail temporarily
* (e.g., a network request), and you want to keep trying without handling or
* worrying about the errors.
*
* **Example**
*
* ```ts
* import { Effect } from "effect"
*
* let counter = 0
*
* const effect = Effect.try(() => {
*   counter++
*   if (counter < 3) {
*     console.log("running effect")
*     throw new Error("error")
*   } else {
*     console.log("effect done")
*     return "some result"
*   }
* })
*
* const program = Effect.eventually(effect)
*
* Effect.runPromise(program).then(console.log)
* // Output:
* // running effect
* // running effect
* // effect done
* // some result
* ```
*
* @since 2.0.0
* @category Error handling
*/
const eventually = eventually$1;
/**
* Discards both the success and failure values of an effect.
*
* **When to Use**
*
* `ignore` allows you to run an effect without caring about its result, whether
* it succeeds or fails. This is useful when you only care about the side
* effects of the effect and do not need to handle or process its outcome.
*
* **Example** (Using Effect.ignore to Discard Values)
*
* ```ts
* import { Effect } from "effect"
*
* //      ┌─── Effect<number, string, never>
* //      ▼
* const task = Effect.fail("Uh oh!").pipe(Effect.as(5))
*
* //      ┌─── Effect<void, never, never>
* //      ▼
* const program = Effect.ignore(task)
* ```
*
* @see {@link ignoreLogged} to log failures while ignoring them.
*
* @since 2.0.0
* @category Error handling
*/
const ignore = ignore$1;
/**
* Ignores the result of an effect but logs any failures.
*
* **Details**
*
* This function takes an effect and returns a new effect that ignores whether
* the original effect succeeds or fails. However, if the effect fails, it will
* log the failure at the Debug level, so you can keep track of any issues that
* arise.
*
* **When to Use**
*
* This is useful in scenarios where you want to continue with your program
* regardless of the result of the effect, but you still want to be aware of
* potential failures that may need attention later.
*
* @since 2.0.0
* @category Error handling
*/
const ignoreLogged = ignoreLogged$1;
/**
* Combines all errors from concurrent operations into a single error.
*
* **Details**
*
* This function is used when you have multiple operations running at the same
* time, and you want to capture all the errors that occur across those
* operations. Instead of handling each error separately, it combines all the
* errors into one unified error.
*
* **When to Use**
*
* When using this function, any errors that occur in the concurrently running
* operations will be grouped together into a single error. This helps simplify
* error handling in cases where you don't need to differentiate between each
* failure, but simply want to know that multiple failures occurred.
*
* **Example**
*
* ```ts
* import { Effect } from "effect"
*
* const fail1 = Effect.fail("Oh uh!")
* const fail2 = Effect.fail("Oh no!")
* const die = Effect.dieMessage("Boom!")
*
* // Run all effects concurrently and capture all errors
* const program = Effect.all([fail1, fail2, die], {
*   concurrency: "unbounded"
* }).pipe(Effect.asVoid, Effect.parallelErrors)
*
* Effect.runPromiseExit(program).then(console.log)
* // Output:
* // {
* //   _id: 'Exit',
* //   _tag: 'Failure',
* //   cause: { _id: 'Cause', _tag: 'Fail', failure: [ 'Oh uh!', 'Oh no!' ] }
* // }
* ```
*
* @since 2.0.0
* @category Error handling
*/
const parallelErrors = parallelErrors$1;
/**
* Transforms an effect to expose detailed error causes.
*
* **Details**
*
* This function enhances an effect by providing detailed information about any
* error, defect, or interruption that may occur during its execution. It
* modifies the error channel of the effect so that it includes a full cause of
* the failure, wrapped in a `Cause<E>` type.
*
* After applying this function, you can use operators like {@link catchAll} and
* {@link catchTags} to handle specific types of errors.
*
* If you no longer need the detailed cause information, you can revert the
* changes using {@link unsandbox} to return to the original error-handling
* behavior.
*
* **Example**
*
* ```ts
* import { Effect, Console } from "effect"
*
* //      ┌─── Effect<string, Error, never>
* //      ▼
* const task = Effect.fail(new Error("Oh uh!")).pipe(
*   Effect.as("primary result")
* )
*
* //      ┌─── Effect<string, Cause<Error>, never>
* //      ▼
* const sandboxed = Effect.sandbox(task)
*
* const program = Effect.catchTags(sandboxed, {
*   Die: (cause) =>
*     Console.log(`Caught a defect: ${cause.defect}`).pipe(
*       Effect.as("fallback result on defect")
*     ),
*   Interrupt: (cause) =>
*     Console.log(`Caught a defect: ${cause.fiberId}`).pipe(
*       Effect.as("fallback result on fiber interruption")
*     ),
*   Fail: (cause) =>
*     Console.log(`Caught a defect: ${cause.error}`).pipe(
*       Effect.as("fallback result on failure")
*     )
* })
*
* // Restore the original error handling with unsandbox
* const main = Effect.unsandbox(program)
*
* Effect.runPromise(main).then(console.log)
* // Output:
* // Caught a defect: Oh uh!
* // fallback result on failure
* ```
*
* @see {@link unsandbox} to restore the original error handling.
*
* @since 2.0.0
* @category Error handling
*/
const sandbox = sandbox$1;
/**
* Retries a failing effect based on a defined retry policy.
*
* **Details**
*
* The `Effect.retry` function takes an effect and a {@link Schedule} policy,
* and will automatically retry the effect if it fails, following the rules of
* the policy.
*
* If the effect ultimately succeeds, the result will be returned.
*
* If the maximum retries are exhausted and the effect still fails, the failure
* is propagated.
*
* **When to Use**
*
* This can be useful when dealing with intermittent failures, such as network
* issues or temporary resource unavailability. By defining a retry policy, you
* can control the number of retries, the delay between them, and when to stop
* retrying.
*
* **Example** (Retrying with a Fixed Delay)
*
* ```ts
* import { Effect, Schedule } from "effect"
*
* let count = 0
*
* // Simulates an effect with possible failures
* const task = Effect.async<string, Error>((resume) => {
*   if (count <= 2) {
*     count++
*     console.log("failure")
*     resume(Effect.fail(new Error()))
*   } else {
*     console.log("success")
*     resume(Effect.succeed("yay!"))
*   }
* })
*
* // Define a repetition policy using a fixed delay between retries
* const policy = Schedule.fixed("100 millis")
*
* const repeated = Effect.retry(task, policy)
*
* Effect.runPromise(repeated).then(console.log)
* // Output:
* // failure
* // failure
* // failure
* // success
* // yay!
* ```
*
* **Example** (Retrying a Task up to 5 times)
*
* ```ts
* import { Effect } from "effect"
*
* let count = 0
*
* // Simulates an effect with possible failures
* const task = Effect.async<string, Error>((resume) => {
*   if (count <= 2) {
*     count++
*     console.log("failure")
*     resume(Effect.fail(new Error()))
*   } else {
*     console.log("success")
*     resume(Effect.succeed("yay!"))
*   }
* })
*
* // Retry the task up to 5 times
* Effect.runPromise(Effect.retry(task, { times: 5 })).then(console.log)
* // Output:
* // failure
* // failure
* // failure
* // success
* ```
*
* **Example** (Retrying Until a Specific Condition is Met)
*
* ```ts
* import { Effect } from "effect"
*
* let count = 0
*
* // Define an effect that simulates varying error on each invocation
* const action = Effect.failSync(() => {
*   console.log(`Action called ${++count} time(s)`)
*   return `Error ${count}`
* })
*
* // Retry the action until a specific condition is met
* const program = Effect.retry(action, {
*   until: (err) => err === "Error 3"
* })
*
* Effect.runPromiseExit(program).then(console.log)
* // Output:
* // Action called 1 time(s)
* // Action called 2 time(s)
* // Action called 3 time(s)
* // {
* //   _id: 'Exit',
* //   _tag: 'Failure',
* //   cause: { _id: 'Cause', _tag: 'Fail', failure: 'Error 3' }
* // }
* ```
*
* @see {@link retryOrElse} for a version that allows you to run a fallback.
* @see {@link repeat} if your retry condition is based on successful outcomes rather than errors.
*
* @since 2.0.0
* @category Error handling
*/
const retry = retry_combined;
/**
* Apply an `ExecutionPlan` to the effect, which allows you to fallback to
* different resources in case of failure.
*
* @since 3.16.0
* @category Error handling
* @experimental
*/
const withExecutionPlan = withExecutionPlan$1;
/**
* Retries a failing effect and runs a fallback effect if retries are exhausted.
*
* **Details**
*
* The `Effect.retryOrElse` function attempts to retry a failing effect multiple
* times according to a defined {@link Schedule} policy.
*
* If the retries are exhausted and the effect still fails, it runs a fallback
* effect instead.
*
* **When to Use**
*
* This function is useful when you want to handle failures gracefully by
* specifying an alternative action after repeated failures.
*
* **Example** (Retrying with Fallback)
*
* ```ts
* import { Effect, Schedule, Console } from "effect"
*
* let count = 0
*
* // Simulates an effect with possible failures
* const task = Effect.async<string, Error>((resume) => {
*   if (count <= 2) {
*     count++
*     console.log("failure")
*     resume(Effect.fail(new Error()))
*   } else {
*     console.log("success")
*     resume(Effect.succeed("yay!"))
*   }
* })
*
* // Retry the task with a delay between retries and a maximum of 2 retries
* const policy = Schedule.addDelay(Schedule.recurs(2), () => "100 millis")
*
* // If all retries fail, run the fallback effect
* const repeated = Effect.retryOrElse(
*   task,
*   policy,
*   // fallback
*   () => Console.log("orElse").pipe(Effect.as("default value"))
* )
*
* Effect.runPromise(repeated).then(console.log)
* // Output:
* // failure
* // failure
* // failure
* // orElse
* // default value
* ```
*
* @see {@link retry} for a version that does not run a fallback effect.
*
* @since 2.0.0
* @category Error handling
*/
const retryOrElse = retryOrElse_Effect;
const try_ = try_$1;
/**
* Returns an effect that maps its success using the specified side-effecting
* `try` function, converting any errors into typed failed effects using the
* `catch` function.
*
* @see {@link tryPromise} for a version that works with asynchronous computations.
*
* @since 2.0.0
* @category Error handling
*/
const tryMap = tryMap$1;
/**
* Returns an effect that maps its success using the specified side-effecting
* `try` function, converting any promise rejections into typed failed effects
* using the `catch` function.
*
* An optional `AbortSignal` can be provided to allow for interruption of the
* wrapped `Promise` API.
*
* @see {@link tryMap} for a version that works with synchronous computations.
*
* @since 2.0.0
* @category Error handling
*/
const tryMapPromise = tryMapPromise$1;
/**
* Creates an `Effect` that represents an asynchronous computation that might
* fail.
*
* **When to Use**
*
* In situations where you need to perform asynchronous operations that might
* fail, such as fetching data from an API, you can use the `tryPromise`
* constructor. This constructor is designed to handle operations that could
* throw exceptions by capturing those exceptions and transforming them into
* manageable errors.
*
* **Error Handling**
*
* There are two ways to handle errors with `tryPromise`:
*
* 1. If you don't provide a `catch` function, the error is caught and the
*    effect fails with an `UnknownException`.
* 2. If you provide a `catch` function, the error is caught and the `catch`
*    function maps it to an error of type `E`.
*
* **Interruptions**
*
* An optional `AbortSignal` can be provided to allow for interruption of the
* wrapped `Promise` API.
*
* **Example** (Fetching a TODO Item)
*
* ```ts
* import { Effect } from "effect"
*
* const getTodo = (id: number) =>
*   // Will catch any errors and propagate them as UnknownException
*   Effect.tryPromise(() =>
*     fetch(`https://jsonplaceholder.typicode.com/todos/${id}`)
*   )
*
* //      ┌─── Effect<Response, UnknownException, never>
* //      ▼
* const program = getTodo(1)
* ```
*
* **Example** (Custom Error Handling)
*
* ```ts
* import { Effect } from "effect"
*
* const getTodo = (id: number) =>
*   Effect.tryPromise({
*     try: () => fetch(`https://jsonplaceholder.typicode.com/todos/${id}`),
*     // remap the error
*     catch: (unknown) => new Error(`something went wrong ${unknown}`)
*   })
*
* //      ┌─── Effect<Response, Error, never>
* //      ▼
* const program = getTodo(1)
* ```
*
* @see {@link promise} if the effectful computation is asynchronous and does not throw errors.
*
* @since 2.0.0
* @category Creating Effects
*/
const tryPromise = tryPromise$1;
/**
* The `unsandbox` function is used to revert an effect that has been
* sandboxed by {@link sandbox}. When you apply `unsandbox`, the
* effect's error channel is restored to its original state, without the
* detailed `Cause<E>` information. This means that any underlying causes of
* errors, defects, or fiber interruptions are no longer exposed in the error
* channel.
*
* This function is useful when you want to remove the detailed error tracking
* provided by `sandbox` and return to the standard error handling for
* your effect. Once unsandboxed, the effect behaves as if `sandbox` was
* never applied.
*
* @see {@link sandbox} to expose the full cause of failures, defects, or interruptions.
*
* @since 2.0.0
* @category Error handling
*/
const unsandbox = unsandbox$1;
/**
* Allows interruption of the current fiber, even in uninterruptible regions.
*
* **Details**
*
* This effect checks whether any other fibers are attempting to interrupt the
* current fiber. If so, it allows the current fiber to perform a
* self-interruption.
*
* **When to Use**
*
* This is useful in situations where you want to allow interruption to happen
* even in regions of the code that are normally uninterruptible.
*
* @since 2.0.0
* @category Interruption
*/
const allowInterrupt = allowInterrupt$1;
/**
* Checks if interruption is allowed and executes a callback accordingly.
*
* **Details**
*
* This function checks the current interrupt status of the running fiber. It
* then calls the provided callback, passing a boolean indicating whether
* interruption is allowed.
*
* **When to Use**
*
* This is useful for handling specific logic based on whether the current
* operation can be interrupted, such as when performing asynchronous operations
* or handling cancellation.
*
* **Example**
*
* ```ts
* import { Console, Effect } from "effect"
*
* const program = Effect.gen(function*() {
*   yield* Effect.checkInterruptible((isInterruptible) => {
*     if (isInterruptible) {
*       return Console.log("You can interrupt this operation.")
*     } else {
*       return Console.log("This operation cannot be interrupted.")
*     }
*   })
* })
*
* Effect.runPromise(program)
* // Output: You can interrupt this operation.
*
* Effect.runPromise(program.pipe(Effect.uninterruptible))
* // Output: This operation cannot be interrupted.
*
* ```
*
*  @since 2.0.0
* @category Interruption
*/
const checkInterruptible = checkInterruptible$1;
/**
* Provides a way to handle timeouts in uninterruptible effects, allowing them
* to continue in the background while the main control flow proceeds with the
* timeout error.
*
* **Details**
*
* The `disconnect` function allows an uninterruptible effect to continue
* running in the background, while enabling the main control flow to
* immediately recognize a timeout condition. This is useful when you want to
* avoid blocking the program due to long-running tasks, especially when those
* tasks do not need to affect the flow of the rest of the program.
*
* Without `disconnect`, an uninterruptible effect will ignore the
* timeout and continue executing until it completes. The timeout error will
* only be assessed after the effect finishes, which can cause delays in
* recognizing a timeout.
*
* With `disconnect`, the uninterruptible effect proceeds in the
* background while the main program flow can immediately handle the timeout
* error or trigger alternative logic. This enables faster timeout handling
* without waiting for the completion of the long-running task.
*
* **Example**
*
* ```ts
* import { Effect } from "effect"
*
* const longRunningTask = Effect.gen(function* () {
*   console.log("Start heavy processing...")
*   yield* Effect.sleep("5 seconds") // Simulate a long process
*   console.log("Heavy processing done.")
*   return "Data processed"
* })
*
* const timedEffect = longRunningTask.pipe(
*   Effect.uninterruptible,
*   // Allows the task to finish in the background if it times out
*   Effect.disconnect,
*   Effect.timeout("1 second")
* )
*
* Effect.runPromiseExit(timedEffect).then(console.log)
* // Output:
* // Start heavy processing...
* // {
* //   _id: 'Exit',
* //   _tag: 'Failure',
* //   cause: {
* //     _id: 'Cause',
* //     _tag: 'Fail',
* //     failure: { _tag: 'TimeoutException' }
* //   }
* // }
* // Heavy processing done.
* ```
*
* @see {@link timeout} for a version that interrupts the effect.
* @see {@link uninterruptible} for creating an uninterruptible effect.
*
* @since 2.0.0
* @category Interruption
*/
const disconnect = disconnect$1;
/**
* Represents an effect that interrupts the current fiber.
*
* **Details**
*
* This effect models the explicit interruption of the fiber in which it runs.
* When executed, it causes the fiber to stop its operation immediately,
* capturing the interruption details such as the fiber's ID and its start time.
* The resulting interruption can be observed in the `Exit` type if the effect
* is run with functions like {@link runPromiseExit}.
*
* **Example**
*
* ```ts
* import { Effect } from "effect"
*
* const program = Effect.gen(function* () {
*   console.log("start")
*   yield* Effect.sleep("2 seconds")
*   yield* Effect.interrupt
*   console.log("done")
*   return "some result"
* })
*
* Effect.runPromiseExit(program).then(console.log)
* // Output:
* // start
* // {
* //   _id: 'Exit',
* //   _tag: 'Failure',
* //   cause: {
* //     _id: 'Cause',
* //     _tag: 'Interrupt',
* //     fiberId: {
* //       _id: 'FiberId',
* //       _tag: 'Runtime',
* //       id: 0,
* //       startTimeMillis: ...
* //     }
* //   }
* // }
* ```
*
* @since 2.0.0
* @category Interruption
*/
const interrupt = interrupt$4;
/**
* @since 2.0.0
* @category Interruption
*/
const interruptWith = interruptWith$2;
/**
* Marks an effect as interruptible.
*
* @since 2.0.0
* @category Interruption
*/
const interruptible = interruptible$2;
/**
* This function behaves like {@link interruptible}, but it also provides a
* `restore` function. This function can be used to restore the interruptibility
* of any specific region of code.
*
* @since 2.0.0
* @category Interruption
*/
const interruptibleMask = interruptibleMask$1;
/**
* Registers a cleanup effect to run when an effect is interrupted.
*
* **Details**
*
* This function allows you to specify an effect to run when the fiber is
* interrupted. This effect will be executed when the fiber is interrupted,
* allowing you to perform cleanup or other actions.
*
* **Example** (Running a Cleanup Action on Interruption)
*
* ```ts
* import { Console, Effect } from "effect"
*
* // This handler is executed when the fiber is interrupted
* const handler = Effect.onInterrupt((_fibers) => Console.log("Cleanup completed"))
*
* const success = Console.log("Task completed").pipe(Effect.as("some result"), handler)
*
* Effect.runFork(success)
* // Output:
* // Task completed
*
* const failure = Console.log("Task failed").pipe(Effect.andThen(Effect.fail("some error")), handler)
*
* Effect.runFork(failure)
* // Output:
* // Task failed
*
* const interruption = Console.log("Task interrupted").pipe(Effect.andThen(Effect.interrupt), handler)
*
* Effect.runFork(interruption)
* // Output:
* // Task interrupted
* // Cleanup completed
* ```
*
* @since 2.0.0
* @category Interruption
*/
const onInterrupt = onInterrupt$1;
/**
* Marks an effect as uninterruptible.
*
* @since 2.0.0
* @category Interruption
*/
const uninterruptible = uninterruptible$1;
/**
* This function behaves like {@link uninterruptible}, but it also provides a
* `restore` function. This function can be used to restore the interruptibility
* of any specific region of code.
*
* @since 2.0.0
* @category Interruption
*/
const uninterruptibleMask = uninterruptibleMask$2;
/**
* Transforms a `Predicate` function into an `Effect` returning the input value if the predicate returns `true`
* or failing with specified error if the predicate fails
*
* **Example**
*
* ```ts
* import { Effect } from "effect"
*
* const isPositive = (n: number): boolean => n > 0
*
* // succeeds with `1`
* Effect.liftPredicate(1, isPositive, n => `${n} is not positive`)
*
* // fails with `"0 is not positive"`
* Effect.liftPredicate(0, isPositive, n => `${n} is not positive`)
* ```
*
* @category Condition Checking
* @since 3.4.0
*/
const liftPredicate = liftPredicate$1;
/**
* Replaces the value inside an effect with a constant value.
*
* **Details**
*
* This function allows you to ignore the original value inside an effect and
* replace it with a constant value.
*
* **When to Use**
*
* It is useful when you no longer need the value produced by an effect but want
* to ensure that the effect completes successfully with a specific constant
* result instead. For instance, you can replace the value produced by a
* computation with a predefined value, ignoring what was calculated before.
*
* **Example** (Replacing a Value)
*
* ```ts
* import { pipe, Effect } from "effect"
*
* // Replaces the value 5 with the constant "new value"
* const program = pipe(Effect.succeed(5), Effect.as("new value"))
*
* Effect.runPromise(program).then(console.log)
* // Output: "new value"
* ```
*
* @since 2.0.0
* @category Mapping
*/
const as = as$3;
/**
* This function maps the success value of an `Effect` value to a `Some` value
* in an `Option` value. If the original `Effect` value fails, the returned
* `Effect` value will also fail.
*
* @category Mapping
* @since 2.0.0
*/
const asSome = asSome$1;
/**
* This function maps the error value of an `Effect` value to a `Some` value
* in an `Option` value. If the original `Effect` value succeeds, the returned
* `Effect` value will also succeed.
*
* @category Mapping
* @since 2.0.0
*/
const asSomeError = asSomeError$1;
/**
* This function maps the success value of an `Effect` value to `void`. If the
* original `Effect` value succeeds, the returned `Effect` value will also
* succeed. If the original `Effect` value fails, the returned `Effect` value
* will fail with the same error.
*
* @since 2.0.0
* @category Mapping
*/
const asVoid = asVoid$3;
/**
* Swaps the success and error channels of an effect.
*
* **Details**
*
* This function reverses the flow of an effect by swapping its success and
* error channels. The success value becomes an error, and the error value
* becomes a success.
*
* **Example**
*
* ```ts
* import { Effect } from "effect"
*
* //      ┌─── Effect<number, string, never>
* //      ▼
* const program = Effect.fail("Oh uh!").pipe(Effect.as(2))
*
* //      ┌─── Effect<string, number, never>
* //      ▼
* const flipped = Effect.flip(program)
* ```
*
* @since 2.0.0
* @category Mapping
*/
const flip = flip$1;
/**
* Swaps the error/value parameters, applies the function `f` and flips the
* parameters back
*
* @since 2.0.0
* @category Mapping
*/
const flipWith = flipWith$1;
/**
* Transforms the value inside an effect by applying a function to it.
*
* **Syntax**
*
* ```ts skip-type-checking
* const mappedEffect = pipe(myEffect, Effect.map(transformation))
* // or
* const mappedEffect = Effect.map(myEffect, transformation)
* // or
* const mappedEffect = myEffect.pipe(Effect.map(transformation))
* ```
*
* **Details**
*
* `map` takes a function and applies it to the value contained within an
* effect, creating a new effect with the transformed value.
*
* It's important to note that effects are immutable, meaning that the original
* effect is not modified. Instead, a new effect is returned with the updated
* value.
*
* **Example** (Adding a Service Charge)
*
* ```ts
* import { pipe, Effect } from "effect"
*
* const addServiceCharge = (amount: number) => amount + 1
*
* const fetchTransactionAmount = Effect.promise(() => Promise.resolve(100))
*
* const finalAmount = pipe(
*   fetchTransactionAmount,
*   Effect.map(addServiceCharge)
* )
*
* Effect.runPromise(finalAmount).then(console.log)
* // Output: 101
* ```
*
* @see {@link mapError} for a version that operates on the error channel.
* @see {@link mapBoth} for a version that operates on both channels.
* @see {@link flatMap} or {@link andThen} for a version that can return a new effect.
*
* @since 2.0.0
* @category Mapping
*/
const map$1 = map$8;
/**
* Applies a stateful transformation to each element of a collection, producing
* new elements along with an updated state.
*
* **When to Use**
*
* Use `mapAccum` when you need to process each element of a collection while
* keeping track of some state across iterations.
*
* **Details**
*
* `mapAccum` takes an initial state (`initial`) and a function (`f`) that is
* applied to each element. This function returns a new state and a transformed
* element. The final effect produces both the accumulated state and the
* transformed collection.
*
* If the input collection is a non-empty array, the return type will match the
* input collection type.
*
* **Example**
*
* ```ts
* import { Effect } from "effect"
*
* // Define an initial state and a transformation function
* const initialState = 0
*
* const transformation = (state: number, element: string) =>
*   Effect.succeed<[number, string]>([state + element.length, element.toUpperCase()])
*
* // Apply mapAccum to transform an array of strings
* const program = Effect.mapAccum(["a", "bb", "ccc"], initialState, transformation)
*
* Effect.runPromise(program).then(([finalState, transformedCollection]) => {
*   console.log(finalState)
*   console.log(transformedCollection)
* })
* // Output:
* // 6
* // [ 'A', 'BB', 'CCC' ]
* ```
*
* @since 2.0.0
* @category Mapping
*/
const mapAccum = mapAccum$1;
/**
* Applies transformations to both the success and error channels of an effect.
*
* **Details**
*
* This function takes two map functions as arguments: one for the error channel
* and one for the success channel. You can use it when you want to modify both
* the error and the success values without altering the overall success or
* failure status of the effect.
*
* **Example**
*
* ```ts
* import { Effect } from "effect"
*
* //      ┌─── Effect<number, string, never>
* //      ▼
* const simulatedTask = Effect.fail("Oh no!").pipe(Effect.as(1))
*
* //      ┌─── Effect<boolean, Error, never>
* //      ▼
* const modified = Effect.mapBoth(simulatedTask, {
*   onFailure: (message) => new Error(message),
*   onSuccess: (n) => n > 0
* })
* ```
*
* @see {@link map} for a version that operates on the success channel.
* @see {@link mapError} for a version that operates on the error channel.
*
* @since 2.0.0
* @category Mapping
*/
const mapBoth = mapBoth$2;
/**
* Transforms or modifies the error produced by an effect without affecting its
* success value.
*
* **When to Use**
*
* This function is helpful when you want to enhance the error with additional
* information, change the error type, or apply custom error handling while
* keeping the original behavior of the effect's success values intact. It only
* operates on the error channel and leaves the success channel unchanged.
*
* **Example**
*
* ```ts
* import { Effect } from "effect"
*
* //      ┌─── Effect<number, string, never>
* //      ▼
* const simulatedTask = Effect.fail("Oh no!").pipe(Effect.as(1))
*
* //      ┌─── Effect<number, Error, never>
* //      ▼
* const mapped = Effect.mapError(
*   simulatedTask,
*   (message) => new Error(message)
* )
* ```
*
* @see {@link map} for a version that operates on the success channel.
* @see {@link mapBoth} for a version that operates on both channels.
* @see {@link orElseFail} if you want to replace the error with a new one.
*
* @since 2.0.0
* @category Mapping
*/
const mapError$1 = mapError$3;
/**
* Maps the cause of failure of an effect using a specified function.
*
* @see {@link sandbox} for a version that exposes the full cause of failures, defects, or interruptions.
* @see {@link catchAllCause} for a version that can recover from all types of defects.
*
* @since 2.0.0
* @category Mapping
*/
const mapErrorCause = mapErrorCause$2;
/**
* Combines both success and error channels of an effect into a single outcome.
*
* **Details**
*
* This function transforms an effect that may fail into one that always returns
* a value, where both success and failure outcomes are handled as values in the
* success channel.
*
* **When to Use**
*
* This can be useful when you want to continue execution regardless of the
* error type and still capture both successful results and errors as part of
* the outcome.
*
* **Example**
*
* ```ts
* import { Effect } from "effect"
*
* //      ┌─── Effect<number, string, never>
* //      ▼
* const program = Effect.fail("Oh uh!").pipe(Effect.as(2))
*
* //      ┌─── Effect<number | string, never, never>
* //      ▼
* const recovered = Effect.merge(program)
* ```
*
* @since 2.0.0
* @category Mapping
*/
const merge = merge$2;
/**
* Returns a new effect with the boolean value of this effect negated.
*
* @since 2.0.0
* @category Mapping
*/
const negate = negate$1;
/**
* Creates a scoped resource using an `acquire` and `release` effect.
*
* **Details**
*
* This function helps manage resources by combining two `Effect` values: one
* for acquiring the resource and one for releasing it.
*
* `acquireRelease` does the following:
*
*   1. Ensures that the effect that acquires the resource will not be
*      interrupted. Note that acquisition may still fail due to internal
*      reasons (such as an uncaught exception).
*   2. Ensures that the `release` effect will not be interrupted, and will be
*      executed as long as the acquisition effect successfully acquires the
*      resource.
*
* If the `acquire` function succeeds, the `release` function is added to the
* list of finalizers for the scope. This ensures that the release will happen
* automatically when the scope is closed.
*
* Both `acquire` and `release` run uninterruptibly, meaning they cannot be
* interrupted while they are executing.
*
* Additionally, the `release` function can be influenced by the exit value when
* the scope closes, allowing for custom handling of how the resource is
* released based on the execution outcome.
*
* **When to Use**
*
* This function is used to ensure that an effect that represents the
* acquisition of a resource (for example, opening a file, launching a thread,
* etc.) will not be interrupted, and that the resource will always be released
* when the `Effect` completes execution.
*
* **Example** (Defining a Simple Resource)
*
* ```ts
* import { Effect } from "effect"
*
* // Define an interface for a resource
* interface MyResource {
*   readonly contents: string
*   readonly close: () => Promise<void>
* }
*
* // Simulate resource acquisition
* const getMyResource = (): Promise<MyResource> =>
*   Promise.resolve({
*     contents: "lorem ipsum",
*     close: () =>
*       new Promise((resolve) => {
*         console.log("Resource released")
*         resolve()
*       })
*   })
*
* // Define how the resource is acquired
* const acquire = Effect.tryPromise({
*   try: () =>
*     getMyResource().then((res) => {
*       console.log("Resource acquired")
*       return res
*     }),
*   catch: () => new Error("getMyResourceError")
* })
*
* // Define how the resource is released
* const release = (res: MyResource) => Effect.promise(() => res.close())
*
* // Create the resource management workflow
* //
* //      ┌─── Effect<MyResource, Error, Scope>
* //      ▼
* const resource = Effect.acquireRelease(acquire, release)
* ```
*
* @see {@link acquireUseRelease} for a version that automatically handles the scoping of resources.
*
* @since 2.0.0
* @category Scoping, Resources & Finalization
*/
const acquireRelease = acquireRelease$1;
/**
* Creates a scoped resource with an interruptible acquire action.
*
* **Details**
*
* This function is similar to {@link acquireRelease}, but it allows the
* acquisition of the resource to be interrupted. The `acquire` effect, which
* represents the process of obtaining the resource, can be interrupted if
* necessary.
*
* @since 2.0.0
* @category Scoping, Resources & Finalization
*/
const acquireReleaseInterruptible = acquireReleaseInterruptible$1;
/**
* Many real-world operations involve working with resources that must be released when no longer needed, such as:
*
* - Database connections
* - File handles
* - Network requests
*
* This function ensures that a resource is:
*
* 1. **Acquired** properly.
* 2. **Used** for its intended purpose.
* 3. **Released** even if an error occurs.
*
* **Example** (Automatically Managing Resource Lifetime)
*
* ```ts
* import { Effect, Console } from "effect"
*
* // Define an interface for a resource
* interface MyResource {
*   readonly contents: string
*   readonly close: () => Promise<void>
* }
*
* // Simulate resource acquisition
* const getMyResource = (): Promise<MyResource> =>
*   Promise.resolve({
*     contents: "lorem ipsum",
*     close: () =>
*       new Promise((resolve) => {
*         console.log("Resource released")
*         resolve()
*       })
*   })
*
* // Define how the resource is acquired
* const acquire = Effect.tryPromise({
*   try: () =>
*     getMyResource().then((res) => {
*       console.log("Resource acquired")
*       return res
*     }),
*   catch: () => new Error("getMyResourceError")
* })
*
* // Define how the resource is released
* const release = (res: MyResource) => Effect.promise(() => res.close())
*
* const use = (res: MyResource) => Console.log(`content is ${res.contents}`)
*
* //      ┌─── Effect<void, Error, never>
* //      ▼
* const program = Effect.acquireUseRelease(acquire, use, release)
*
* Effect.runPromise(program)
* // Output:
* // Resource acquired
* // content is lorem ipsum
* // Resource released
* ```
*
* @since 2.0.0
* @category Scoping, Resources & Finalization
*/
const acquireUseRelease = acquireUseRelease$1;
/**
* Ensures a finalizer is added to the scope of the calling effect, guaranteeing
* it runs when the scope is closed.
*
* **Details**
*
* This function adds a finalizer that will execute whenever the scope of the
* effect is closed, regardless of whether the effect succeeds, fails, or is
* interrupted. The finalizer receives the `Exit` value of the effect's scope,
* allowing it to react differently depending on how the effect concludes.
*
* Finalizers are a reliable way to manage resource cleanup, ensuring that
* resources such as file handles, network connections, or database transactions
* are properly closed even in the event of an unexpected interruption or error.
*
* Finalizers operate in conjunction with Effect's scoped resources. If an
* effect with a finalizer is wrapped in a scope, the finalizer will execute
* automatically when the scope ends.
*
* **Example** (Adding a Finalizer on Success)
*
* ```ts
* import { Effect, Console } from "effect"
*
* //      ┌─── Effect<string, never, Scope>
* //      ▼
* const program = Effect.gen(function* () {
*   yield* Effect.addFinalizer((exit) =>
*     Console.log(`Finalizer executed. Exit status: ${exit._tag}`)
*   )
*   return "some result"
* })
*
* // Wrapping the effect in a scope
* //
* //      ┌─── Effect<string, never, never>
* //      ▼
* const runnable = Effect.scoped(program)
*
* Effect.runPromiseExit(runnable).then(console.log)
* // Output:
* // Finalizer executed. Exit status: Success
* // { _id: 'Exit', _tag: 'Success', value: 'some result' }
* ```
*
* **Example** (Adding a Finalizer on Failure)
*
* ```ts
* import { Effect, Console } from "effect"
*
* //      ┌─── Effect<never, string, Scope>
* //      ▼
* const program = Effect.gen(function* () {
*   yield* Effect.addFinalizer((exit) =>
*     Console.log(`Finalizer executed. Exit status: ${exit._tag}`)
*   )
*   return yield* Effect.fail("Uh oh!")
* })
*
* // Wrapping the effect in a scope
* //
* //      ┌─── Effect<never, string, never>
* //      ▼
* const runnable = Effect.scoped(program)
*
* Effect.runPromiseExit(runnable).then(console.log)
* // Output:
* // Finalizer executed. Exit status: Failure
* // {
* //   _id: 'Exit',
* //   _tag: 'Failure',
* //   cause: { _id: 'Cause', _tag: 'Fail', failure: 'Uh oh!' }
* // }
* ```
*
* **Example** (Adding a Finalizer on Interruption)
*
* ```ts
* import { Effect, Console } from "effect"
*
* //      ┌─── Effect<never, never, Scope>
* //      ▼
* const program = Effect.gen(function* () {
*   yield* Effect.addFinalizer((exit) =>
*     Console.log(`Finalizer executed. Exit status: ${exit._tag}`)
*   )
*   return yield* Effect.interrupt
* })
*
* // Wrapping the effect in a scope
* //
* //      ┌─── Effect<never, never, never>
* //      ▼
* const runnable = Effect.scoped(program)
*
* Effect.runPromiseExit(runnable).then(console.log)
* // Output:
* // Finalizer executed. Exit status: Failure
* // {
* //   _id: 'Exit',
* //   _tag: 'Failure',
* //   cause: {
* //     _id: 'Cause',
* //     _tag: 'Interrupt',
* //     fiberId: {
* //       _id: 'FiberId',
* //       _tag: 'Runtime',
* //       id: 0,
* //       startTimeMillis: ...
* //     }
* //   }
* // }
* ```
*
* @see {@link onExit} for attaching a finalizer directly to an effect.
*
* @since 2.0.0
* @category Scoping, Resources & Finalization
*/
const addFinalizer = addFinalizer$2;
/**
* Guarantees the execution of a finalizer when an effect starts execution.
*
* **Details**
*
* This function allows you to specify a `finalizer` effect that will always be
* run once the effect starts execution, regardless of whether the effect
* succeeds, fails, or is interrupted.
*
* **When to Use**
*
* This is useful when you need to ensure that certain cleanup or final steps
* are executed in all cases, such as releasing resources or performing
* necessary logging.
*
* While this function provides strong guarantees about executing the finalizer,
* it is considered a low-level tool, which may not be ideal for more complex
* resource management. For higher-level resource management with automatic
* acquisition and release, see the {@link acquireRelease} family of functions.
* For use cases where you need access to the result of an effect, consider
* using {@link onExit}.
*
* **Example** (Running a Finalizer in All Outcomes)
*
* ```ts
* import { Console, Effect } from "effect"
*
* // Define a cleanup effect
* const handler = Effect.ensuring(Console.log("Cleanup completed"))
*
* // Define a successful effect
* const success = Console.log("Task completed").pipe(
*   Effect.as("some result"),
*   handler
* )
*
* Effect.runFork(success)
* // Output:
* // Task completed
* // Cleanup completed
*
* // Define a failing effect
* const failure = Console.log("Task failed").pipe(
*   Effect.andThen(Effect.fail("some error")),
*   handler
* )
*
* Effect.runFork(failure)
* // Output:
* // Task failed
* // Cleanup completed
*
* // Define an interrupted effect
* const interruption = Console.log("Task interrupted").pipe(
*   Effect.andThen(Effect.interrupt),
*   handler
* )
*
* Effect.runFork(interruption)
* // Output:
* // Task interrupted
* // Cleanup completed
* ```
*
* @see {@link onExit} for a version that provides access to the result of an
* effect.
*
* @since 2.0.0
* @category Scoping, Resources & Finalization
*/
const ensuring = ensuring$1;
/**
* Ensures a cleanup effect runs whenever the calling effect fails, providing
* the failure cause to the cleanup effect.
*
* **Details**
*
* This function allows you to attach a cleanup effect that runs whenever the
* calling effect fails. The cleanup effect receives the cause of the failure,
* allowing you to perform actions such as logging, releasing resources, or
* executing additional recovery logic based on the error. The cleanup effect
* will execute even if the failure is due to interruption.
*
* Importantly, the cleanup effect itself is uninterruptible, ensuring that it
* completes regardless of external interruptions.
*
* **Example** (Running Cleanup Only on Failure)
*
* ```ts
* import { Console, Effect } from "effect"
*
* // This handler logs the failure cause when the effect fails
* const handler = Effect.onError((cause) =>
*   Console.log(`Cleanup completed: ${cause}`)
* )
*
* // Define a successful effect
* const success = Console.log("Task completed").pipe(
*   Effect.as("some result"),
*   handler
* )
*
* Effect.runFork(success)
* // Output:
* // Task completed
*
* // Define a failing effect
* const failure = Console.log("Task failed").pipe(
*   Effect.andThen(Effect.fail("some error")),
*   handler
* )
*
* Effect.runFork(failure)
* // Output:
* // Task failed
* // Cleanup completed: Error: some error
*
* // Define a failing effect
* const defect = Console.log("Task failed with defect").pipe(
*   Effect.andThen(Effect.die("Boom!")),
*   handler
* )
*
* Effect.runFork(defect)
* // Output:
* // Task failed with defect
* // Cleanup completed: Error: Boom!
*
* // Define an interrupted effect
* const interruption = Console.log("Task interrupted").pipe(
*   Effect.andThen(Effect.interrupt),
*   handler
* )
*
* Effect.runFork(interruption)
* // Output:
* // Task interrupted
* // Cleanup completed: All fibers interrupted without errors.
* ```
*
* @see {@link ensuring} for attaching a cleanup effect that runs on both success and failure.
* @see {@link onExit} for attaching a cleanup effect that runs on all possible exits.
*
* @since 2.0.0
* @category Scoping, Resources & Finalization
*/
const onError = onError$1;
/**
* Guarantees that a cleanup function runs regardless of whether the effect
* succeeds, fails, or is interrupted.
*
* **Details**
*
* This function ensures that a provided cleanup function is executed after the
* effect completes, regardless of the outcome. The cleanup function is given
* the `Exit` value of the effect, which provides detailed information about the
* result:
* - If the effect succeeds, the `Exit` contains the success value.
* - If the effect fails, the `Exit` contains the error or failure cause.
* - If the effect is interrupted, the `Exit` reflects the interruption.
*
* The cleanup function is guaranteed to run uninterruptibly, ensuring reliable
* resource management even in complex or high-concurrency scenarios.
*
* **Example** (Running a Cleanup Function with the Effect’s Result)
*
* ```ts
* import { Console, Effect, Exit } from "effect"
*
* // Define a cleanup effect that logs the result
* const handler = Effect.onExit((exit) =>
*   Console.log(`Cleanup completed: ${Exit.getOrElse(exit, String)}`)
* )
*
* // Define a successful effect
* const success = Console.log("Task completed").pipe(
*   Effect.as("some result"),
*   handler
* )
*
* Effect.runFork(success)
* // Output:
* // Task completed
* // Cleanup completed: some result
*
* // Define a failing effect
* const failure = Console.log("Task failed").pipe(
*   Effect.andThen(Effect.fail("some error")),
*   handler
* )
*
* Effect.runFork(failure)
* // Output:
* // Task failed
* // Cleanup completed: Error: some error
*
* // Define an interrupted effect
* const interruption = Console.log("Task interrupted").pipe(
*   Effect.andThen(Effect.interrupt),
*   handler
* )
*
* Effect.runFork(interruption)
* // Output:
* // Task interrupted
* // Cleanup completed: All fibers interrupted without errors.
* ```
*
* @since 2.0.0
* @category Scoping, Resources & Finalization
*/
const onExit = onExit$2;
/**
* Ensures that finalizers are run concurrently when the scope of an effect is
* closed.
*
* **Details**
*
* This function modifies the behavior of finalizers within a scoped workflow to
* allow them to run concurrently when the scope is closed.
*
* By default, finalizers are executed sequentially in reverse order of their
* addition, but this function changes that behavior to execute all finalizers
* concurrently.
*
* **When to Use**
*
* Running finalizers concurrently can improve performance when multiple
* independent cleanup tasks need to be performed. However, it requires that
* these tasks do not depend on the order of execution or introduce race
* conditions.
*
* **Example**
*
* ```ts
* import { Console, Effect } from "effect"
*
* // Define a program that adds multiple finalizers
* const program = Effect.gen(function*() {
*   yield* Effect.addFinalizer(() => Console.log("Finalizer 1 executed").pipe(Effect.delay("300 millis")))
*   yield* Effect.addFinalizer(() => Console.log("Finalizer 2 executed").pipe(Effect.delay("100 millis")))
*   yield* Effect.addFinalizer(() => Console.log("Finalizer 3 executed").pipe(Effect.delay("200 millis")))
*   return "some result"
* })
*
* // Modify the program to ensure finalizers run in parallel
* const modified = program.pipe(Effect.parallelFinalizers)
*
* const runnable = Effect.scoped(modified)
*
* Effect.runFork(runnable)
* // Output:
* // Finalizer 2 executed
* // Finalizer 3 executed
* // Finalizer 1 executed
* ```
*
* @see {@link sequentialFinalizers} for a version that ensures finalizers are run sequentially.
*
* @since 2.0.0
* @category Scoping, Resources & Finalization
*/
const parallelFinalizers = parallelFinalizers$1;
/**
* Ensures that finalizers are run sequentially in reverse order of their
* addition.
*
* **Details**
*
* This function modifies the behavior of finalizers within a scoped workflow to
* ensure they are run sequentially in reverse order when the scope is closed.
*
* By default, finalizers are executed sequentially, so this only changes the
* behavior if the scope is configured to run finalizers concurrently.
*
* @see {@link parallelFinalizers} for a version that ensures finalizers are run concurrently.
*
* @since 2.0.0
* @category Scoping, Resources & Finalization
*/
const sequentialFinalizers = sequentialFinalizers$1;
/**
* Applies a custom execution strategy to finalizers within a scoped workflow.
*
* **Details**
*
* This function allows you to control how finalizers are executed in a scope by
* applying a specified `ExecutionStrategy`. The `strategy` can dictate whether
* finalizers run (e.g., sequentially or in parallel).
*
* Additionally, the function provides a `restore` operation, which ensures that
* the effect passed to it is executed under the default execution strategy.
*
* @since 2.0.0
* @category Scoping, Resources & Finalization
*/
const finalizersMask = finalizersMask$1;
/**
* Provides access to the current scope in a scoped workflow.
*
* @since 2.0.0
* @category Scoping, Resources & Finalization
*/
const scope = scope$1;
/**
* Accesses the current scope and uses it to perform the specified effect.
*
* @since 2.0.0
* @category Scoping, Resources & Finalization
*/
const scopeWith = scopeWith$1;
/**
* Creates a `Scope`, passes it to the specified effectful function, and closes
* the scope when the effect completes (whether through success, failure, or
* interruption).
*
* @since 3.11.0
* @category Scoping, Resources & Finalization
*/
const scopedWith = scopedWith$1;
/**
* Scopes all resources used in an effect to the lifetime of the effect.
*
* **Details**
*
* This function ensures that all resources used within an effect are tied to
* its lifetime. Finalizers for these resources are executed automatically when
* the effect completes, whether through success, failure, or interruption. This
* guarantees proper resource cleanup without requiring explicit management.
*
* @since 2.0.0
* @category Scoping, Resources & Finalization
*/
const scoped = scopedEffect;
/**
* Scopes all resources acquired by one effect to the lifetime of another
* effect.
*
* **Details**
*
* This function allows you to scope the resources acquired by one effect
* (`self`) to the lifetime of another effect (`use`). This ensures that the
* resources are cleaned up as soon as the `use` effect completes, regardless of
* how the `use` effect ends (success, failure, or interruption).
*
* **Example**
*
* ```ts
* import { Console, Effect } from "effect"
*
* const acquire = Console.log("Acquiring resource").pipe(
*   Effect.as(1),
*   Effect.tap(Effect.addFinalizer(() => Console.log("Releasing resource")))
* )
* const use = (resource: number) => Console.log(`Using resource: ${resource}`)
*
* const program = acquire.pipe(Effect.using(use))
*
* Effect.runFork(program)
* // Output:
* // Acquiring resource
* // Using resource: 1
* // Releasing resource
* ```
*
* @see {@link scopedWith} Manage scoped operations with a temporary scope.
*
* @since 2.0.0
* @category Scoping, Resources & Finalization
*/
const using = using$1;
/**
* Returns the result of the effect and a finalizer to close its scope.
*
* **Details**
*
* This function allows you to retrieve both the result of an effect and a
* finalizer that can be used to manually close its scope. This is useful for
* workflows where you need early access to the result while retaining control
* over the resource cleanup process.
*
* **Example**
*
* ```ts
* import { Console, Effect } from "effect"
*
* const acquire = Console.log("Acquiring resource").pipe(
*   Effect.as(1),
*   Effect.tap(Effect.addFinalizer(() => Console.log("Releasing resource")))
* )
* const program = Effect.gen(function*() {
*   const [finalizer, resource] = yield* Effect.withEarlyRelease(acquire)
*   console.log(`Using resource: ${resource}`)
*   yield* Effect.sleep("1 second")
*   yield* finalizer
* })
*
* Effect.runFork(program.pipe(Effect.scoped))
* // Output:
* // Acquiring resource
* // Using resource: 1
* // Releasing resource
* ```
*
* @since 2.0.0
* @category Scoping, Resources & Finalization
*/
const withEarlyRelease = withEarlyRelease$1;
/**
* Returns a new effect that will not succeed with its value before first
* waiting for the end of all child fibers forked by the effect.
*
* @since 2.0.0
* @category Supervision & Fibers
*/
const awaitAllChildren = awaitAllChildren$1;
/**
* Returns a new workflow that will not supervise any fibers forked by this
* workflow.
*
* @since 2.0.0
* @category Supervision & Fibers
*/
const daemonChildren = daemonChildren$1;
/**
* Constructs an effect with information about the current `Fiber`.
*
* @since 2.0.0
* @category Supervision & Fibers
*/
const descriptor = descriptor$1;
/**
* Constructs an effect based on information about the current `Fiber`.
*
* @since 2.0.0
* @category Supervision & Fibers
*/
const descriptorWith = descriptorWith$1;
/**
* Returns a new workflow that executes this one and captures the changes in
* `FiberRef` values.
*
* @since 2.0.0
* @category Supervision & Fibers
*/
const diffFiberRefs = diffFiberRefs$1;
/**
* Acts on the children of this fiber (collected into a single fiber),
* guaranteeing the specified callback will be invoked, whether or not this
* effect succeeds.
*
* @since 2.0.0
* @category Supervision & Fibers
*/
const ensuringChild = ensuringChild$1;
/**
* Acts on the children of this fiber, guaranteeing the specified callback
* will be invoked, whether or not this effect succeeds.
*
* @since 2.0.0
* @category Supervision & Fibers
*/
const ensuringChildren = ensuringChildren$1;
/**
* @since 2.0.0
* @category Supervision & Fibers
*/
const fiberId = fiberId$1;
/**
* @since 2.0.0
* @category Supervision & Fibers
*/
const fiberIdWith = fiberIdWith$1;
/**
* Creates a new fiber to run an effect concurrently.
*
* **Details**
*
* This function takes an effect and forks it into a separate fiber, allowing it
* to run concurrently without blocking the original effect. The new fiber
* starts execution immediately after being created, and the fiber object is
* returned immediately without waiting for the effect to begin. This is useful
* when you want to run tasks concurrently while continuing other tasks in the
* parent fiber.
*
* The forked fiber is attached to the parent fiber's scope. This means that
* when the parent fiber terminates, the child fiber will also be terminated
* automatically. This feature, known as "auto supervision," ensures that no
* fibers are left running unintentionally. If you prefer not to have this auto
* supervision behavior, you can use {@link forkDaemon} or {@link forkIn}.
*
* **When to Use**
*
* Use this function when you need to run an effect concurrently without
* blocking the current execution flow. For example, you might use it to launch
* background tasks or concurrent computations. However, working with fibers can
* be complex, so before using this function directly, you might want to explore
* higher-level functions like {@link raceWith}, {@link zip}, or others that can
* manage concurrency for you.
*
* **Example**
*
* ```ts
* import { Effect } from "effect"
*
* const fib = (n: number): Effect.Effect<number> =>
*   n < 2
*     ? Effect.succeed(n)
*     : Effect.zipWith(fib(n - 1), fib(n - 2), (a, b) => a + b)
*
* //      ┌─── Effect<RuntimeFiber<number, never>, never, never>
* //      ▼
* const fib10Fiber = Effect.fork(fib(10))
* ```
*
* @see {@link forkWithErrorHandler} for a version that allows you to handle errors.
*
* @since 2.0.0
* @category Supervision & Fibers
*/
const fork = fork$2;
/**
* Creates a long-running background fiber that is independent of its parent.
*
* **Details**
*
* This function creates a "daemon" fiber that runs in the background and is not
* tied to the lifecycle of its parent fiber. Unlike normal fibers that stop
* when the parent fiber terminates, a daemon fiber will continue running until
* the global scope closes or the fiber completes naturally. This makes it
* useful for tasks that need to run in the background independently, such as
* periodic logging, monitoring, or background data processing.
*
* **Example** (Creating a Daemon Fiber)
*
* ```ts
* import { Effect, Console, Schedule } from "effect"
*
* // Daemon fiber that logs a message repeatedly every second
* const daemon = Effect.repeat(
*   Console.log("daemon: still running!"),
*   Schedule.fixed("1 second")
* )
*
* const parent = Effect.gen(function* () {
*   console.log("parent: started!")
*   // Daemon fiber running independently
*   yield* Effect.forkDaemon(daemon)
*   yield* Effect.sleep("3 seconds")
*   console.log("parent: finished!")
* })
*
* Effect.runFork(parent)
* // Output:
* // parent: started!
* // daemon: still running!
* // daemon: still running!
* // daemon: still running!
* // parent: finished!
* // daemon: still running!
* // daemon: still running!
* // daemon: still running!
* // daemon: still running!
* // daemon: still running!
* // ...etc...
* ```
*
* @since 2.0.0
* @category Supervision & Fibers
*/
const forkDaemon = forkDaemon$1;
/**
* Returns an effect that forks all of the specified values, and returns a
* composite fiber that produces a list of their results, in order.
*
* @since 2.0.0
* @category Supervision & Fibers
*/
const forkAll = forkAll$1;
/**
* Forks an effect in a specific scope, allowing finer control over its
* execution.
*
* **Details**
*
* There are some cases where we need more fine-grained control, so we want to
* fork a fiber in a specific scope. We can use the `Effect.forkIn` operator
* which takes the target scope as an argument.
*
* The fiber will be interrupted when the scope is closed.
*
* **Example** (Forking a Fiber in a Specific Scope)
*
* In this example, the child fiber is forked into the outerScope,
* allowing it to outlive the inner scope but still be terminated
* when the outerScope is closed.
*
* ```ts
* import { Console, Effect, Schedule } from "effect"
*
* // Child fiber that logs a message repeatedly every second
* const child = Effect.repeat(
*   Console.log("child: still running!"),
*   Schedule.fixed("1 second")
* )
*
* const program = Effect.scoped(
*   Effect.gen(function* () {
*     yield* Effect.addFinalizer(() =>
*       Console.log("The outer scope is about to be closed!")
*     )
*
*     // Capture the outer scope
*     const outerScope = yield* Effect.scope
*
*     // Create an inner scope
*     yield* Effect.scoped(
*       Effect.gen(function* () {
*         yield* Effect.addFinalizer(() =>
*           Console.log("The inner scope is about to be closed!")
*         )
*         // Fork the child fiber in the outer scope
*         yield* Effect.forkIn(child, outerScope)
*         yield* Effect.sleep("3 seconds")
*       })
*     )
*
*     yield* Effect.sleep("5 seconds")
*   })
* )
*
* Effect.runFork(program)
* // Output:
* // child: still running!
* // child: still running!
* // child: still running!
* // The inner scope is about to be closed!
* // child: still running!
* // child: still running!
* // child: still running!
* // child: still running!
* // child: still running!
* // child: still running!
* // The outer scope is about to be closed!
* ```
*
* @since 2.0.0
* @category Supervision & Fibers
*/
const forkIn = forkIn$1;
/**
* Forks a fiber in a local scope, ensuring it outlives its parent.
*
* **Details**
*
* This function is used to create fibers that are tied to a local scope,
* meaning they are not dependent on their parent fiber's lifecycle. Instead,
* they will continue running until the scope they were created in is closed.
* This is particularly useful when you need a fiber to run independently of the
* parent fiber, but still want it to be terminated when the scope ends.
*
* Fibers created with this function are isolated from the parent fiber’s
* termination, so they can run for a longer period. This behavior is different
* from fibers created with {@link fork}, which are terminated when the parent fiber
* terminates. With `forkScoped`, the child fiber will keep running until the
* local scope ends, regardless of the state of the parent fiber.
*
* **Example** (Forking a Fiber in a Local Scope)
*
* In this example, the child fiber continues to run beyond the lifetime of the parent fiber.
* The child fiber is tied to the local scope and will be terminated only when the scope ends.
*
* ```ts
* import { Effect, Console, Schedule } from "effect"
*
* // Child fiber that logs a message repeatedly every second
* const child = Effect.repeat(
*   Console.log("child: still running!"),
*   Schedule.fixed("1 second")
* )
*
* //      ┌─── Effect<void, never, Scope>
* //      ▼
* const parent = Effect.gen(function* () {
*   console.log("parent: started!")
*   // Child fiber attached to local scope
*   yield* Effect.forkScoped(child)
*   yield* Effect.sleep("3 seconds")
*   console.log("parent: finished!")
* })
*
* // Program runs within a local scope
* const program = Effect.scoped(
*   Effect.gen(function* () {
*     console.log("Local scope started!")
*     yield* Effect.fork(parent)
*     // Scope lasts for 5 seconds
*     yield* Effect.sleep("5 seconds")
*     console.log("Leaving the local scope!")
*   })
* )
*
* Effect.runFork(program)
* // Output:
* // Local scope started!
* // parent: started!
* // child: still running!
* // child: still running!
* // child: still running!
* // parent: finished!
* // child: still running!
* // child: still running!
* // Leaving the local scope!
* ```
*
* @since 2.0.0
* @category Supervision & Fibers
*/
const forkScoped = forkScoped$1;
/**
* Like {@link fork} but handles an error with the provided handler.
*
* @since 2.0.0
* @category Supervision & Fibers
*/
const forkWithErrorHandler = forkWithErrorHandler$1;
/**
* Creates an `Effect` value that represents the exit value of the specified
* fiber.
*
* @see {@link fromFiberEffect} for creating an effect from a fiber obtained from an effect.
*
* @since 2.0.0
* @category Supervision & Fibers
*/
const fromFiber = fromFiber$1;
/**
* Creates an `Effect` value that represents the exit value of a fiber obtained
* from an effect.
*
* @see {@link fromFiber} for creating an effect from a fiber.
*
* @since 2.0.0
* @category Supervision & Fibers
*/
const fromFiberEffect = fromFiberEffect$1;
/**
* Supervises child fibers by reporting them to a specified supervisor.
*
* **Details**
*
* This function takes a supervisor as an argument and returns an effect where
* all child fibers forked within it are supervised by the provided supervisor.
* This enables you to capture detailed information about these child fibers,
* such as their status, through the supervisor.
*
* **Example** (Monitoring Fiber Count)
*
* ```ts
* import { Effect, Supervisor, Schedule, Fiber, FiberStatus } from "effect"
*
* // Main program that monitors fibers while calculating a Fibonacci number
* const program = Effect.gen(function* () {
*   // Create a supervisor to track child fibers
*   const supervisor = yield* Supervisor.track
*
*   // Start a Fibonacci calculation, supervised by the supervisor
*   const fibFiber = yield* fib(20).pipe(
*     Effect.supervised(supervisor),
*     // Fork the Fibonacci effect into a fiber
*     Effect.fork
*   )
*
*   // Define a schedule to periodically monitor the fiber count every 500ms
*   const policy = Schedule.spaced("500 millis").pipe(
*     Schedule.whileInputEffect((_) =>
*       Fiber.status(fibFiber).pipe(
*         // Continue while the Fibonacci fiber is not done
*         Effect.andThen((status) => status !== FiberStatus.done)
*       )
*     )
*   )
*
*   // Start monitoring the fibers, using the supervisor to track the count
*   const monitorFiber = yield* monitorFibers(supervisor).pipe(
*     // Repeat the monitoring according to the schedule
*     Effect.repeat(policy),
*     // Fork the monitoring into its own fiber
*     Effect.fork
*   )
*
*   // Join the monitor and Fibonacci fibers to ensure they complete
*   yield* Fiber.join(monitorFiber)
*   const result = yield* Fiber.join(fibFiber)
*
*   console.log(`fibonacci result: ${result}`)
* })
*
* // Function to monitor and log the number of active fibers
* const monitorFibers = (
*   supervisor: Supervisor.Supervisor<Array<Fiber.RuntimeFiber<any, any>>>
* ): Effect.Effect<void> =>
*   Effect.gen(function* () {
*     const fibers = yield* supervisor.value // Get the current set of fibers
*     console.log(`number of fibers: ${fibers.length}`)
*   })
*
* // Recursive Fibonacci calculation, spawning fibers for each recursive step
* const fib = (n: number): Effect.Effect<number> =>
*   Effect.gen(function* () {
*     if (n <= 1) {
*       return 1
*     }
*     yield* Effect.sleep("500 millis") // Simulate work by delaying
*
*     // Fork two fibers for the recursive Fibonacci calls
*     const fiber1 = yield* Effect.fork(fib(n - 2))
*     const fiber2 = yield* Effect.fork(fib(n - 1))
*
*     // Join the fibers to retrieve their results
*     const v1 = yield* Fiber.join(fiber1)
*     const v2 = yield* Fiber.join(fiber2)
*
*     return v1 + v2 // Combine the results
*   })
*
* Effect.runPromise(program)
* // Output:
* // number of fibers: 0
* // number of fibers: 2
* // number of fibers: 6
* // number of fibers: 14
* // number of fibers: 30
* // number of fibers: 62
* // number of fibers: 126
* // number of fibers: 254
* // number of fibers: 510
* // number of fibers: 1022
* // number of fibers: 2034
* // number of fibers: 3795
* // number of fibers: 5810
* // number of fibers: 6474
* // number of fibers: 4942
* // number of fibers: 2515
* // number of fibers: 832
* // number of fibers: 170
* // number of fibers: 18
* // number of fibers: 0
* // fibonacci result: 10946
* ```
*
* @since 2.0.0
* @category Supervision & Fibers
*/
const supervised = supervised$1;
/**
* Transplants specified effects so that when those effects fork other
* effects, the forked effects will be governed by the scope of the fiber that
* executes this effect.
*
* This can be used to "graft" deep grandchildren onto a higher-level scope,
* effectively extending their lifespans into the parent scope.
*
* @since 2.0.0
* @category Supervision & Fibers
*/
const transplant = transplant$1;
/**
* @since 2.0.0
* @category Supervision & Fibers
*/
const withConcurrency = withConcurrency$1;
/**
* Sets the provided scheduler for usage in the wrapped effect
*
* @since 2.0.0
* @category Scheduler
*/
const withScheduler = withScheduler$1;
/**
* Sets the scheduling priority used when yielding
*
* @since 2.0.0
* @category Scheduler
*/
const withSchedulingPriority = withSchedulingPriority$1;
/**
* Sets the maximum number of operations before yield by the default schedulers
*
* @since 2.0.0
* @category Scheduler
*/
const withMaxOpsBeforeYield = withMaxOpsBeforeYield$1;
/**
* Retrieves the `Clock` service from the context.
*
* **Example**
*
* ```ts
* import { Effect } from "effect"
*
* const program = Effect.gen(function*() {
*   const clock = yield* Effect.clock
*   const currentTime = yield* clock.currentTimeMillis
*   console.log(`Current time in milliseconds: ${currentTime}`)
* })
*
* Effect.runFork(program)
* // Example Output:
* // Current time in milliseconds: 1735484796134
* ```
*
* @since 2.0.0
* @category Clock
*/
const clock = clock$1;
/**
* Retrieves the `Clock` service from the context and provides it to the
* specified effectful function.
*
* **Example**
*
* ```ts
* import { Console, Effect } from "effect"
*
* const program = Effect.clockWith((clock) =>
*   clock.currentTimeMillis.pipe(
*     Effect.map((currentTime) => `Current time is: ${currentTime}`),
*     Effect.tap(Console.log)
*   )
* )
*
* Effect.runFork(program)
* // Example Output:
* // Current time is: 1735484929744
* ```
*
* @since 2.0.0
* @category Clock
*/
const clockWith = clockWith$1;
/**
* Sets the implementation of the `Clock` service to the specified value and
* restores it to its original value when the scope is closed.
*
* @since 2.0.0
* @category Clock
*/
const withClockScoped = withClockScoped$1;
/**
* Executes the specified workflow with the specified implementation of the
* `Clock` service.
*
* @since 2.0.0
* @category Clock
*/
const withClock = withClock$1;
/**
* Retreives the `Console` service from the context
*
* @since 2.0.0
* @category Console
*/
const console$1 = console$2;
/**
* Retreives the `Console` service from the context and provides it to the
* specified effectful function.
*
* @since 2.0.0
* @category Console
*/
const consoleWith = consoleWith$1;
/**
* Sets the implementation of the console service to the specified value and
* restores it to its original value when the scope is closed.
*
* @since 2.0.0
* @category Creating Effects
*/
const withConsoleScoped = withConsoleScoped$1;
/**
* Executes the specified workflow with the specified implementation of the
* console service.
*
* @since 2.0.0
* @category Console
*/
const withConsole = withConsole$1;
/**
* Delays the execution of an effect by a specified `Duration`.
*
* **Details
*
* This function postpones the execution of the provided effect by the specified
* duration. The duration can be provided in various formats supported by the
* `Duration` module.
*
* Internally, this function does not block the thread; instead, it uses an
* efficient, non-blocking mechanism to introduce the delay.
*
* **Example**
*
* ```ts
* import { Console, Effect } from "effect"
*
* const task = Console.log("Task executed")
*
* const program = Console.log("start").pipe(
*   Effect.andThen(
*     // Delays the log message by 2 seconds
*     task.pipe(Effect.delay("2 seconds"))
*   )
* )
*
* Effect.runFork(program)
* // Output:
* // start
* // Task executed
* ```
*
* @since 2.0.0
* @category Delays & Timeouts
*/
const delay = delay$1;
/**
* Suspends the execution of an effect for a specified `Duration`.
*
* **Details**
*
* This function pauses the execution of an effect for a given duration. It is
* asynchronous, meaning that it does not block the fiber executing the effect.
* Instead, the fiber is suspended during the delay period and can resume once
* the specified time has passed.
*
* The duration can be specified using various formats supported by the
* `Duration` module, such as a string (`"2 seconds"`) or numeric value
* representing milliseconds.
*
* **Example**
*
* ```ts
* import { Effect } from "effect"
*
* const program = Effect.gen(function*() {
*   console.log("Starting task...")
*   yield* Effect.sleep("3 seconds") // Waits for 3 seconds
*   console.log("Task completed!")
* })
*
* Effect.runFork(program)
* // Output:
* // Starting task...
* // Task completed!
* ```
*
* @since 2.0.0
* @category Delays & Timeouts
*/
const sleep = sleep$1;
/**
* Executes an effect and measures the time it takes to complete.
*
* **Details**
*
* This function wraps the provided effect and returns a new effect that, when
* executed, performs the original effect and calculates its execution duration.
*
* The result of the new effect includes both the execution time (as a
* `Duration`) and the original effect's result. This is useful for monitoring
* performance or gaining insights into the time taken by specific operations.
*
* The original effect's behavior (success, failure, or interruption) remains
* unchanged, and the timing information is provided alongside the result in a
* tuple.
*
* **Example**
*
* ```ts
* import { Duration, Effect } from "effect"
*
* const task = Effect.gen(function*() {
*   yield* Effect.sleep("2 seconds") // Simulates some work
*   return "some result"
* })
*
* const timedTask = task.pipe(Effect.timed)
*
* const program = Effect.gen(function*() {
*   const [duration, result] = yield* timedTask
*   console.log(`Task completed in ${Duration.toMillis(duration)} ms with result: ${result}`)
* })
*
* Effect.runFork(program)
* // Output: Task completed in 2003.749125 ms with result: some result
* ```
*
* @since 2.0.0
* @category Delays & Timeouts
*/
const timed = timed$1;
/**
* Executes an effect and measures its execution time using a custom clock.
*
* **Details**
*
* This function extends the functionality of {@link timed} by allowing you to
* specify a custom clock for measuring the execution duration. The provided
* effect (`nanoseconds`) represents the clock and should return the current
* time in nanoseconds. The timing information is computed using this custom
* clock instead of the default system clock.
*
* @since 2.0.0
* @category Delays & Timeouts
*/
const timedWith = timedWith$1;
/**
* Adds a time limit to an effect, triggering a timeout if the effect exceeds
* the duration.
*
* **Details**
*
* This function allows you to enforce a time limit on the execution of an
* effect. If the effect does not complete within the given duration, it fails
* with a `TimeoutException`. This is useful for preventing tasks from hanging
* indefinitely, especially in scenarios where responsiveness or resource limits
* are critical.
*
* The returned effect will either:
* - Succeed with the original effect's result if it completes within the
*   specified duration.
* - Fail with a `TimeoutException` if the time limit is exceeded.
*
* **Example**
*
* ```ts
* import { Effect } from "effect"
*
* const task = Effect.gen(function* () {
*   console.log("Start processing...")
*   yield* Effect.sleep("2 seconds") // Simulates a delay in processing
*   console.log("Processing complete.")
*   return "Result"
* })
*
* // Output will show a TimeoutException as the task takes longer
* // than the specified timeout duration
* const timedEffect = task.pipe(Effect.timeout("1 second"))
*
* Effect.runPromiseExit(timedEffect).then(console.log)
* // Output:
* // Start processing...
* // {
* //   _id: 'Exit',
* //   _tag: 'Failure',
* //   cause: {
* //     _id: 'Cause',
* //     _tag: 'Fail',
* //     failure: { _tag: 'TimeoutException' }
* //   }
* // }
* ```
*
* @see {@link timeoutFail} for a version that raises a custom error.
* @see {@link timeoutFailCause} for a version that raises a custom defect.
* @see {@link timeoutTo} for a version that allows specifying both success and
* timeout handlers.
*
* @since 2.0.0
* @category Delays & Timeouts
*/
const timeout = timeout$1;
/**
* Gracefully handles timeouts by returning an `Option` that represents either
* the result or a timeout.
*
* **Details**
*
* This function wraps the outcome of an effect in an `Option` type. If the
* effect completes within the specified duration, it returns a `Some`
* containing the result. If the effect times out, it returns a `None`. Unlike
* other timeout methods, this approach does not raise errors or exceptions;
* instead, it allows you to treat timeouts as a regular outcome, simplifying
* the logic for handling delays.
*
* **When to Use**
*
* This is useful when you want to handle timeouts without causing the program
* to fail, making it easier to manage situations where you expect tasks might
* take too long but want to continue executing other tasks.
*
* **Example**
*
* ```ts
* import { Effect } from "effect"
*
* const task = Effect.gen(function* () {
*   console.log("Start processing...")
*   yield* Effect.sleep("2 seconds") // Simulates a delay in processing
*   console.log("Processing complete.")
*   return "Result"
* })
*
* const timedOutEffect = Effect.all([
*   task.pipe(Effect.timeoutOption("3 seconds")),
*   task.pipe(Effect.timeoutOption("1 second"))
* ])
*
* Effect.runPromise(timedOutEffect).then(console.log)
* // Output:
* // Start processing...
* // Processing complete.
* // Start processing...
* // [
* //   { _id: 'Option', _tag: 'Some', value: 'Result' },
* //   { _id: 'Option', _tag: 'None' }
* // ]
* ```
*
* @see {@link timeout} for a version that raises a `TimeoutException`.
* @see {@link timeoutFail} for a version that raises a custom error.
* @see {@link timeoutFailCause} for a version that raises a custom defect.
* @see {@link timeoutTo} for a version that allows specifying both success and
* timeout handlers.
*
* @since 3.1.0
* @category Delays & Timeouts
*/
const timeoutOption = timeoutOption$1;
/**
* Specifies a custom error to be produced when a timeout occurs.
*
* **Details**
*
* This function allows you to handle timeouts in a customized way by defining a
* specific error to be raised when an effect exceeds the given duration. Unlike
* default timeout behaviors that use generic exceptions, this function gives
* you the flexibility to specify a meaningful error type that aligns with your
* application's needs.
*
* When you apply this function, you provide:
* - A `duration`: The time limit for the effect.
* - An `onTimeout` function: A lazy evaluation function that generates the
*   custom error if the timeout occurs.
*
* If the effect completes within the time limit, its result is returned
* normally. Otherwise, the `onTimeout` function is triggered, and its output is
* used as the error for the effect.
*
* **Example**
*
* ```ts
* import { Effect } from "effect"
*
* const task = Effect.gen(function* () {
*   console.log("Start processing...")
*   yield* Effect.sleep("2 seconds") // Simulates a delay in processing
*   console.log("Processing complete.")
*   return "Result"
* })
*
* class MyTimeoutError {
*   readonly _tag = "MyTimeoutError"
* }
*
* const program = task.pipe(
*   Effect.timeoutFail({
*     duration: "1 second",
*     onTimeout: () => new MyTimeoutError() // Custom timeout error
*   })
* )
*
* Effect.runPromiseExit(program).then(console.log)
* // Output:
* // Start processing...
* // {
* //   _id: 'Exit',
* //   _tag: 'Failure',
* //   cause: {
* //     _id: 'Cause',
* //     _tag: 'Fail',
* //     failure: MyTimeoutError { _tag: 'MyTimeoutError' }
* //   }
* // }
* ```
*
* @see {@link timeout} for a version that raises a `TimeoutException`.
* @see {@link timeoutFailCause} for a version that raises a custom defect.
* @see {@link timeoutTo} for a version that allows specifying both success and
* timeout handlers.
*
* @since 2.0.0
* @category Delays & Timeouts
*/
const timeoutFail = timeoutFail$1;
/**
* Specifies a custom defect to be thrown when a timeout occurs.
*
* **Details**
*
* This function allows you to handle timeouts as exceptional cases by
* generating a custom defect when an effect exceeds the specified duration. You
* provide:
* - A `duration`: The time limit for the effect.
* - An `onTimeout` function: A lazy evaluation function that generates the
*   custom defect (typically created using `Cause.die`).
*
* If the effect completes within the time limit, its result is returned
* normally. Otherwise, the custom defect is triggered, and the effect fails
* with that defect.
*
* **When to Use**
*
* This is especially useful when you need to treat timeouts as critical
* failures in your application and wish to include meaningful information in
* the defect.
*
* **Example**
*
* ```ts
* import { Effect, Cause } from "effect"
*
* const task = Effect.gen(function* () {
*   console.log("Start processing...")
*   yield* Effect.sleep("2 seconds") // Simulates a delay in processing
*   console.log("Processing complete.")
*   return "Result"
* })
*
* const program = task.pipe(
*   Effect.timeoutFailCause({
*     duration: "1 second",
*     onTimeout: () => Cause.die("Timed out!") // Custom defect for timeout
*   })
* )
*
* Effect.runPromiseExit(program).then(console.log)
* // Output:
* // Start processing...
* // {
* //   _id: 'Exit',
* //   _tag: 'Failure',
* //   cause: { _id: 'Cause', _tag: 'Die', defect: 'Timed out!' }
* // }
* ```
*
* @see {@link timeout} for a version that raises a `TimeoutException`.
* @see {@link timeoutFail} for a version that raises a custom error.
* @see {@link timeoutTo} for a version that allows specifying both success and
* timeout handlers.
*
* @since 2.0.0
* @category Delays & Timeouts
*/
const timeoutFailCause = timeoutFailCause$1;
/**
* Provides custom behavior for successful and timed-out operations.
*
* **Details**
*
* This function allows you to define distinct outcomes for an effect depending
* on whether it completes within a specified time frame or exceeds the timeout
* duration. You can provide:
* - `onSuccess`: A handler for processing the result of the effect if it
*   completes successfully within the time limit.
* - `onTimeout`: A handler for generating a result when the effect times out.
* - `duration`: The maximum allowed time for the effect to complete.
*
* **When to Use**
*
* Unlike {@link timeout}, which raises an exception for timeouts, this function
* gives you full control over the behavior for both success and timeout
* scenarios. It is particularly useful when you want to encapsulate timeouts
* and successes into a specific data structure, like an `Either` type, to
* represent these outcomes in a meaningful way.
*
* **Example**
*
* ```ts
* import { Effect, Either } from "effect"
*
* const task = Effect.gen(function* () {
*   console.log("Start processing...")
*   yield* Effect.sleep("2 seconds") // Simulates a delay in processing
*   console.log("Processing complete.")
*   return "Result"
* })
*
* const program = task.pipe(
*   Effect.timeoutTo({
*     duration: "1 second",
*     onSuccess: (result): Either.Either<string, string> =>
*       Either.right(result),
*     onTimeout: (): Either.Either<string, string> =>
*       Either.left("Timed out!")
*   })
* )
*
* Effect.runPromise(program).then(console.log)
* // Output:
* // Start processing...
* // {
* //   _id: "Either",
* //   _tag: "Left",
* //   left: "Timed out!"
* // }
* ```
*
* @see {@link timeout} for a version that raises a `TimeoutException`.
* @see {@link timeoutFail} for a version that raises a custom error.
* @see {@link timeoutFailCause} for a version that raises a custom defect.
*
* @since 2.0.0
* @category Delays & Timeouts
*/
const timeoutTo = timeoutTo$1;
/**
* Allows working with the default configuration provider.
*
* **Details**
*
* This function retrieves the default configuration provider and passes it to
* the provided function, which can use it to perform computations or retrieve
* configuration values. The function can return an effect that leverages the
* configuration provider for its operations.
*
* @since 2.0.0
* @category Config
*/
const configProviderWith = configProviderWith$1;
/**
* Executes an effect using a specific configuration provider.
*
* **Details**
*
* This function lets you run an effect with a specified configuration provider.
* The custom provider will override the default configuration provider for the
* duration of the effect's execution.
*
* **When to Use**
*
* This is particularly useful when you need to use a different set of
* configuration values or sources for specific parts of your application.
*
* **Example**
*
* ```ts
* import { Config, ConfigProvider, Effect } from "effect"
*
* const customProvider: ConfigProvider.ConfigProvider = ConfigProvider.fromMap(
*   new Map([["custom-key", "custom-value"]])
* )
*
* const program = Effect.withConfigProvider(customProvider)(
*   Effect.gen(function*() {
*     const value = yield* Config.string("custom-key")
*     console.log(`Config value: ${value}`)
*   })
* )
*
* Effect.runPromise(program)
* // Output:
* // Config value: custom-value
* ```
*
* @since 2.0.0
* @category Config
*/
const withConfigProvider = withConfigProvider$1;
/**
* Sets a configuration provider within a scope.
*
* **Details**
*
* This function sets the configuration provider to a specified value and
* ensures that it is restored to its original value when the scope is closed.
*
* @since 2.0.0
* @category Config
*/
const withConfigProviderScoped = withConfigProviderScoped$1;
/**
* Accesses the full context of the effect.
*
* **Details**
*
* This function provides the ability to access the entire context required by
* an effect. The context is a container that holds dependencies or environment
* values needed by an effect to run. By using this function, you can retrieve
* and work with the context directly within an effect.
*
* @since 2.0.0
* @category Context
*/
const context = context$1;
/**
* Accesses the context and applies a transformation function.
*
* **Details**
*
* This function retrieves the context of the effect and applies a pure
* transformation function to it. The result of the transformation is then
* returned within the effect.
*
* @see {@link contextWithEffect} for a version that allows effectful transformations.
*
* @since 2.0.0
* @category Context
*/
const contextWith = contextWith$1;
/**
* Accesses the context and performs an effectful transformation.
*
* **Details**
*
* This function retrieves the context and allows you to transform it
* effectually using another effect. It is useful when the transformation
* involves asynchronous or effectful operations.
*
* @see {@link contextWith} for a version that allows pure transformations.
*
* @since 2.0.0
* @category Context
*/
const contextWithEffect = contextWithEffect$1;
/**
* Provides part of the required context while leaving the rest unchanged.
*
* **Details**
*
* This function allows you to transform the context required by an effect,
* providing part of the context and leaving the rest to be fulfilled later.
*
* **Example**
*
* ```ts
* import { Context, Effect } from "effect"
*
* class Service1 extends Context.Tag("Service1")<Service1, { readonly port: number }>() {}
* class Service2 extends Context.Tag("Service2")<Service2, { readonly connection: string }>() {}
*
* const program = Effect.gen(function*() {
*   const service1 = yield* Service1
*   console.log(service1.port)
*   const service2 = yield* Service2
*   console.log(service2.connection)
*   return "some result"
* })
*
* //      ┌─── Effect<string, never, Service2>
* //      ▼
* const programWithService1 = Effect.mapInputContext(
*   program,
*   (ctx: Context.Context<Service2>) => Context.add(ctx, Service1, { port: 3000 })
* )
*
* const runnable = programWithService1.pipe(
*   Effect.provideService(Service2, { connection: "localhost" }),
*   Effect.provideService(Service1, { port: 3001 })
* )
*
* Effect.runPromise(runnable)
* // Output:
* // 3000
* // localhost
* ```
*
* @since 2.0.0
* @category Context
*/
const mapInputContext = mapInputContext$1;
/**
* Provides necessary dependencies to an effect, removing its environmental
* requirements.
*
* **Details**
*
* This function allows you to supply the required environment for an effect.
* The environment can be provided in the form of one or more `Layer`s, a
* `Context`, a `Runtime`, or a `ManagedRuntime`. Once the environment is
* provided, the effect can run without requiring external dependencies.
*
* You can compose layers to create a modular and reusable way of setting up the
* environment for effects. For example, layers can be used to configure
* databases, logging services, or any other required dependencies.
*
* **Example**
*
* ```ts
* import { Context, Effect, Layer } from "effect"
*
* class Database extends Context.Tag("Database")<
*   Database,
*   { readonly query: (sql: string) => Effect.Effect<Array<unknown>> }
* >() {}
*
* const DatabaseLive = Layer.succeed(
*   Database,
*   {
*     // Simulate a database query
*     query: (sql: string) => Effect.log(`Executing query: ${sql}`).pipe(Effect.as([]))
*   }
* )
*
* //      ┌─── Effect<unknown[], never, Database>
* //      ▼
* const program = Effect.gen(function*() {
*   const database = yield* Database
*   const result = yield* database.query("SELECT * FROM users")
*   return result
* })
*
* //      ┌─── Effect<unknown[], never, never>
* //      ▼
* const runnable = Effect.provide(program, DatabaseLive)
*
* Effect.runPromise(runnable).then(console.log)
* // Output:
* // timestamp=... level=INFO fiber=#0 message="Executing query: SELECT * FROM users"
* // []
* ```
*
* @see {@link provideService} for providing a service to an effect.
*
* @since 2.0.0
* @category Context
*/
const provide = effect_provide;
/**
* Provides an implementation for a service in the context of an effect.
*
* **Details**
*
* This function allows you to supply a specific implementation for a service
* required by an effect. Services are typically defined using `Context.Tag`,
* which acts as a unique identifier for the service. By using this function,
* you link the service to its concrete implementation, enabling the effect to
* execute successfully without additional requirements.
*
* For example, you can use this function to provide a random number generator,
* a logger, or any other service your effect depends on. Once the service is
* provided, all parts of the effect that rely on the service will automatically
* use the implementation you supplied.
*
* **Example**
*
* ```ts
* import { Effect, Context } from "effect"
*
* // Declaring a tag for a service that generates random numbers
* class Random extends Context.Tag("MyRandomService")<
*   Random,
*   { readonly next: Effect.Effect<number> }
* >() {}
*
* // Using the service
* const program = Effect.gen(function* () {
*   const random = yield* Random
*   const randomNumber = yield* random.next
*   console.log(`random number: ${randomNumber}`)
* })
*
* // Providing the implementation
* //
* //      ┌─── Effect<void, never, never>
* //      ▼
* const runnable = Effect.provideService(program, Random, {
*   next: Effect.sync(() => Math.random())
* })
*
* // Run successfully
* Effect.runPromise(runnable)
* // Example Output:
* // random number: 0.8241872233134417
* ```
*
* @see {@link provide} for providing multiple layers to an effect.
*
* @since 2.0.0
* @category Context
*/
const provideService = provideService$1;
/**
* Dynamically provides an implementation for a service using an effect.
*
* **Details**
*
* This function allows you to provide an implementation for a service
* dynamically by using another effect. The provided effect is executed to
* produce the service implementation, which is then made available to the
* consuming effect. This is particularly useful when the service implementation
* itself requires asynchronous or resource-intensive initialization.
*
* For example, you can use this function to lazily initialize a database
* connection or fetch configuration values from an external source before
* making the service available to your effect.
*
* @since 2.0.0
* @category Context
*/
const provideServiceEffect = provideServiceEffect$1;
/**
* Creates a function that uses a service from the context to produce a value.
*
* @see {@link serviceFunctionEffect} for a version that returns an effect.
*
* @since 2.0.0
* @category Context
*/
const serviceFunction = serviceFunction$1;
/**
* Creates a function that uses a service from the context to produce an effect.
*
* @see {@link serviceFunction} for a version that returns a value.
*
* @since 2.0.0
* @category Context
*/
const serviceFunctionEffect = serviceFunctionEffect$1;
/**
* @since 2.0.0
* @category Context
*/
const serviceFunctions = serviceFunctions$1;
/**
* @since 2.0.0
* @category Context
*/
const serviceConstants = serviceConstants$1;
/**
* @since 2.0.0
* @category Context
*/
const serviceMembers = serviceMembers$1;
/**
* Retrieves an optional service from the context as an `Option`.
*
* **Details**
*
* This function retrieves a service from the context and wraps it in an
* `Option`. If the service is available, it returns a `Some` containing the
* service. If the service is not found, it returns a `None`. This approach is
* useful when you want to handle the absence of a service gracefully without
* causing an error.
*
* **When to Use**
*
* Use this function when:
* - You need to access a service that may or may not be present in the context.
* - You want to handle the absence of a service using the `Option` type instead
*   of throwing an error.
*
* @see {@link serviceOptional} for a version that throws an error if the service is missing.
*
* @since 2.0.0
* @category Context
*/
const serviceOption = serviceOption$1;
/**
* Retrieves a service from the context, throwing an error if it is missing.
*
* **Details**
*
* This function retrieves a required service from the context. If the service
* is available, it returns the service. If the service is missing, it throws a
* `NoSuchElementException`, which can be handled using Effect's error-handling
* mechanisms. This is useful for services that are critical to the execution of
* your effect.
*
* @see {@link serviceOption} for a version that returns an `Option` instead of throwing an error.
*
* @since 2.0.0
* @category Context
*/
const serviceOptional = serviceOptional$1;
/**
* Updates a service in the context with a new implementation.
*
* **Details**
*
* This function modifies the existing implementation of a service in the
* context. It retrieves the current service, applies the provided
* transformation function `f`, and replaces the old service with the
* transformed one.
*
* **When to Use**
*
* This is useful for adapting or extending a service's behavior during the
* execution of an effect.
*
* @since 2.0.0
* @category Context
*/
const updateService = updateService$1;
/**
* The "do simulation" in Effect allows you to write code in a more declarative style, similar to the "do notation" in other programming languages. It provides a way to define variables and perform operations on them using functions like `bind` and `let`.
*
* Here's how the do simulation works:
*
* 1. Start the do simulation using the `Do` value
* 2. Within the do simulation scope, you can use the `bind` function to define variables and bind them to `Effect` values
* 3. You can accumulate multiple `bind` statements to define multiple variables within the scope
* 4. Inside the do simulation scope, you can also use the `let` function to define variables and bind them to simple values
*
* **Example**
*
* ```ts
* import * as assert from "node:assert"
* import { Effect, pipe } from "effect"
*
* const result = pipe(
*   Effect.Do,
*   Effect.bind("x", () => Effect.succeed(2)),
*   Effect.bind("y", () => Effect.succeed(3)),
*   Effect.let("sum", ({ x, y }) => x + y)
* )
* assert.deepStrictEqual(Effect.runSync(result), { x: 2, y: 3, sum: 5 })
* ```
*
* @see {@link bind}
* @see {@link bindTo}
* @see {@link let_ let}
*
* @category Do notation
* @since 2.0.0
*/
const Do = Do$1;
/**
* The "do simulation" in Effect allows you to write code in a more declarative style, similar to the "do notation" in other programming languages. It provides a way to define variables and perform operations on them using functions like `bind` and `let`.
*
* Here's how the do simulation works:
*
* 1. Start the do simulation using the `Do` value
* 2. Within the do simulation scope, you can use the `bind` function to define variables and bind them to `Effect` values
* 3. You can accumulate multiple `bind` statements to define multiple variables within the scope
* 4. Inside the do simulation scope, you can also use the `let` function to define variables and bind them to simple values
*
* **Example**
*
* ```ts
* import * as assert from "node:assert"
* import { Effect, pipe } from "effect"
*
* const result = pipe(
*   Effect.Do,
*   Effect.bind("x", () => Effect.succeed(2)),
*   Effect.bind("y", () => Effect.succeed(3)),
*   Effect.let("sum", ({ x, y }) => x + y)
* )
* assert.deepStrictEqual(Effect.runSync(result), { x: 2, y: 3, sum: 5 })
* ```
*
* @see {@link Do}
* @see {@link bindTo}
* @see {@link let_ let}
*
* @category Do notation
* @since 2.0.0
*/
const bind = bind$1;
/**
* `bindAll` combines `all` with `bind`. It is useful
* when you want to concurrently run multiple effects and then combine their
* results in a Do notation pipeline.
*
* **Example**
*
* ```ts
* import * as assert from "node:assert"
* import { Effect, Either, pipe } from "effect"
*
* const result = pipe(
*   Effect.Do,
*   Effect.bind("x", () => Effect.succeed(2)),
*   Effect.bindAll(({ x }) => ({
*     a: Effect.succeed(x),
*     b: Effect.fail("oops"),
*   }), { concurrency: 2, mode: "either" })
* )
* assert.deepStrictEqual(Effect.runSync(result), { x: 2, a: Either.right(2), b: Either.left("oops") })
* ```
*
* @category Do notation
* @since 3.7.0
*/
const bindAll = bindAll$1;
/**
* The "do simulation" in Effect allows you to write code in a more declarative style, similar to the "do notation" in other programming languages. It provides a way to define variables and perform operations on them using functions like `bind` and `let`.
*
* Here's how the do simulation works:
*
* 1. Start the do simulation using the `Do` value
* 2. Within the do simulation scope, you can use the `bind` function to define variables and bind them to `Effect` values
* 3. You can accumulate multiple `bind` statements to define multiple variables within the scope
* 4. Inside the do simulation scope, you can also use the `let` function to define variables and bind them to simple values
*
* **Example**
*
* ```ts
* import * as assert from "node:assert"
* import { Effect, pipe } from "effect"
*
* const result = pipe(
*   Effect.Do,
*   Effect.bind("x", () => Effect.succeed(2)),
*   Effect.bind("y", () => Effect.succeed(3)),
*   Effect.let("sum", ({ x, y }) => x + y)
* )
* assert.deepStrictEqual(Effect.runSync(result), { x: 2, y: 3, sum: 5 })
* ```
*
* @see {@link Do}
* @see {@link bind}
* @see {@link let_ let}
*
* @category Do notation
* @since 2.0.0
*/
const bindTo = bindTo$1;
const let_ = let_$1;
/**
* Encapsulates the result of an effect in an `Option`.
*
* **Details**
*
* This function wraps the outcome of an effect in an `Option` type. If the
* original effect succeeds, the success value is wrapped in `Option.some`. If
* the effect fails, the failure is converted to `Option.none`.
*
* This is particularly useful for scenarios where you want to represent the
* absence of a value explicitly, without causing the resulting effect to fail.
* The resulting effect has an error type of `never`, meaning it cannot fail
* directly. However, unrecoverable errors, also referred to as defects, are
* not captured and will still result in failure.
*
* **Example** (Using Effect.option to Handle Errors)
*
* ```ts
* import { Effect } from "effect"
*
* const maybe1 = Effect.option(Effect.succeed(1))
*
* Effect.runPromiseExit(maybe1).then(console.log)
* // Output:
* // {
* //   _id: 'Exit',
* //   _tag: 'Success',
* //   value: { _id: 'Option', _tag: 'Some', value: 1 }
* // }
*
* const maybe2 = Effect.option(Effect.fail("Uh oh!"))
*
* Effect.runPromiseExit(maybe2).then(console.log)
* // Output:
* // {
* //   _id: 'Exit',
* //   _tag: 'Success',
* //   value: { _id: 'Option', _tag: 'None' }
* // }
*
* const maybe3 = Effect.option(Effect.die("Boom!"))
*
* Effect.runPromiseExit(maybe3).then(console.log)
* // Output:
* // {
* //   _id: 'Exit',
* //   _tag: 'Failure',
* //   cause: { _id: 'Cause', _tag: 'Die', defect: 'Boom!' }
* // }
* ```
*
* @see {@link either} for a version that uses `Either` instead.
* @see {@link exit} for a version that encapsulates both recoverable errors and defects in an `Exit`.
*
* @since 2.0.0
* @category Outcome Encapsulation
*/
const option = option$1;
/**
* Encapsulates both success and failure of an `Effect` into an `Either` type.
*
* **Details**
*
* This function converts an effect that may fail into an effect that always
* succeeds, wrapping the outcome in an `Either` type. The result will be
* `Either.Left` if the effect fails, containing the recoverable error, or
* `Either.Right` if it succeeds, containing the result.
*
* Using this function, you can handle recoverable errors explicitly without
* causing the effect to fail. This is particularly useful in scenarios where
* you want to chain effects and manage both success and failure in the same
* logical flow.
*
* It's important to note that unrecoverable errors, often referred to as
* "defects," are still thrown and not captured within the `Either` type. Only
* failures that are explicitly represented as recoverable errors in the effect
* are encapsulated.
*
* The resulting effect cannot fail directly because all recoverable failures
* are represented inside the `Either` type.
*
* **Example**
*
* ```ts
* import { Effect, Either, Random } from "effect"
*
* class HttpError {
*   readonly _tag = "HttpError"
* }
*
* class ValidationError {
*   readonly _tag = "ValidationError"
* }
*
* //      ┌─── Effect<string, HttpError | ValidationError, never>
* //      ▼
* const program = Effect.gen(function* () {
*   const n1 = yield* Random.next
*   const n2 = yield* Random.next
*   if (n1 < 0.5) {
*     yield* Effect.fail(new HttpError())
*   }
*   if (n2 < 0.5) {
*     yield* Effect.fail(new ValidationError())
*   }
*   return "some result"
* })
*
* //      ┌─── Effect<string, never, never>
* //      ▼
* const recovered = Effect.gen(function* () {
*   //      ┌─── Either<string, HttpError | ValidationError>
*   //      ▼
*   const failureOrSuccess = yield* Effect.either(program)
*   return Either.match(failureOrSuccess, {
*     onLeft: (error) => `Recovering from ${error._tag}`,
*     onRight: (value) => value // Do nothing in case of success
*   })
* })
* ```
*
* @see {@link option} for a version that uses `Option` instead.
* @see {@link exit} for a version that encapsulates both recoverable errors and defects in an `Exit`.
*
* @since 2.0.0
* @category Outcome Encapsulation
*/
const either = either$1;
/**
* Encapsulates both success and failure of an `Effect` using the `Exit` type.
*
* **Details**
*
* This function converts an effect into one that always succeeds, wrapping its
* outcome in the `Exit` type. The `Exit` type provides explicit handling of
* both success (`Exit.Success`) and failure (`Exit.Failure`) cases, including
* defects (unrecoverable errors).
*
* Unlike {@link either} or {@link option}, this function also encapsulates
* defects, which are typically unrecoverable and would otherwise terminate the
* effect. With the `Exit` type, defects are represented in `Exit.Failure`,
* allowing for detailed introspection and structured error handling.
*
* This makes the resulting effect robust and incapable of direct failure (its
* error type is `never`). It is particularly useful for workflows where all
* outcomes, including unexpected defects, must be managed and analyzed.
*
* **Example**
*
* ```ts
* import { Effect, Cause, Console, Exit } from "effect"
*
* // Simulating a runtime error
* const task = Effect.dieMessage("Boom!")
*
* const program = Effect.gen(function* () {
*   const exit = yield* Effect.exit(task)
*   if (Exit.isFailure(exit)) {
*     const cause = exit.cause
*     if (
*       Cause.isDieType(cause) &&
*       Cause.isRuntimeException(cause.defect)
*     ) {
*       yield* Console.log(
*         `RuntimeException defect caught: ${cause.defect.message}`
*       )
*     } else {
*       yield* Console.log("Unknown failure caught.")
*     }
*   }
* })
*
* // We get an Exit.Success because we caught all failures
* Effect.runPromiseExit(program).then(console.log)
* // Output:
* // RuntimeException defect caught: Boom!
* // {
* //   _id: "Exit",
* //   _tag: "Success",
* //   value: undefined
* // }
* ```
*
* @see {@link option} for a version that uses `Option` instead.
* @see {@link either} for a version that uses `Either` instead.
*
* @since 2.0.0
* @category Outcome Encapsulation
*/
const exit = exit$2;
/**
* Converts an `Effect` into an operation that completes a `Deferred` with its result.
*
* **Details**
*
* The `intoDeferred` function takes an effect and a `Deferred` and ensures that the `Deferred`
* is completed based on the outcome of the effect. If the effect succeeds, the `Deferred` is
* completed with the success value. If the effect fails, the `Deferred` is completed with the
* failure. Additionally, if the effect is interrupted, the `Deferred` will also be interrupted.
*
* **Example**
*
* ```ts
* import { Deferred, Effect } from "effect"
*
* // Define an effect that succeeds
* const successEffect = Effect.succeed(42)
*
* const program = Effect.gen(function*() {
*   // Create a deferred
*   const deferred = yield* Deferred.make<number, string>()
*
*   // Complete the deferred using the successEffect
*   const isCompleted = yield* Effect.intoDeferred(successEffect, deferred)
*
*   // Access the value of the deferred
*   const value = yield* Deferred.await(deferred)
*   console.log(value)
*
*   return isCompleted
* })
*
* Effect.runPromise(program).then(console.log)
* // Output:
* // 42
* // true
* ```
*
* @since 2.0.0
* @category Synchronization Utilities
*/
const intoDeferred = intoDeferred$1;
const if_ = if_$1;
/**
* Filters an effect, dying with a custom defect if the predicate fails.
*
* **Details**
*
* This function applies a predicate to the result of an effect. If the
* predicate evaluates to `false`, the effect dies with a custom defect
* generated by the `orDieWith` function.
*
* **When to Use**
*
* This is useful for enforcing constraints on values and treating violations as
* fatal program errors.
*
* @since 2.0.0
* @category Filtering
*/
const filterOrDie = filterOrDie$1;
/**
* Filters an effect, dying with a custom message if the predicate fails.
*
* **Details**
*
* This function works like {@link filterOrDie} but allows you to specify a
* custom error message to describe the reason for the failure. The message is
* included in the defect when the predicate evaluates to `false`.
*
* @since 2.0.0
* @category Filtering
*/
const filterOrDieMessage = filterOrDieMessage$1;
/**
* Filters an effect, providing an alternative effect if the predicate fails.
*
* **Details**
*
* This function applies a predicate to the result of an effect. If the
* predicate evaluates to `false`, it executes the `orElse` effect instead. The
* `orElse` effect can produce an alternative value or perform additional
* computations.
*
* @since 2.0.0
* @category Filtering
*/
const filterOrElse = filterOrElse$1;
/**
* Filters an effect, failing with a custom error if the predicate fails.
*
* **Details**
*
* This function applies a predicate to the result of an effect. If the
* predicate evaluates to `false`, the effect fails with a custom error
* generated by the `orFailWith` function.
*
* **When to Use**
*
* This is useful for enforcing constraints and treating violations as
* recoverable errors.
*
* **Providing a Guard**
*
* In addition to the filtering capabilities discussed earlier, you have the
* option to further refine and narrow down the type of the success channel by
* providing a [user-defined type
* guard](https://www.typescriptlang.org/docs/handbook/2/narrowing.html#using-type-predicates).
* Let's explore this concept through an example:
*
* **Example**
*
* ```ts
* import { Effect, pipe } from "effect"
*
* // Define a user interface
* interface User {
*   readonly name: string
* }
*
* // Simulate an asynchronous authentication function
* declare const auth: () => Promise<User | null>
*
* const program = pipe(
*   Effect.promise(() => auth()),
*   // Use filterOrFail with a custom type guard to ensure user is not null
*   Effect.filterOrFail(
*     (user): user is User => user !== null, // Type guard
*     () => new Error("Unauthorized")
*   ),
*   // 'user' now has the type `User` (not `User | null`)
*   Effect.andThen((user) => user.name)
* )
* ```
*
* @since 2.0.0
* @category Filtering
*/
const filterOrFail = filterOrFail$1;
/**
* Filters an effect with an effectful predicate, falling back to an alternative
* effect if the predicate fails.
*
* **Details**
*
* This function applies a predicate to the result of an effect. If the
* predicate evaluates to `false`, the effect falls back to the `orElse`
* effect. The `orElse` effect can produce an alternative value or perform
* additional computations.
*
* **Example**
*
* ```ts
* import { Effect, pipe } from "effect"
*
* // Define a user interface
* interface User {
*   readonly name: string
* }
*
* // Simulate an asynchronous authentication function
* declare const auth: () => Promise<User | null>
*
* const program = pipe(
*   Effect.promise(() => auth()),
*   // Use filterEffectOrElse with an effectful predicate
*   Effect.filterEffectOrElse({
*     predicate: (user) => Effect.succeed(user !== null),
*     orElse: (user) => Effect.fail(new Error(`Unauthorized user: ${user}`))
*   }),
* )
* ```
*
* @since 3.13.0
* @category Filtering
*/
const filterEffectOrElse = filterEffectOrElse$1;
/**
* Filters an effect with an effectful predicate, failing with a custom error if the predicate fails.
*
* **Details**
*
* This function applies a predicate to the result of an effect. If the
* predicate evaluates to `false`, the effect fails with a custom error
* generated by the `orFailWith` function.
*
* **When to Use**
*
* This is useful for enforcing constraints and treating violations as
* recoverable errors.
*
* **Example**
*
* ```ts
* import { Effect, pipe } from "effect"
*
* // Define a user interface
* interface User {
*   readonly name: string
* }
*
* // Simulate an asynchronous authentication function
* declare const auth: () => Promise<User | null>
*
* const program = pipe(
*   Effect.promise(() => auth()),
*   // Use filterEffectOrFail with an effectful predicate
*   Effect.filterEffectOrFail({
*     predicate: (user) => Effect.succeed(user !== null),
*     orFailWith: () => new Error("Unauthorized")
*   }),
* )
* ```
*
* @since 3.13.0
* @category Filtering
*/
const filterEffectOrFail = filterEffectOrFail$1;
/**
* Executes an effect only if the condition is `false`.
*
* @see {@link unlessEffect} for a version that allows the condition to be an effect.
* @see {@link when} for a version that executes the effect when the condition is `true`.
*
* @since 2.0.0
* @category Conditional Operators
*/
const unless = unless$1;
/**
* Conditionally execute an effect based on the result of another effect.
*
* @see {@link unless} for a version that allows the condition to be a boolean.
* @see {@link whenEffect} for a version that executes the effect when the condition is `true`.
*
* @since 2.0.0
* @category Conditional Operators
*/
const unlessEffect = unlessEffect$1;
/**
* Conditionally executes an effect based on a boolean condition.
*
* **Details**
*
* This function allows you to run an effect only if a given condition evaluates
* to `true`. If the condition is `true`, the effect is executed, and its result
* is wrapped in an `Option.some`. If the condition is `false`, the effect is
* skipped, and the result is `Option.none`.
*
* **When to Use**
*
* This function is useful for scenarios where you need to dynamically decide
* whether to execute an effect based on runtime logic, while also representing
* the skipped case explicitly.
*
* **Example** (Conditional Effect Execution)
*
* ```ts
* import { Effect, Option } from "effect"
*
* const validateWeightOption = (
*   weight: number
* ): Effect.Effect<Option.Option<number>> =>
*   // Conditionally execute the effect if the weight is non-negative
*   Effect.succeed(weight).pipe(Effect.when(() => weight >= 0))
*
* // Run with a valid weight
* Effect.runPromise(validateWeightOption(100)).then(console.log)
* // Output:
* // {
* //   _id: "Option",
* //   _tag: "Some",
* //   value: 100
* // }
*
* // Run with an invalid weight
* Effect.runPromise(validateWeightOption(-5)).then(console.log)
* // Output:
* // {
* //   _id: "Option",
* //   _tag: "None"
* // }
* ```
*
* @see {@link whenEffect} for a version that allows the condition to be an effect.
* @see {@link unless} for a version that executes the effect when the condition is `false`.
*
* @since 2.0.0
* @category Conditional Operators
*/
const when = when$1;
/**
* Conditionally executes an effect based on the result of another effect.
*
* **Details**
*
* This function allows you to run an effect only if a conditional effect
* evaluating to a boolean resolves to `true`. If the conditional effect
* evaluates to `true`, the specified effect is executed, and its result is
* wrapped in `Option.some`. If the conditional effect evaluates to `false`, the
* effect is skipped, and the result is `Option.none`.
*
* **When to Use**
*
* This function is particularly useful when the decision to execute an effect
* depends on the result of another effect, such as a random value, a
* user-provided input, or a network request result.
*
* **Example** (Using an Effect as a Condition)
*
* ```ts
* import { Effect, Random } from "effect"
*
* const randomIntOption = Random.nextInt.pipe(
*   Effect.whenEffect(Random.nextBoolean)
* )
*
* console.log(Effect.runSync(randomIntOption))
* // Example Output:
* // { _id: 'Option', _tag: 'Some', value: 8609104974198840 }
* ```
*
* @see {@link when} for a version that allows the condition to be a boolean.
* @see {@link unlessEffect} for a version that executes the effect when the condition is `false`.
*
* @since 2.0.0
* @category Conditional Operators
*/
const whenEffect = whenEffect$1;
/**
* Executes an effect conditionally based on the value of a `FiberRef` that
* satisfies a predicate.
*
* **Details**
*
* This function enables you to execute an effect only when the value of a
* specified `FiberRef` meets a certain condition defined by a predicate. If the
* value satisfies the predicate, the effect is executed, and the result is
* wrapped in an `Option.some`. If the predicate is not satisfied, the effect is
* skipped, and the result is `Option.none`. In both cases, the current value of
* the `FiberRef` is included in the result.
*
* @since 2.0.0
* @category Conditional Operators
*/
const whenFiberRef = whenFiberRef$1;
/**
* Executes an effect conditionally based on the value of a `Ref` that satisfies
* a predicate.
*
* **Details**
*
* This function allows you to execute an effect only when the value of a
* specified `Ref` meets a condition defined by a predicate. If the value
* satisfies the predicate, the effect is executed, and the result is wrapped in
* an `Option.some`. If the predicate is not satisfied, the effect is skipped,
* and the result is `Option.none`. In both cases, the current value of the
* `Ref` is included in the result.
*
* @since 2.0.0
* @category Conditional Operators
*/
const whenRef = whenRef$1;
/**
* Chains effects to produce new `Effect` instances, useful for combining
* operations that depend on previous results.
*
* **Syntax**
*
* ```ts skip-type-checking
* const flatMappedEffect = pipe(myEffect, Effect.flatMap(transformation))
* // or
* const flatMappedEffect = Effect.flatMap(myEffect, transformation)
* // or
* const flatMappedEffect = myEffect.pipe(Effect.flatMap(transformation))
* ```
*
* **Details**
*
* `flatMap` lets you sequence effects so that the result of one effect can be
* used in the next step. It is similar to `flatMap` used with arrays but works
* specifically with `Effect` instances, allowing you to avoid deeply nested
* effect structures.
*
* Since effects are immutable, `flatMap` always returns a new effect instead of
* changing the original one.
*
* **When to Use**
*
* Use `flatMap` when you need to chain multiple effects, ensuring that each
* step produces a new `Effect` while flattening any nested effects that may
* occur.
*
* **Example**
*
* ```ts
* import { pipe, Effect } from "effect"
*
* // Function to apply a discount safely to a transaction amount
* const applyDiscount = (
*   total: number,
*   discountRate: number
* ): Effect.Effect<number, Error> =>
*   discountRate === 0
*     ? Effect.fail(new Error("Discount rate cannot be zero"))
*     : Effect.succeed(total - (total * discountRate) / 100)
*
* // Simulated asynchronous task to fetch a transaction amount from database
* const fetchTransactionAmount = Effect.promise(() => Promise.resolve(100))
*
* // Chaining the fetch and discount application using `flatMap`
* const finalAmount = pipe(
*   fetchTransactionAmount,
*   Effect.flatMap((amount) => applyDiscount(amount, 5))
* )
*
* Effect.runPromise(finalAmount).then(console.log)
* // Output: 95
* ```
*
* @see {@link tap} for a version that ignores the result of the effect.
*
* @since 2.0.0
* @category Sequencing
*/
const flatMap$1 = flatMap$4;
/**
* Chains two actions, where the second action can depend on the result of the
* first.
*
* **Syntax**
*
* ```ts skip-type-checking
* const transformedEffect = pipe(myEffect, Effect.andThen(anotherEffect))
* // or
* const transformedEffect = Effect.andThen(myEffect, anotherEffect)
* // or
* const transformedEffect = myEffect.pipe(Effect.andThen(anotherEffect))
* ```
*
* **When to Use**
*
* Use `andThen` when you need to run multiple actions in sequence, with the
* second action depending on the result of the first. This is useful for
* combining effects or handling computations that must happen in order.
*
* **Details**
*
* The second action can be:
*
* - A constant value (similar to {@link as})
* - A function returning a value (similar to {@link map})
* - A `Promise`
* - A function returning a `Promise`
* - An `Effect`
* - A function returning an `Effect` (similar to {@link flatMap})
*
* **Note:** `andThen` works well with both `Option` and `Either` types,
* treating them as effects.
*
* **Example** (Applying a Discount Based on Fetched Amount)
*
* ```ts
* import { pipe, Effect } from "effect"
*
* // Function to apply a discount safely to a transaction amount
* const applyDiscount = (
*   total: number,
*   discountRate: number
* ): Effect.Effect<number, Error> =>
*   discountRate === 0
*     ? Effect.fail(new Error("Discount rate cannot be zero"))
*     : Effect.succeed(total - (total * discountRate) / 100)
*
* // Simulated asynchronous task to fetch a transaction amount from database
* const fetchTransactionAmount = Effect.promise(() => Promise.resolve(100))
*
* // Using Effect.map and Effect.flatMap
* const result1 = pipe(
*   fetchTransactionAmount,
*   Effect.map((amount) => amount * 2),
*   Effect.flatMap((amount) => applyDiscount(amount, 5))
* )
*
* Effect.runPromise(result1).then(console.log)
* // Output: 190
*
* // Using Effect.andThen
* const result2 = pipe(
*   fetchTransactionAmount,
*   Effect.andThen((amount) => amount * 2),
*   Effect.andThen((amount) => applyDiscount(amount, 5))
* )
*
* Effect.runPromise(result2).then(console.log)
* // Output: 190
* ```
*
* @since 2.0.0
* @category Sequencing
*/
const andThen = andThen$1;
/**
* @since 2.0.0
* @category Sequencing
*/
const flatten$1 = flatten$3;
/**
* Races two effects and returns the result of the first successful one.
*
* **Details**
*
* This function takes two effects and runs them concurrently. The first effect
* that successfully completes will determine the result of the race, and the
* other effect will be interrupted.
*
* If neither effect succeeds, the function will fail with a `Cause`
* containing all the errors.
*
* **When to Use**
*
* This is useful when you want to run two effects concurrently, but only care
* about the first one to succeed. It is commonly used in cases like timeouts,
* retries, or when you want to optimize for the faster response without
* worrying about the other effect.
*
* **Handling Success or Failure with Either**
*
* If you want to handle the result of whichever task completes first, whether
* it succeeds or fails, you can use the `Effect.either` function. This function
* wraps the result in an `Either` type, allowing you to see if the result
* was a success (`Right`) or a failure (`Left`).
*
* **Example** (Both Tasks Succeed)
*
* ```ts
* import { Effect, Console } from "effect"
*
* const task1 = Effect.succeed("task1").pipe(
*   Effect.delay("200 millis"),
*   Effect.tap(Console.log("task1 done")),
*   Effect.onInterrupt(() => Console.log("task1 interrupted"))
* )
* const task2 = Effect.succeed("task2").pipe(
*   Effect.delay("100 millis"),
*   Effect.tap(Console.log("task2 done")),
*   Effect.onInterrupt(() => Console.log("task2 interrupted"))
* )
*
* const program = Effect.race(task1, task2)
*
* Effect.runFork(program)
* // Output:
* // task1 done
* // task2 interrupted
* ```
*
* **Example** (One Task Fails, One Succeeds)
*
* ```ts
* import { Effect, Console } from "effect"
*
* const task1 = Effect.fail("task1").pipe(
*   Effect.delay("100 millis"),
*   Effect.tap(Console.log("task1 done")),
*   Effect.onInterrupt(() => Console.log("task1 interrupted"))
* )
* const task2 = Effect.succeed("task2").pipe(
*   Effect.delay("200 millis"),
*   Effect.tap(Console.log("task2 done")),
*   Effect.onInterrupt(() => Console.log("task2 interrupted"))
* )
*
* const program = Effect.race(task1, task2)
*
* Effect.runFork(program)
* // Output:
* // task2 done
* ```
*
* **Example** (Both Tasks Fail)
*
* ```ts
* import { Effect, Console } from "effect"
*
* const task1 = Effect.fail("task1").pipe(
*   Effect.delay("100 millis"),
*   Effect.tap(Console.log("task1 done")),
*   Effect.onInterrupt(() => Console.log("task1 interrupted"))
* )
* const task2 = Effect.fail("task2").pipe(
*   Effect.delay("200 millis"),
*   Effect.tap(Console.log("task2 done")),
*   Effect.onInterrupt(() => Console.log("task2 interrupted"))
* )
*
* const program = Effect.race(task1, task2)
*
* Effect.runPromiseExit(program).then(console.log)
* // Output:
* // {
* //   _id: 'Exit',
* //   _tag: 'Failure',
* //   cause: {
* //     _id: 'Cause',
* //     _tag: 'Parallel',
* //     left: { _id: 'Cause', _tag: 'Fail', failure: 'task1' },
* //     right: { _id: 'Cause', _tag: 'Fail', failure: 'task2' }
* //   }
* // }
* ```
*
* **Example** (Handling Success or Failure with Either)
*
* ```ts
* import { Effect, Console } from "effect"
*
* const task1 = Effect.fail("task1").pipe(
*   Effect.delay("100 millis"),
*   Effect.tap(Console.log("task1 done")),
*   Effect.onInterrupt(() => Console.log("task1 interrupted"))
* )
* const task2 = Effect.succeed("task2").pipe(
*   Effect.delay("200 millis"),
*   Effect.tap(Console.log("task2 done")),
*   Effect.onInterrupt(() => Console.log("task2 interrupted"))
* )
*
* // Run both tasks concurrently, wrapping the result
* // in Either to capture success or failure
* const program = Effect.race(Effect.either(task1), Effect.either(task2))
*
* Effect.runPromise(program).then(console.log)
* // Output:
* // task2 interrupted
* // { _id: 'Either', _tag: 'Left', left: 'task1' }
* ```
*
* @see {@link raceAll} for a version that handles multiple effects.
* @see {@link raceFirst} for a version that returns the result of the first effect to complete.
*
* @since 2.0.0
* @category Racing
*/
const race = race$1;
/**
* Races multiple effects and returns the first successful result.
*
* **Details**
*
* This function runs multiple effects concurrently and returns the result of
* the first one to succeed. If one effect succeeds, the others will be
* interrupted.
*
* If none of the effects succeed, the function will fail with the last error
* encountered.
*
* **When to Use**
*
* This is useful when you want to race multiple effects, but only care about
* the first one to succeed. It is commonly used in cases like timeouts,
* retries, or when you want to optimize for the faster response without
* worrying about the other effects.
*
* **Example** (All Tasks Succeed)
*
* ```ts
* import { Effect, Console } from "effect"
*
* const task1 = Effect.succeed("task1").pipe(
*   Effect.delay("100 millis"),
*   Effect.tap(Console.log("task1 done")),
*   Effect.onInterrupt(() => Console.log("task1 interrupted"))
* )
* const task2 = Effect.succeed("task2").pipe(
*   Effect.delay("200 millis"),
*   Effect.tap(Console.log("task2 done")),
*   Effect.onInterrupt(() => Console.log("task2 interrupted"))
* )
*
* const task3 = Effect.succeed("task3").pipe(
*   Effect.delay("150 millis"),
*   Effect.tap(Console.log("task3 done")),
*   Effect.onInterrupt(() => Console.log("task3 interrupted"))
* )
*
* const program = Effect.raceAll([task1, task2, task3])
*
* Effect.runFork(program)
* // Output:
* // task1 done
* // task2 interrupted
* // task3 interrupted
* ```
*
* **Example** (One Task Fails, Two Tasks Succeed)
*
* ```ts
* import { Effect, Console } from "effect"
*
* const task1 = Effect.fail("task1").pipe(
*   Effect.delay("100 millis"),
*   Effect.tap(Console.log("task1 done")),
*   Effect.onInterrupt(() => Console.log("task1 interrupted"))
* )
* const task2 = Effect.succeed("task2").pipe(
*   Effect.delay("200 millis"),
*   Effect.tap(Console.log("task2 done")),
*   Effect.onInterrupt(() => Console.log("task2 interrupted"))
* )
*
* const task3 = Effect.succeed("task3").pipe(
*   Effect.delay("150 millis"),
*   Effect.tap(Console.log("task3 done")),
*   Effect.onInterrupt(() => Console.log("task3 interrupted"))
* )
*
* const program = Effect.raceAll([task1, task2, task3])
*
* Effect.runFork(program)
* // Output:
* // task3 done
* // task2 interrupted
* ```
*
* **Example** (All Tasks Fail)
*
* ```ts
* import { Effect, Console } from "effect"
*
* const task1 = Effect.fail("task1").pipe(
*   Effect.delay("100 millis"),
*   Effect.tap(Console.log("task1 done")),
*   Effect.onInterrupt(() => Console.log("task1 interrupted"))
* )
* const task2 = Effect.fail("task2").pipe(
*   Effect.delay("200 millis"),
*   Effect.tap(Console.log("task2 done")),
*   Effect.onInterrupt(() => Console.log("task2 interrupted"))
* )
*
* const task3 = Effect.fail("task3").pipe(
*   Effect.delay("150 millis"),
*   Effect.tap(Console.log("task3 done")),
*   Effect.onInterrupt(() => Console.log("task3 interrupted"))
* )
*
* const program = Effect.raceAll([task1, task2, task3])
*
* Effect.runPromiseExit(program).then(console.log)
* // Output:
* // {
* //   _id: 'Exit',
* //   _tag: 'Failure',
* //   cause: { _id: 'Cause', _tag: 'Fail', failure: 'task2' }
* // }
* ```
*
* @see {@link race} for a version that handles only two effects.
*
* @since 2.0.0
* @category Racing
*/
const raceAll = raceAll$1;
/**
* Races two effects and returns the result of the first one to complete.
*
* **Details**
*
* This function takes two effects and runs them concurrently, returning the
* result of the first one that completes, regardless of whether it succeeds or
* fails.
*
* **When to Use**
*
* This function is useful when you want to race two operations, and you want to
* proceed with whichever one finishes first, regardless of whether it succeeds
* or fails.
*
* **Disconnecting Effects**
*
* The `Effect.raceFirst` function safely interrupts the “loser” effect once the other completes, but it will not resume until the loser is cleanly terminated.
*
* If you want a quicker return, you can disconnect the interrupt signal for both effects. Instead of calling:
*
* ```ts skip-type-checking
* Effect.raceFirst(task1, task2)
* ```
*
* You can use:
*
* ```ts skip-type-checking
* Effect.raceFirst(Effect.disconnect(task1), Effect.disconnect(task2))
* ```
*
* This allows both effects to complete independently while still terminating the losing effect in the background.
*
* **Example** (Both Tasks Succeed)
*
* ```ts
* import { Effect, Console } from "effect"
*
* const task1 = Effect.succeed("task1").pipe(
*   Effect.delay("100 millis"),
*   Effect.tap(Console.log("task1 done")),
*   Effect.onInterrupt(() =>
*     Console.log("task1 interrupted").pipe(Effect.delay("100 millis"))
*   )
* )
* const task2 = Effect.succeed("task2").pipe(
*   Effect.delay("200 millis"),
*   Effect.tap(Console.log("task2 done")),
*   Effect.onInterrupt(() =>
*     Console.log("task2 interrupted").pipe(Effect.delay("100 millis"))
*   )
* )
*
* const program = Effect.raceFirst(task1, task2).pipe(
*   Effect.tap(Console.log("more work..."))
* )
*
* Effect.runPromiseExit(program).then(console.log)
* // Output:
* // task1 done
* // task2 interrupted
* // more work...
* // { _id: 'Exit', _tag: 'Success', value: 'task1' }
* ```
*
* **Example** (One Task Fails, One Succeeds)
*
* ```ts
* import { Effect, Console } from "effect"
*
* const task1 = Effect.fail("task1").pipe(
*   Effect.delay("100 millis"),
*   Effect.tap(Console.log("task1 done")),
*   Effect.onInterrupt(() =>
*     Console.log("task1 interrupted").pipe(Effect.delay("100 millis"))
*   )
* )
* const task2 = Effect.succeed("task2").pipe(
*   Effect.delay("200 millis"),
*   Effect.tap(Console.log("task2 done")),
*   Effect.onInterrupt(() =>
*     Console.log("task2 interrupted").pipe(Effect.delay("100 millis"))
*   )
* )
*
* const program = Effect.raceFirst(task1, task2).pipe(
*   Effect.tap(Console.log("more work..."))
* )
*
* Effect.runPromiseExit(program).then(console.log)
* // Output:
* // task2 interrupted
* // {
* //   _id: 'Exit',
* //   _tag: 'Failure',
* //   cause: { _id: 'Cause', _tag: 'Fail', failure: 'task1' }
* // }
* ```
*
* **Example** (Using Effect.disconnect for Quicker Return)
*
* ```ts
* import { Effect, Console } from "effect"
*
* const task1 = Effect.succeed("task1").pipe(
*   Effect.delay("100 millis"),
*   Effect.tap(Console.log("task1 done")),
*   Effect.onInterrupt(() =>
*     Console.log("task1 interrupted").pipe(Effect.delay("100 millis"))
*   )
* )
* const task2 = Effect.succeed("task2").pipe(
*   Effect.delay("200 millis"),
*   Effect.tap(Console.log("task2 done")),
*   Effect.onInterrupt(() =>
*     Console.log("task2 interrupted").pipe(Effect.delay("100 millis"))
*   )
* )
*
* // Race the two tasks with disconnect to allow quicker return
* const program = Effect.raceFirst(
*   Effect.disconnect(task1),
*   Effect.disconnect(task2)
* ).pipe(Effect.tap(Console.log("more work...")))
*
* Effect.runPromiseExit(program).then(console.log)
* // Output:
* // task1 done
* // more work...
* // { _id: 'Exit', _tag: 'Success', value: 'task1' }
* // task2 interrupted
* ```
*
* @since 2.0.0
* @category Racing
*/
const raceFirst = raceFirst$1;
/**
* Races two effects and calls a finisher when the first one completes.
*
* **Details**
*
* This function runs two effects concurrently and calls a specified “finisher”
* function once one of the effects completes, regardless of whether it succeeds
* or fails.
*
* The finisher functions for each effect allow you to handle the results of
* each effect as soon as they complete.
*
* The function takes two finisher callbacks, one for each effect, and allows
* you to specify how to handle the result of the race.
*
* **When to Use**
*
* This function is useful when you need to react to the completion of either
* effect without waiting for both to finish. It can be used whenever you want
* to take action based on the first available result.
*
* **Example** (Handling Results of Concurrent Tasks)
*
* ```ts
* import { Effect, Console } from "effect"
*
* const task1 = Effect.succeed("task1").pipe(
*   Effect.delay("100 millis"),
*   Effect.tap(Console.log("task1 done")),
*   Effect.onInterrupt(() =>
*     Console.log("task1 interrupted").pipe(Effect.delay("100 millis"))
*   )
* )
* const task2 = Effect.succeed("task2").pipe(
*   Effect.delay("200 millis"),
*   Effect.tap(Console.log("task2 done")),
*   Effect.onInterrupt(() =>
*     Console.log("task2 interrupted").pipe(Effect.delay("100 millis"))
*   )
* )
*
* const program = Effect.raceWith(task1, task2, {
*   onSelfDone: (exit) => Console.log(`task1 exited with ${exit}`),
*   onOtherDone: (exit) => Console.log(`task2 exited with ${exit}`)
* })
*
* Effect.runFork(program)
* // Output:
* // task1 done
* // task1 exited with {
* //   "_id": "Exit",
* //   "_tag": "Success",
* //   "value": "task1"
* // }
* // task2 interrupted
* ```
*
* @since 2.0.0
* @category Racing
*/
const raceWith = raceWith$1;
/**
* Summarizes a effect by computing some value before and after execution, and
* then combining the values to produce a summary, together with the result of
* execution.
*
* @since 2.0.0
* @category Sequencing
*/
const summarized = summarized$1;
/**
* Runs a side effect with the result of an effect without changing the original
* value.
*
* **Details**
*
* This function works similarly to `flatMap`, but it ignores the result of the
* function passed to it. The value from the previous effect remains available
* for the next part of the chain. Note that if the side effect fails, the
* entire chain will fail too.
*
* **When to Use**
*
* Use this function when you want to perform a side effect, like logging or
* tracking, without modifying the main value. This is useful when you need to
* observe or record an action but want the original value to be passed to the
* next step.
*
* **Example** (Logging a step in a pipeline)
*
* ```ts
* import { Console, Effect, pipe } from "effect"
*
* // Function to apply a discount safely to a transaction amount
* const applyDiscount = (
*   total: number,
*   discountRate: number
* ): Effect.Effect<number, Error> =>
*   discountRate === 0
*     ? Effect.fail(new Error("Discount rate cannot be zero"))
*     : Effect.succeed(total - (total * discountRate) / 100)
*
* // Simulated asynchronous task to fetch a transaction amount from database
* const fetchTransactionAmount = Effect.promise(() => Promise.resolve(100))
*
* const finalAmount = pipe(
*   fetchTransactionAmount,
*   // Log the fetched transaction amount
*   Effect.tap((amount) => Console.log(`Apply a discount to: ${amount}`)),
*   // `amount` is still available!
*   Effect.flatMap((amount) => applyDiscount(amount, 5))
* )
*
* Effect.runPromise(finalAmount).then(console.log)
* // Output:
* // Apply a discount to: 100
* // 95
* ```
*
* @see {@link flatMap} for a version that allows you to change the value.
*
* @since 2.0.0
* @category Sequencing
*/
const tap = tap$1;
/**
* Allows you to inspect both success and failure outcomes of an effect and
* perform side effects for each.
*
* **Details**
*
* This function enables you to handle both success and failure cases
* separately, without modifying the main effect's result. It is particularly
* useful for scenarios where you need to log, monitor, or perform additional
* actions depending on whether the effect succeeded or failed.
*
* When the effect succeeds, the `onSuccess` handler is executed with the
* success value. When the effect fails, the `onFailure` handler is executed
* with the failure value. Both handlers can include side effects such as
* logging or analytics, and neither modifies the original effect's output.
*
* If either the success or failure handler fails, the overall effect will also
* fail.
*
* **Example**
*
* ```ts
* import { Effect, Random, Console } from "effect"
*
* // Simulate a task that might fail
* const task = Effect.filterOrFail(
*   Random.nextRange(-1, 1),
*   (n) => n >= 0,
*   () => "random number is negative"
* )
*
* // Use tapBoth to log both success and failure outcomes
* const tapping = Effect.tapBoth(task, {
*   onFailure: (error) => Console.log(`failure: ${error}`),
*   onSuccess: (randomNumber) =>
*     Console.log(`random number: ${randomNumber}`)
* })
*
* Effect.runFork(tapping)
* // Example Output:
* // failure: random number is negative
* ```
*
* @since 2.0.0
* @category Sequencing
*/
const tapBoth = tapBoth$1;
/**
* Inspect severe errors or defects (non-recoverable failures) in an effect.
*
* **Details**
*
* This function is specifically designed to handle and inspect defects, which
* are critical failures in your program, such as unexpected runtime exceptions
* or system-level errors. Unlike normal recoverable errors, defects typically
* indicate serious issues that cannot be addressed through standard error
* handling.
*
* When a defect occurs in an effect, the function you provide to this function
* will be executed, allowing you to log, monitor, or handle the defect in some
* way. Importantly, this does not alter the main result of the effect. If no
* defect occurs, the effect behaves as if this function was not used.
*
* **Example**
*
* ```ts
* import { Effect, Console } from "effect"
*
* // Simulate a task that fails with a recoverable error
* const task1: Effect.Effect<number, string> = Effect.fail("NetworkError")
*
* // tapDefect won't log anything because NetworkError is not a defect
* const tapping1 = Effect.tapDefect(task1, (cause) =>
*   Console.log(`defect: ${cause}`)
* )
*
* Effect.runFork(tapping1)
* // No Output
*
* // Simulate a severe failure in the system
* const task2: Effect.Effect<number, string> = Effect.dieMessage(
*   "Something went wrong"
* )
*
* // Log the defect using tapDefect
* const tapping2 = Effect.tapDefect(task2, (cause) =>
*   Console.log(`defect: ${cause}`)
* )
*
* Effect.runFork(tapping2)
* // Output:
* // defect: RuntimeException: Something went wrong
* //   ... stack trace ...
* ```
*
* @since 2.0.0
* @category Sequencing
*/
const tapDefect = tapDefect$1;
/**
* Execute a side effect on failure without modifying the original effect.
*
* **Details**
*
* This function allows you to inspect and react to the failure of an effect by
* executing an additional effect. The failure value is passed to the provided
* function, enabling you to log it, track it, or perform any other operation.
* Importantly, the original failure remains intact and is re-propagated, so the
* effect's behavior is unchanged.
*
* The side effect you provide is only executed when the effect fails. If the
* effect succeeds, the function is ignored, and the success value is propagated
* as usual.
*
* **Example**
*
* ```ts
* import { Effect, Console } from "effect"
*
* // Simulate a task that fails with an error
* const task: Effect.Effect<number, string> = Effect.fail("NetworkError")
*
* // Use tapError to log the error message when the task fails
* const tapping = Effect.tapError(task, (error) =>
*   Console.log(`expected error: ${error}`)
* )
*
* Effect.runFork(tapping)
* // Output:
* // expected error: NetworkError
* ```
*
* @since 2.0.0
* @category Sequencing
*/
const tapError = tapError$1;
/**
* Inspect errors matching a specific tag without altering the original effect.
*
* **Details**
*
* This function allows you to inspect and handle specific error types based on
* their `_tag` property. It is particularly useful in applications where errors
* are modeled with tagged types (e.g., union types with discriminating tags).
* By targeting errors with a specific `_tag`, you can log or perform actions on
* them while leaving the error channel and overall effect unchanged.
*
* If the error doesn't match the specified tag, this function does nothing, and
* the effect proceeds as usual.
*
* **Example**
*
* ```ts
* import { Effect, Console } from "effect"
*
* class NetworkError {
*   readonly _tag = "NetworkError"
*   constructor(readonly statusCode: number) {}
* }
*
* class ValidationError {
*   readonly _tag = "ValidationError"
*   constructor(readonly field: string) {}
* }
*
* // Create a task that fails with a NetworkError
* const task: Effect.Effect<number, NetworkError | ValidationError> =
*   Effect.fail(new NetworkError(504))
*
* // Use tapErrorTag to inspect only NetworkError types and log the status code
* const tapping = Effect.tapErrorTag(task, "NetworkError", (error) =>
*   Console.log(`expected error: ${error.statusCode}`)
* )
*
* Effect.runFork(tapping)
* // Output:
* // expected error: 504
* ```
*
* @since 2.0.0
* @category Sequencing
*/
const tapErrorTag = tapErrorTag$1;
/**
* Inspect the complete cause of an error, including failures and defects.
*
* **Details**
*
* This function provides access to the full cause of an error, including both
* recoverable failures and irrecoverable defects. It allows you to handle, log,
* or monitor specific error causes without modifying the result of the effect.
* The full `Cause` object encapsulates the error and its contextual
* information, making it useful for debugging and understanding failure
* scenarios in complex workflows.
*
* The effect itself is not modified, and any errors or defects remain in the
* error channel of the original effect.
*
* **Example**
*
* ```ts
* import { Effect, Console } from "effect"
*
* // Create a task that fails with a NetworkError
* const task1: Effect.Effect<number, string> = Effect.fail("NetworkError")
*
* const tapping1 = Effect.tapErrorCause(task1, (cause) =>
*   Console.log(`error cause: ${cause}`)
* )
*
* Effect.runFork(tapping1)
* // Output:
* // error cause: Error: NetworkError
*
* // Simulate a severe failure in the system
* const task2: Effect.Effect<number, string> = Effect.dieMessage(
*   "Something went wrong"
* )
*
* const tapping2 = Effect.tapErrorCause(task2, (cause) =>
*   Console.log(`error cause: ${cause}`)
* )
*
* Effect.runFork(tapping2)
* // Output:
* // error cause: RuntimeException: Something went wrong
* //   ... stack trace ...
* ```
*
* @since 2.0.0
* @category Sequencing
*/
const tapErrorCause = tapErrorCause$1;
/**
* Repeats an effect indefinitely until an error occurs.
*
* **Details**
*
* This function executes an effect repeatedly in an infinite loop. Each
* iteration is executed sequentially, and the loop continues until the first
* error occurs. If the effect succeeds, it starts over from the beginning. If
* the effect fails, the error is propagated, and the loop stops.
*
* Be cautious when using this function, as it will run indefinitely unless an
* error interrupts it. This makes it suitable for long-running processes or
* continuous polling tasks, but you should ensure proper error handling or
* combine it with other operators like `timeout` or `schedule` to prevent
* unintentional infinite loops.
*
* @since 2.0.0
* @category Repetition / Recursion
*/
const forever = forever$2;
/**
* Repeatedly updates a state through an effectful operation until a condition
* is no longer met.
*
* **Details**
*
* This function provides a way to implement effectful loops, similar to a
* `while` loop in JavaScript.
*
* ```ts skip-type-checking
* let result = initial
*
* while (options.while(result)) {
*   result = options.body(result)
* }
*
* return result
* ```
*
* It starts with an initial state, checks a
* condition (`while`), and executes a body operation to update the state if the
* condition evaluates to `true`. The process repeats until the condition
* returns `false`.
*
* The state is passed between iterations, allowing the body operation to modify
* it dynamically. The final state after the loop ends is returned as the result
* of the effect.
*
* **When to Use**
*
* This is particularly useful for scenarios where looping logic involves
* asynchronous or side-effectful operations, such as polling or iterative
* computations that depend on external factors.
*
* **Example** (Effectful Iteration)
*
* ```ts
* import { Effect } from "effect"
*
* const result = Effect.iterate(
*   // Initial result
*   1,
*   {
*     // Condition to continue iterating
*     while: (result) => result <= 5,
*     // Operation to change the result
*     body: (result) => Effect.succeed(result + 1)
*   }
* )
*
* Effect.runPromise(result).then(console.log)
* // Output: 6
* ```
*
* @since 2.0.0
* @category Looping
*/
const iterate = iterate$1;
/**
* Repeatedly executes a loop with a state, collecting results or discarding
* them based on configuration.
*
* **Details**
*
* This function performs an effectful loop, starting with an initial state and
* iterating as long as the `while` condition evaluates to `true`, similar to a
* `while` loop in JavaScript.
*
* ```ts skip-type-checking
* let state = initial
* const result = []
*
* while (options.while(state)) {
*   result.push(options.body(state)) // Perform the effectful operation
*   state = options.step(state) // Update the state
* }
*
* return result
* ```
*
* During each iteration, the `step` function updates the state, and the `body`
* effect is executed.
*
* The results of the body effect can be collected in an array or discarded
* based on the `discard` option.
*
* **Discarding Intermediate Results**
*
* - If `discard` is `false` or not provided, the intermediate results are
*   collected into an array and returned as the final result.
* - If `discard` is `true`, the intermediate results are ignored, and the
*   effect returns `void`.
*
* **When to Use**
*
* This is useful for implementing loops where you need to perform effectful
* computations repeatedly, such as processing items in a list, generating
* values, or performing iterative updates.
*
* **Example** (Looping with Collected Results)
*
* ```ts
* import { Effect } from "effect"
*
* // A loop that runs 5 times, collecting each iteration's result
* const result = Effect.loop(
*   // Initial state
*   1,
*   {
*     // Condition to continue looping
*     while: (state) => state <= 5,
*     // State update function
*     step: (state) => state + 1,
*     // Effect to be performed on each iteration
*     body: (state) => Effect.succeed(state)
*   }
* )
*
* Effect.runPromise(result).then(console.log)
* // Output: [1, 2, 3, 4, 5]
* ```
*
* **Example** (Loop with Discarded Results)
*
* ```ts
* import { Effect, Console } from "effect"
*
* const result = Effect.loop(
*   // Initial state
*   1,
*   {
*     // Condition to continue looping
*     while: (state) => state <= 5,
*     // State update function
*     step: (state) => state + 1,
*     // Effect to be performed on each iteration
*     body: (state) => Console.log(`Currently at state ${state}`),
*     // Discard intermediate results
*     discard: true
*   }
* )
*
* Effect.runPromise(result).then(console.log)
* // Output:
* // Currently at state 1
* // Currently at state 2
* // Currently at state 3
* // Currently at state 4
* // Currently at state 5
* // undefined
* ```
*
* @since 2.0.0
* @category Looping
*/
const loop = loop$1;
/**
* Repeats an effect based on a specified schedule or until the first failure.
*
* **Details**
*
* This function executes an effect repeatedly according to the given schedule.
* Each repetition occurs after the initial execution of the effect, meaning
* that the schedule determines the number of additional repetitions. For
* example, using `Schedule.once` will result in the effect being executed twice
* (once initially and once as part of the repetition).
*
* If the effect succeeds, it is repeated according to the schedule. If it
* fails, the repetition stops immediately, and the failure is returned.
*
* The schedule can also specify delays between repetitions, making it useful
* for tasks like retrying operations with backoff, periodic execution, or
* performing a series of dependent actions.
*
* You can combine schedules for more advanced repetition logic, such as adding
* delays, limiting recursions, or dynamically adjusting based on the outcome of
* each execution.
*
* **Example** (Success Example)
*
* ```ts
* import { Effect, Schedule, Console } from "effect"
*
* const action = Console.log("success")
* const policy = Schedule.addDelay(Schedule.recurs(2), () => "100 millis")
* const program = Effect.repeat(action, policy)
*
* Effect.runPromise(program).then((n) => console.log(`repetitions: ${n}`))
* ```
*
* **Example** (Failure Example)
*
* ```ts
* import { Effect, Schedule } from "effect"
*
* let count = 0
*
* // Define an async effect that simulates an action with possible failures
* const action = Effect.async<string, string>((resume) => {
*   if (count > 1) {
*     console.log("failure")
*     resume(Effect.fail("Uh oh!"))
*   } else {
*     count++
*     console.log("success")
*     resume(Effect.succeed("yay!"))
*   }
* })
*
* const policy = Schedule.addDelay(Schedule.recurs(2), () => "100 millis")
* const program = Effect.repeat(action, policy)
*
* Effect.runPromiseExit(program).then(console.log)
* ```
*
* @since 2.0.0
* @category Repetition / Recursion
*/
const repeat = repeat_combined;
/**
* Repeats an effect a specified number of times or until the first failure.
*
* **Details**
*
* This function executes an effect initially and then repeats it the specified
* number of times, as long as it succeeds. For example, calling
* `repeatN(action, 2)` will execute `action` once initially and then repeat it
* two additional times if there are no failures.
*
* If the effect fails during any repetition, the failure is returned, and no
* further repetitions are attempted.
*
* **When to Use**
*
* This function is useful for tasks that need to be retried a fixed number of
* times or for performing repeated actions without requiring a schedule.
*
* **Example**
*
* ```ts
* import { Effect, Console } from "effect"
*
* const action = Console.log("success")
* const program = Effect.repeatN(action, 2)
*
* Effect.runPromise(program)
* ```
*
* @since 2.0.0
* @category Repetition / Recursion
*/
const repeatN = repeatN$1;
/**
* Repeats an effect with a schedule, handling failures using a custom handler.
*
* **Details**
*
* This function allows you to execute an effect repeatedly based on a specified
* schedule. If the effect fails at any point, a custom failure handler is
* invoked. The handler is provided with both the failure value and the output
* of the schedule at the time of failure. This enables advanced error recovery
* or alternative fallback logic while maintaining flexibility in how
* repetitions are handled.
*
* For example, using a schedule with `recurs(2)` will allow for two additional
* repetitions after the initial execution, provided the effect succeeds. If a
* failure occurs during any iteration, the failure handler is invoked to handle
* the situation.
*
* **Example**
*
* ```ts
* import { Effect, Schedule } from "effect"
*
* let count = 0
*
* // Define an async effect that simulates an action with possible failures
* const action = Effect.async<string, string>((resume) => {
*   if (count > 1) {
*     console.log("failure")
*     resume(Effect.fail("Uh oh!"))
*   } else {
*     count++
*     console.log("success")
*     resume(Effect.succeed("yay!"))
*   }
* })
*
* const policy = Schedule.addDelay(
*   Schedule.recurs(2), // Repeat for a maximum of 2 times
*   () => "100 millis" // Add a delay of 100 milliseconds between repetitions
* )
*
* const program = Effect.repeatOrElse(action, policy, () =>
*   Effect.sync(() => {
*     console.log("orElse")
*     return count - 1
*   })
* )
*
* Effect.runPromise(program).then((n) => console.log(`repetitions: ${n}`))
* ```
*
* @since 2.0.0
* @category Repetition / Recursion
*/
const repeatOrElse = repeatOrElse_Effect;
/**
* Repeats an effect based on a specified schedule.
*
* **Details**
*
* This function allows you to execute an effect repeatedly according to a given
* schedule. The schedule determines the timing and number of repetitions. Each
* repetition can also depend on the decision of the schedule, providing
* flexibility for complex workflows. This function does not modify the effect's
* success or failure; it only controls its repetition.
*
* For example, you can use a schedule that recurs a specific number of times,
* adds delays between repetitions, or customizes repetition behavior based on
* external inputs. The effect runs initially and is repeated according to the
* schedule.
*
* @see {@link scheduleFrom} for a variant that allows the schedule's decision
* to depend on the result of this effect.
*
* @since 2.0.0
* @category Repetition / Recursion
*/
const schedule = schedule_Effect;
/**
* Runs an effect repeatedly on a new fiber according to a given schedule.
*
* **Details**
*
* This function starts the provided effect on a new fiber and runs it
* repeatedly based on the specified schedule. The repetitions are managed by
* the schedule's rules, which define the timing and number of iterations. The
* fiber is attached to the current scope, meaning it is automatically managed
* and cleaned up when the scope is closed.
*
* The function returns a `RuntimeFiber` that allows you to monitor or interact
* with the running fiber.
*
* **When to Use**
*
* This is particularly useful for concurrent execution of scheduled tasks or
* when you want to continue processing without waiting for the repetitions to
* complete.
*
* @since 2.0.0
* @category Repetition / Recursion
*/
const scheduleForked = scheduleForked$1;
/**
* Runs an effect repeatedly according to a schedule, starting from a specified
* input value.
*
* **Details**
*
* This function allows you to repeatedly execute an effect based on a schedule.
* The schedule starts with the given `initial` input value, which is passed to
* the first execution. Subsequent executions of the effect are controlled by
* the schedule's rules, using the output of the previous iteration as the input
* for the next one.
*
* The returned effect will complete when the schedule ends or the effect fails,
* propagating the error.
*
* @since 2.0.0
* @category Repetition / Recursion
*/
const scheduleFrom = scheduleFrom_Effect;
/**
* @since 2.0.0
* @category Repetition / Recursion
*/
const whileLoop = whileLoop$2;
/**
* Returns a collection of all `FiberRef` values for the fiber running this
* effect.
*
* @since 2.0.0
* @category Fiber Refs
*/
const getFiberRefs = fiberRefs;
/**
* Inherits values from all `FiberRef` instances into current fiber.
*
* @since 2.0.0
* @category Fiber Refs
*/
const inheritFiberRefs = inheritFiberRefs$1;
/**
* @since 2.0.0
* @category Fiber Refs
*/
const locally = fiberRefLocally;
/**
* @since 2.0.0
* @category Fiber Refs
*/
const locallyWith = fiberRefLocallyWith;
/**
* @since 2.0.0
* @category Fiber Refs
*/
const locallyScoped = fiberRefLocallyScoped;
/**
* @since 2.0.0
* @category Fiber Refs
*/
const locallyScopedWith = fiberRefLocallyScopedWith;
/**
* Applies the specified changes to the `FiberRef` values for the fiber
* running this workflow.
*
* @since 2.0.0
* @category Fiber Refs
*/
const patchFiberRefs = patchFiberRefs$1;
/**
* Sets the `FiberRef` values for the fiber running this effect to the values
* in the specified collection of `FiberRef` values.
*
* @since 2.0.0
* @category Fiber Refs
*/
const setFiberRefs = setFiberRefs$1;
/**
* Updates the `FiberRef` values for the fiber running this effect using the
* specified function.
*
* @since 2.0.0
* @category Fiber Refs
*/
const updateFiberRefs = updateFiberRefs$1;
/**
* Checks if an effect has failed.
*
* **Details**
*
* This function evaluates whether an effect has resulted in a failure. It
* returns a boolean value wrapped in an effect, with `true` indicating the
* effect failed and `false` otherwise.
*
* The resulting effect cannot fail (`never` in the error channel) but retains
* the context of the original effect.
*
* **Example**
*
* ```ts
* import { Effect } from "effect"
*
* const failure = Effect.fail("Uh oh!")
*
* console.log(Effect.runSync(Effect.isFailure(failure)))
* // Output: true
*
* const defect = Effect.dieMessage("BOOM!")
*
* Effect.runSync(Effect.isFailure(defect))
* // throws: BOOM!
* ```
*
* @since 2.0.0
* @category Condition Checking
*/
const isFailure = isFailure$2;
/**
* Checks if an effect has succeeded.
*
* **Details**
*
* This function evaluates whether an effect has resulted in a success. It
* returns a boolean value wrapped in an effect, with `true` indicating the
* effect succeeded and `false` otherwise.
*
* The resulting effect cannot fail (`never` in the error channel) but retains
* the context of the original effect.
*
* @since 2.0.0
* @category Condition Checking
*/
const isSuccess = isSuccess$2;
/**
* Handles both success and failure cases of an effect without performing side
* effects.
*
* **Details**
*
* `match` lets you define custom handlers for both success and failure
* scenarios. You provide separate functions to handle each case, allowing you
* to process the result if the effect succeeds, or handle the error if the
* effect fails.
*
* **When to Use**
*
* This is useful for structuring your code to respond differently to success or
* failure without triggering side effects.
*
* **Example** (Handling Both Success and Failure Cases)
*
* ```ts
* import { Effect } from "effect"
*
* const success: Effect.Effect<number, Error> = Effect.succeed(42)
*
* const program1 = Effect.match(success, {
*   onFailure: (error) => `failure: ${error.message}`,
*   onSuccess: (value) => `success: ${value}`
* })
*
* // Run and log the result of the successful effect
* Effect.runPromise(program1).then(console.log)
* // Output: "success: 42"
*
* const failure: Effect.Effect<number, Error> = Effect.fail(
*   new Error("Uh oh!")
* )
*
* const program2 = Effect.match(failure, {
*   onFailure: (error) => `failure: ${error.message}`,
*   onSuccess: (value) => `success: ${value}`
* })
*
* // Run and log the result of the failed effect
* Effect.runPromise(program2).then(console.log)
* // Output: "failure: Uh oh!"
* ```
*
* @see {@link matchEffect} if you need to perform side effects in the handlers.
*
* @since 2.0.0
* @category Matching
*/
const match = match$4;
/**
* Handles failures by matching the cause of failure.
*
* **Details**
*
* The `matchCause` function allows you to handle failures with access to the
* full cause of the failure within a fiber.
*
* **When to Use**
*
* This is useful for differentiating between different types of errors, such as
* regular failures, defects, or interruptions. You can provide specific
* handling logic for each failure type based on the cause.
*
* **Example** (Handling Different Failure Causes)
*
* ```ts
* import { Effect } from "effect"
*
* const task: Effect.Effect<number, Error> = Effect.die("Uh oh!")
*
* const program = Effect.matchCause(task, {
*   onFailure: (cause) => {
*     switch (cause._tag) {
*       case "Fail":
*         // Handle standard failure
*         return `Fail: ${cause.error.message}`
*       case "Die":
*         // Handle defects (unexpected errors)
*         return `Die: ${cause.defect}`
*       case "Interrupt":
*         // Handle interruption
*         return `${cause.fiberId} interrupted!`
*     }
*     // Fallback for other causes
*     return "failed due to other causes"
*   },
*   onSuccess: (value) =>
*     // task completes successfully
*     `succeeded with ${value} value`
* })
*
* Effect.runPromise(program).then(console.log)
* // Output: "Die: Uh oh!"
* ```
*
* @see {@link matchCauseEffect} if you need to perform side effects in the
* handlers.
* @see {@link match} if you don't need to handle the cause of the failure.
*
* @since 2.0.0
* @category Matching
*/
const matchCause = matchCause$2;
/**
* Handles failures with access to the cause and allows performing side effects.
*
* **Details**
*
* The `matchCauseEffect` function works similarly to {@link matchCause}, but it
* also allows you to perform additional side effects based on the failure
* cause. This function provides access to the complete cause of the failure,
* making it possible to differentiate between various failure types, and allows
* you to respond accordingly while performing side effects (like logging or
* other operations).
*
* **Example** (Handling Different Failure Causes with Side Effects)
*
* ```ts
* import { Effect, Console } from "effect"
*
* const task: Effect.Effect<number, Error> = Effect.die("Uh oh!")
*
* const program = Effect.matchCauseEffect(task, {
*   onFailure: (cause) => {
*     switch (cause._tag) {
*       case "Fail":
*         // Handle standard failure with a logged message
*         return Console.log(`Fail: ${cause.error.message}`)
*       case "Die":
*         // Handle defects (unexpected errors) by logging the defect
*         return Console.log(`Die: ${cause.defect}`)
*       case "Interrupt":
*         // Handle interruption and log the fiberId that was interrupted
*         return Console.log(`${cause.fiberId} interrupted!`)
*     }
*     // Fallback for other causes
*     return Console.log("failed due to other causes")
*   },
*   onSuccess: (value) =>
*     // Log success if the task completes successfully
*     Console.log(`succeeded with ${value} value`)
* })
*
* Effect.runPromise(program)
* // Output: "Die: Uh oh!"
* ```
*
* @see {@link matchCause} if you don't need side effects and only want to handle the result or failure.
* @see {@link matchEffect} if you don't need to handle the cause of the failure.
*
* @since 2.0.0
* @category Matching
*/
const matchCauseEffect = matchCauseEffect$2;
/**
* Handles both success and failure cases of an effect, allowing for additional
* side effects.
*
* **Details**
*
* The `matchEffect` function is similar to {@link match}, but it enables you to
* perform side effects in the handlers for both success and failure outcomes.
*
* **When to Use**
*
* This is useful when you need to execute additional actions, like logging or
* notifying users, based on whether an effect succeeds or fails.
*
* **Example** (Handling Both Success and Failure Cases with Side Effects)
*
* ```ts
* import { Effect } from "effect"
*
* const success: Effect.Effect<number, Error> = Effect.succeed(42)
* const failure: Effect.Effect<number, Error> = Effect.fail(
*   new Error("Uh oh!")
* )
*
* const program1 = Effect.matchEffect(success, {
*   onFailure: (error) =>
*     Effect.succeed(`failure: ${error.message}`).pipe(
*       Effect.tap(Effect.log)
*     ),
*   onSuccess: (value) =>
*     Effect.succeed(`success: ${value}`).pipe(Effect.tap(Effect.log))
* })
*
* console.log(Effect.runSync(program1))
* // Output:
* // timestamp=... level=INFO fiber=#0 message="success: 42"
* // success: 42
*
* const program2 = Effect.matchEffect(failure, {
*   onFailure: (error) =>
*     Effect.succeed(`failure: ${error.message}`).pipe(
*       Effect.tap(Effect.log)
*     ),
*   onSuccess: (value) =>
*     Effect.succeed(`success: ${value}`).pipe(Effect.tap(Effect.log))
* })
*
* console.log(Effect.runSync(program2))
* // Output:
* // timestamp=... level=INFO fiber=#1 message="failure: Uh oh!"
* // failure: Uh oh!
* ```
*
* @see {@link match} if you don't need side effects and only want to handle the
* result or failure.
*
* @since 2.0.0
* @category Matching
*/
const matchEffect = matchEffect$2;
/**
* Logs one or more messages or error causes at the current log level.
*
* **Details**
*
* This function provides a simple way to log messages or error causes during
* the execution of your effects. By default, logs are recorded at the `INFO`
* level, but this can be adjusted using other logging utilities
* (`Logger.withMinimumLogLevel`). Multiple items, including `Cause` instances,
* can be logged in a single call. When logging `Cause` instances, detailed
* error information is included in the log output.
*
* The log output includes useful metadata like the current timestamp, log
* level, and fiber ID, making it suitable for debugging and tracking purposes.
* This function does not interrupt or alter the effect's execution flow.
*
* **Example**
*
* ```ts
* import { Cause, Effect } from "effect"
*
* const program = Effect.log(
*   "message1",
*   "message2",
*   Cause.die("Oh no!"),
*   Cause.die("Oh uh!")
* )
*
* Effect.runFork(program)
* // Output:
* // timestamp=... level=INFO fiber=#0 message=message1 message=message2 cause="Error: Oh no!
* // Error: Oh uh!"
* ```
*
* @since 2.0.0
* @category Logging
*/
const log = log$1;
/**
* Logs messages at the TRACE log level.
*
* **Details**
*
* This function logs the specified messages at the TRACE level. TRACE logs are
* typically used for very detailed diagnostic information. These messages are
* not displayed by default. To view them, you must adjust the logging
* configuration by setting the minimum log level to `LogLevel.Trace` using
* `Logger.withMinimumLogLevel`.
*
* **Example**
*
* ```ts
* import { Effect, Logger, LogLevel } from "effect"
*
* const program = Effect.logTrace("message1").pipe(Logger.withMinimumLogLevel(LogLevel.Trace))
*
* Effect.runFork(program)
* // timestamp=... level=TRACE fiber=#0 message=message1
* ```
*
* @since 2.0.0
* @category Logging
*/
const logTrace = logTrace$1;
/**
* Logs messages at the DEBUG log level.
*
* **Details**
*
* This function logs messages at the DEBUG level, which is typically used for
* diagnosing application behavior during development. DEBUG messages provide
* less detailed information than TRACE logs but are still not shown by default.
* To view these logs, adjust the log level using `Logger.withMinimumLogLevel`.
*
* **Example**
*
* ```ts
* import { Effect, Logger, LogLevel } from "effect"
*
* const program = Effect.logDebug("message1").pipe(Logger.withMinimumLogLevel(LogLevel.Debug))
*
* Effect.runFork(program)
* // timestamp=... level=DEBUG fiber=#0 message=message1
* ```
*
* @since 2.0.0
* @category Logging
*/
const logDebug = logDebug$1;
/**
* Logs messages at the INFO log level.
*
* **Details**
*
* This function logs messages at the INFO level, suitable for general
* application events or operational messages. INFO logs are shown by default
* and are commonly used for highlighting normal, non-error operations.
*
* @since 2.0.0
* @category Logging
*/
const logInfo = logInfo$1;
/**
* Logs messages at the WARNING log level.
*
* **Details**
*
* This function logs messages at the WARNING level, suitable for highlighting
* potential issues that are not errors but may require attention. These
* messages indicate that something unexpected occurred or might lead to errors
* in the future.
*
* @since 2.0.0
* @category Logging
*/
const logWarning = logWarning$1;
/**
* Logs messages at the ERROR log level.
*
* **Details**
*
* This function logs messages at the ERROR level, suitable for reporting
* application errors or failures. These logs are typically used for unexpected
* issues that need immediate attention.
*
* @since 2.0.0
* @category Logging
*/
const logError = logError$1;
/**
* Logs messages at the FATAL log level.
*
* **Details**
*
* This function logs messages at the FATAL level, suitable for reporting
* critical errors that cause the application to terminate or stop functioning.
* These logs are typically used for unrecoverable errors that require immediate
* attention.
*
* @since 2.0.0
* @category Logging
*/
const logFatal = logFatal$1;
/**
* Adds a log span to an effect for tracking and logging its execution duration.
*
* **Details**
*
* This function wraps an effect with a log span, providing performance
* monitoring and debugging capabilities. The log span tracks the duration of
* the wrapped effect and logs it with the specified label. This is particularly
* useful when analyzing time-sensitive operations or understanding the
* execution time of specific tasks in your application.
*
* The logged output will include the label and the total time taken for the
* operation. The span information is included in the log metadata, making it
* easy to trace performance metrics in logs.
*
* **Example**
*
* ```ts
* import { Effect } from "effect"
*
* const program = Effect.gen(function*() {
*   yield* Effect.sleep("1 second")
*   yield* Effect.log("The job is finished!")
* }).pipe(Effect.withLogSpan("myspan"))
*
* Effect.runFork(program)
* // timestamp=... level=INFO fiber=#0 message="The job is finished!" myspan=1011ms
* ```
*
* @since 2.0.0
* @category Logging
*/
const withLogSpan = withLogSpan$1;
/**
* Adds custom annotations to log entries generated within an effect.
*
* **Details**
*
* This function allows you to enhance log messages by appending additional
* context in the form of key-value pairs. These annotations are included in
* every log message created during the execution of the effect, making the logs
* more informative and easier to trace.
*
* The annotations can be specified as a single key-value pair or as a record of
* multiple key-value pairs. This is particularly useful for tracking
* operations, debugging, or associating specific metadata with logs for better
* observability.
*
* The annotated key-value pairs will appear alongside the log message in the
* output.
*
* **Example**
*
* ```ts
* import { Effect } from "effect"
*
* const program = Effect.gen(function*() {
*   yield* Effect.log("message1")
*   yield* Effect.log("message2")
* }).pipe(Effect.annotateLogs("taskId", "1234")) // Annotation as key/value pair
*
* Effect.runFork(program)
* // timestamp=... level=INFO fiber=#0 message=message1 taskId=1234
* // timestamp=... level=INFO fiber=#0 message=message2 taskId=1234
* ```
*
* @see {@link annotateLogsScoped} to add log annotations with a limited scope.
*
* @since 2.0.0
* @category Logging
*/
const annotateLogs = annotateLogs$1;
/**
* Adds log annotations with a limited scope to enhance contextual logging.
*
* **Details**
*
* This function allows you to apply key-value annotations to log entries
* generated within a specific scope of your effect computations. The
* annotations are restricted to the defined `Scope`, ensuring that they are
* only applied to logs produced during that scope. Once the scope ends, the
* annotations are automatically removed, making it easier to manage
* context-specific logging without affecting other parts of your application.
*
* The annotations can be provided as a single key-value pair or as a record of
* multiple key-value pairs. This flexibility enables fine-grained control over
* the additional metadata included in logs for specific tasks or operations.
*
* **Example**
*
* ```ts
* import { Effect } from "effect"
*
* const program = Effect.gen(function*() {
*   yield* Effect.log("no annotations")
*   yield* Effect.annotateLogsScoped({ key: "value" })
*   yield* Effect.log("message1") // Annotation is applied to this log
*   yield* Effect.log("message2") // Annotation is applied to this log
* }).pipe(Effect.scoped, Effect.andThen(Effect.log("no annotations again")))
*
* Effect.runFork(program)
* // timestamp=... level=INFO fiber=#0 message="no annotations"
* // timestamp=... level=INFO fiber=#0 message=message1 key=value
* // timestamp=... level=INFO fiber=#0 message=message2 key=value
* // timestamp=... level=INFO fiber=#0 message="no annotations again"
* ```
*
* @see {@link annotateLogs} to add custom annotations to log entries generated within an effect.
*
* @since 3.1.0
* @category Logging
*/
const annotateLogsScoped = annotateLogsScoped$1;
/**
* Retrieves the current log annotations for the current scope.
*
* **Details**
*
* This function provides access to the log annotations associated with the
* current scope. Log annotations are key-value pairs that provide additional
* context to log entries. They are often used to add metadata such as tags,
* identifiers, or extra debugging information to logs.
*
* By using this function, you can inspect or utilize the annotations applied to
* the current scope, making it easier to trace and debug specific sections of
* your application.
*
* @see {@link annotateLogs} to add custom annotations to log entries generated within an effect.
* @see {@link annotateLogsScoped} to add log annotations with a limited scope.
*
* @since 2.0.0
* @category Logging
*/
const logAnnotations = logAnnotations$1;
/**
* Configures whether child fibers will log unhandled errors and at what log
* level.
*
* **Details**
*
* This function allows you to control whether unhandled errors from child
* fibers are logged and to specify the log level for these errors. By default,
* unhandled errors are reported via the logger. However, using this function,
* you can choose to suppress these logs by passing `Option.none` or adjust the
* log level to a specific severity, such as `Error`, `Warning`, or `Info`.
*
* This configuration is scoped to the effect it is applied to, meaning the
* changes only apply to the child fibers created within that effect's context.
* It is especially useful when you want to reduce noise in logs or prioritize
* certain types of errors.
*
* **Example**
*
* ```ts
* import { Effect, Fiber, LogLevel, Option } from "effect"
*
* const program = Effect.gen(function*() {
*   const fiber = yield* Effect.fork(Effect.fail("Unhandled error!"))
*   yield* Fiber.join(fiber)
* })
*
* Effect.runFork(program.pipe(Effect.withUnhandledErrorLogLevel(Option.some(LogLevel.Error))))
* // Output:
* // timestamp=... level=ERROR fiber=#1 message="Fiber terminated with an unhandled error" cause="Error: Unhandled error!"
* ```
*
* @since 2.0.0
* @category Logging
*/
const withUnhandledErrorLogLevel = withUnhandledErrorLogLevel$1;
/**
* Conditionally executes an effect based on the specified log level and currently enabled log level.
*
* **Details**
*
* This function runs the provided effect only if the specified log level is
* enabled. If the log level is enabled, the effect is executed and its result
* is wrapped in `Some`. If the log level is not enabled, the effect is not
* executed and `None` is returned.
*
* This function is useful for conditionally executing logging-related effects
* or other operations that depend on the current log level configuration.
*
* **Example**
*
* ```ts
* import { Effect, Logger, LogLevel } from "effect"
*
* const program = Effect.gen(function* () {
*   yield* Effect.whenLogLevel(Effect.logTrace("message1"), LogLevel.Trace); // returns `None`
*   yield* Effect.whenLogLevel(Effect.logDebug("message2"), LogLevel.Debug); // returns `Some`
* }).pipe(Logger.withMinimumLogLevel(LogLevel.Debug));
*
* Effect.runFork(program)
* // timestamp=... level=DEBUG fiber=#0 message=message2
* ```
*
* @see {@link FiberRef.currentMinimumLogLevel} to retrieve the current minimum log level.
*
* @since 3.13.0
* @category Logging
*/
const whenLogLevel = whenLogLevel$1;
/**
* Converts an effect's failure into a fiber termination, removing the error
* from the effect's type.
*
* **Details**
*
* The `orDie` function is used when you encounter errors that you do not want
* to handle or recover from. It removes the error type from the effect and
* ensures that any failure will terminate the fiber. This is useful for
* propagating failures as defects, signaling that they should not be handled
* within the effect.
*
* **When to Use*
*
* Use `orDie` when failures should be treated as unrecoverable defects and no
* error handling is required.
*
* **Example** (Propagating an Error as a Defect)
*
* ```ts
* import { Effect } from "effect"
*
* const divide = (a: number, b: number) =>
*   b === 0
*     ? Effect.fail(new Error("Cannot divide by zero"))
*     : Effect.succeed(a / b)
*
* //      ┌─── Effect<number, never, never>
* //      ▼
* const program = Effect.orDie(divide(1, 0))
*
* Effect.runPromise(program).catch(console.error)
* // Output:
* // (FiberFailure) Error: Cannot divide by zero
* //   ...stack trace...
* ```
*
* @see {@link orDieWith} if you need to customize the error.
*
* @since 2.0.0
* @category Converting Failures to Defects
*/
const orDie = orDie$1;
/**
* Converts an effect's failure into a fiber termination with a custom error.
*
* **Details**
*
* The `orDieWith` function behaves like {@link orDie}, but it allows you to provide a mapping
* function to transform the error before terminating the fiber. This is useful for cases where
* you want to include a more detailed or user-friendly error when the failure is propagated
* as a defect.
*
* **When to Use**
*
* Use `orDieWith` when failures should terminate the fiber as defects, and you want to customize
* the error for clarity or debugging purposes.
*
* **Example** (Customizing Defect)
*
* ```ts
* import { Effect } from "effect"
*
* const divide = (a: number, b: number) =>
*   b === 0
*     ? Effect.fail(new Error("Cannot divide by zero"))
*     : Effect.succeed(a / b)
*
* //      ┌─── Effect<number, never, never>
* //      ▼
* const program = Effect.orDieWith(
*   divide(1, 0),
*   (error) => new Error(`defect: ${error.message}`)
* )
*
* Effect.runPromise(program).catch(console.error)
* // Output:
* // (FiberFailure) Error: defect: Cannot divide by zero
* //   ...stack trace...
* ```
*
* @see {@link orDie} if you don't need to customize the error.
*
* @since 2.0.0
* @category Converting Failures to Defects
*/
const orDieWith = orDieWith$1;
/**
* Attempts one effect, and if it fails, falls back to another effect.
*
* **Details**
*
* This function allows you to try executing an effect, and if it fails
* (produces an error), a fallback effect is executed instead. The fallback
* effect is defined as a lazy argument, meaning it will only be evaluated if
* the first effect fails. This provides a way to recover from errors by
* specifying an alternative path of execution.
*
* The error type of the resulting effect will be that of the fallback effect,
* as the first effect's error is replaced when the fallback is executed.
*
* **Example**
*
* ```ts
* import { Effect } from "effect"
*
* const success = Effect.succeed("success")
* const failure = Effect.fail("failure")
* const fallback = Effect.succeed("fallback")
*
* // Try the success effect first, fallback is not used
* const program1 = Effect.orElse(success, () => fallback)
* console.log(Effect.runSync(program1))
* // Output: "success"
*
* // Try the failure effect first, fallback is used
* const program2 = Effect.orElse(failure, () => fallback)
* console.log(Effect.runSync(program2))
* // Output: "fallback"
* ```
*
* @see {@link catchAll} if you need to access the error in the fallback effect.
*
* @since 2.0.0
* @category Fallback
*/
const orElse$1 = orElse$4;
/**
* Replaces the failure of an effect with a custom failure value.
*
* **Details**
*
* This function allows you to handle the failure of an effect by replacing it
* with a predefined failure value. If the effect fails, the new failure value
* provided by the `evaluate` function will be returned instead of the original
* failure. If the effect succeeds, the original success value is returned
* unchanged.
*
* **When to Use**
*
* This is particularly useful when you want to standardize error handling or
* provide a consistent failure value for specific operations. It simplifies
* error management by ensuring that all failures are replaced with a controlled
* alternative.
*
* **Example**
*
* ```ts
* import { Effect } from "effect"
*
* const validate = (age: number): Effect.Effect<number, string> => {
*   if (age < 0) {
*     return Effect.fail("NegativeAgeError")
*   } else if (age < 18) {
*     return Effect.fail("IllegalAgeError")
*   } else {
*     return Effect.succeed(age)
*   }
* }
*
* const program = Effect.orElseFail(validate(-1), () => "invalid age")
*
* console.log(Effect.runSyncExit(program))
* // Output:
* // {
* //   _id: 'Exit',
* //   _tag: 'Failure',
* //   cause: { _id: 'Cause', _tag: 'Fail', failure: 'invalid age' }
* // }
* ```
*
* @see {@link mapError} if you need to access the error to transform it.
*
* @since 2.0.0
* @category Fallback
*/
const orElseFail = orElseFail$1;
/**
* Ensures the effect always succeeds by replacing failures with a default
* success value.
*
* **Details**
*
* This function transforms an effect that may fail into one that cannot fail by
* replacing any failure with a provided success value. If the original effect
* fails, the failure is "swallowed," and the specified success value is
* returned instead. If the original effect succeeds, its value remains
* unchanged.
*
* **When to Use**
*
* This is especially useful for providing default values in case of failure,
* ensuring that an effect always completes successfully. By using this
* function, you can avoid the need for complex error handling and guarantee a
* fallback result.
*
* **Example**
*
* ```ts
* import { Effect } from "effect"
*
* const validate = (age: number): Effect.Effect<number, string> => {
*   if (age < 0) {
*     return Effect.fail("NegativeAgeError")
*   } else if (age < 18) {
*     return Effect.fail("IllegalAgeError")
*   } else {
*     return Effect.succeed(age)
*   }
* }
*
* const program = Effect.orElseSucceed(validate(-1), () => 18)
*
* console.log(Effect.runSyncExit(program))
* // Output:
* // { _id: 'Exit', _tag: 'Success', value: 18 }
* ```
*
* @since 2.0.0
* @category Fallback
*/
const orElseSucceed = orElseSucceed$1;
/**
* Runs a sequence of effects and returns the result of the first successful
* one.
*
* **Details**
*
* This function allows you to execute a collection of effects in sequence,
* stopping at the first success. If an effect succeeds, its result is
* immediately returned, and no further effects in the sequence are executed.
* However, if all the effects fail, the function will return the error of the
* last effect.
*
* The execution is sequential, meaning that effects are evaluated one at a time
* in the order they are provided. This ensures predictable behavior and avoids
* unnecessary computations.
*
* If the collection of effects is empty, an `IllegalArgumentException` is
* thrown, indicating that the operation is invalid without any effects to try.
*
* **When to Use**
*
* This is particularly useful when you have multiple fallback strategies or
* alternative sources to obtain a result, such as attempting multiple APIs,
* retrieving configurations, or accessing resources in a prioritized manner.
*
* **Example**
*
* ```ts
* import { Effect, Console } from "effect"
*
* interface Config {
*   host: string
*   port: number
*   apiKey: string
* }
*
* // Create a configuration object with sample values
* const makeConfig = (name: string): Config => ({
*   host: `${name}.example.com`,
*   port: 8080,
*   apiKey: "12345-abcde"
* })
*
* // Simulate retrieving configuration from a remote node
* const remoteConfig = (name: string): Effect.Effect<Config, Error> =>
*   Effect.gen(function* () {
*     // Simulate node3 being the only one with available config
*     if (name === "node3") {
*       yield* Console.log(`Config for ${name} found`)
*       return makeConfig(name)
*     } else {
*       yield* Console.log(`Unavailable config for ${name}`)
*       return yield* Effect.fail(new Error(`Config not found for ${name}`))
*     }
*   })
*
* // Define the master configuration and potential fallback nodes
* const masterConfig = remoteConfig("master")
* const nodeConfigs = ["node1", "node2", "node3", "node4"].map(remoteConfig)
*
* // Attempt to find a working configuration,
* // starting with the master and then falling back to other nodes
* const config = Effect.firstSuccessOf([masterConfig, ...nodeConfigs])
*
* // Run the effect to retrieve the configuration
* const result = Effect.runSync(config)
*
* console.log(result)
* // Output:
* // Unavailable config for master
* // Unavailable config for node1
* // Unavailable config for node2
* // Config for node3 found
* // { host: 'node3.example.com', port: 8080, apiKey: '12345-abcde' }
* ```
*
* @since 2.0.0
* @category Fallback
*/
const firstSuccessOf = firstSuccessOf$1;
/**
* Retrieves the `Random` service from the context.
*
* @since 2.0.0
* @category Random
*/
const random = random$1;
/**
* Retrieves the `Random` service from the context and uses it to run the
* specified effect.
*
* @since 2.0.0
* @category Random
*/
const randomWith = randomWith$1;
/**
* Executes the specified effect with the specified implementation of the
* `Random` service.
*
* @since 2.0.0
* @category Random
*/
const withRandom = withRandom$1;
/**
* Sets the implementation of the `Random` service to the specified value and
* restores it to its original value when the scope is closed.
*
* @since 2.0.0
* @category Random
*/
const withRandomScoped = withRandomScoped$1;
/**
* Returns an effect that accesses the runtime, which can be used to (unsafely)
* execute tasks.
*
* **When to Use**
*
* This is useful for integration with legacy code that must call back into
* Effect code.
*
* @since 2.0.0
* @category Runtime
*/
const runtime = runtime$1;
/**
* Retrieves an effect that succeeds with the current runtime flags, which
* govern behavior and features of the runtime system.
*
* @since 2.0.0
* @category Runtime
*/
const getRuntimeFlags = runtimeFlags;
/**
* @since 2.0.0
* @category Runtime
*/
const patchRuntimeFlags = updateRuntimeFlags;
/**
* @since 2.0.0
* @category Runtime
*/
const withRuntimeFlagsPatch = withRuntimeFlags;
/**
* @since 2.0.0
* @category Runtime
*/
const withRuntimeFlagsPatchScoped = withRuntimeFlagsScoped;
/**
* Tags each metric in an effect with specific key-value pairs.
*
* **Details**
*
* This function allows you to tag all metrics in an effect with a set of
* key-value pairs or a single key-value pair. Tags help you add metadata to
* metrics, making it easier to filter and categorize them in monitoring
* systems. The provided tags will apply to all metrics generated within the
* effect's scope.
*
* @since 2.0.0
* @category Metrics
*/
const tagMetrics = tagMetrics$1;
/**
* Adds labels to metrics within an effect using `MetricLabel` objects.
*
* **Details**
*
* This function allows you to label metrics using `MetricLabel` objects. Labels
* help add structured metadata to metrics for categorization and filtering in
* monitoring systems. The provided labels will apply to all metrics within the
* effect's execution.
*
* @since 2.0.0
* @category Metrics
*/
const labelMetrics = labelMetrics$1;
/**
* Tags metrics within a scope with a specific key-value pair.
*
* **Details**
*
* This function tags all metrics within a scope with the provided key-value
* pair. Once the scope is closed, the tag is automatically removed. This is
* useful for applying temporary context-specific tags to metrics during scoped
* operations.
*
* @since 2.0.0
* @category Metrics
*/
const tagMetricsScoped = tagMetricsScoped$1;
/**
* Adds labels to metrics within a scope using `MetricLabel` objects.
*
* **Details**
*
* This function allows you to apply labels to all metrics generated within a
* specific scope using an array of `MetricLabel` objects. These labels provide
* additional metadata to metrics, which can be used for categorization,
* filtering, or monitoring purposes. The labels are scoped and will be removed
* automatically once the scope is closed, ensuring they are only applied
* temporarily within the defined context.
*
* @since 2.0.0
* @category Metrics
*/
const labelMetricsScoped = labelMetricsScoped$1;
/**
* Retrieves the metric labels associated with the current scope.
*
* @since 2.0.0
* @category Metrics
*/
const metricLabels = metricLabels$1;
/**
* Associates a metric with the current effect, updating it as the effect progresses.
*
* @since 2.0.0
* @category Metrics
*/
const withMetric = withMetric$1;
/**
* Unsafely creates a new Semaphore.
*
* @since 2.0.0
* @category Semaphore
*/
const unsafeMakeSemaphore = unsafeMakeSemaphore$1;
/**
* Creates a new semaphore with the specified number of permits.
*
* **Details**
*
* This function initializes a semaphore that controls concurrent access to a
* shared resource. The number of permits determines how many tasks can access
* the resource concurrently.
*
* **Example**
*
* ```ts
* import { Effect } from "effect"
*
* // Create a semaphore with 3 permits
* const mutex = Effect.makeSemaphore(3)
* ```
*
* @since 2.0.0
* @category Semaphore
*/
const makeSemaphore = makeSemaphore$1;
/**
* @category Latch
* @since 3.8.0
*/
const unsafeMakeLatch = unsafeMakeLatch$1;
/**
* Creates a new `Latch`, starting in the specified state.
*
* **Details**
*
* This function initializes a `Latch` safely, ensuring proper runtime
* guarantees. By default, the latch starts in the closed state.
*
* **Example**
*
* ```ts
* import { Console, Effect } from "effect"
*
* const program = Effect.gen(function*() {
*   // Create a latch, starting in the closed state
*   const latch = yield* Effect.makeLatch(false)
*
*   // Fork a fiber that logs "open sesame" when the latch is opened
*   const fiber = yield* Console.log("open sesame").pipe(
*     latch.whenOpen,
*     Effect.fork
*   )
*
*   yield* Effect.sleep("1 second")
*
*   // Open the latch
*   yield* latch.open
*   yield* fiber.await
* })
*
* Effect.runFork(program)
* // Output: open sesame (after 1 second)
* ```
*
* @category Latch
* @since 3.8.0
*/
const makeLatch = makeLatch$1;
/**
* Runs an effect in the background, returning a fiber that can be observed or
* interrupted.
*
* Unless you specifically need a `Promise` or synchronous operation, `runFork`
* is a good default choice.
*
* **Details**
*
* This function is the foundational way to execute an effect in the background.
* It creates a "fiber," a lightweight, cooperative thread of execution that can
* be observed (to access its result), interrupted, or joined. Fibers are useful
* for concurrent programming and allow effects to run independently of the main
* program flow.
*
* Once the effect is running in a fiber, you can monitor its progress, cancel
* it if necessary, or retrieve its result when it completes. If the effect
* fails, the fiber will propagate the failure, which you can observe and
* handle.
*
* **When to Use**
*
* Use this function when you need to run an effect in the background,
* especially if the effect is long-running or performs periodic tasks. It's
* suitable for tasks that need to run independently but might still need
* observation or management, like logging, monitoring, or scheduled tasks.
*
* This function is ideal if you don't need the result immediately or if the
* effect is part of a larger concurrent workflow.
*
* **Example** (Running an Effect in the Background)
*
* ```ts
* import { Effect, Console, Schedule, Fiber } from "effect"
*
* //      ┌─── Effect<number, never, never>
* //      ▼
* const program = Effect.repeat(
*   Console.log("running..."),
*   Schedule.spaced("200 millis")
* )
*
* //      ┌─── RuntimeFiber<number, never>
* //      ▼
* const fiber = Effect.runFork(program)
*
* setTimeout(() => {
*   Effect.runFork(Fiber.interrupt(fiber))
* }, 500)
* ```
*
* @since 2.0.0
* @category Running Effects
*/
const runFork = unsafeForkEffect;
/**
* Executes an effect asynchronously and handles the result using a callback.
*
* **Details**
*
* This function runs an effect asynchronously and passes the result (`Exit`) to
* a specified callback. The callback is invoked with the outcome of the effect:
* - On success, the callback receives the successful result.
* - On failure, the callback receives the failure information.
*
* **When to Use**
*
* This function is effectful and should only be invoked at the edges of your
* program.
*
* @since 2.0.0
* @category Running Effects
*/
const runCallback = unsafeRunEffect;
/**
* Executes an effect and returns the result as a `Promise`.
*
* **Details**
*
* This function runs an effect and converts its result into a `Promise`. If the
* effect succeeds, the `Promise` will resolve with the successful result. If
* the effect fails, the `Promise` will reject with an error, which includes the
* failure details of the effect.
*
* The optional `options` parameter allows you to pass an `AbortSignal` for
* cancellation, enabling more fine-grained control over asynchronous tasks.
*
* **When to Use**
*
* Use this function when you need to execute an effect and work with its result
* in a promise-based system, such as when integrating with third-party
* libraries that expect `Promise` results.
*
* **Example** (Running a Successful Effect as a Promise)
*
* ```ts
* import { Effect } from "effect"
*
* Effect.runPromise(Effect.succeed(1)).then(console.log)
* // Output: 1
* ```
*
* **Example** (Handling a Failing Effect as a Rejected Promise)
*
* ```ts
* import { Effect } from "effect"
*
* Effect.runPromise(Effect.fail("my error")).catch(console.error)
* // Output:
* // (FiberFailure) Error: my error
* ```
*
* @see {@link runPromiseExit} for a version that returns an `Exit` type instead
* of rejecting.
*
* @since 2.0.0
* @category Running Effects
*/
const runPromise = unsafeRunPromiseEffect;
/**
* Runs an effect and returns a `Promise` that resolves to an `Exit`,
* representing the outcome.
*
* **Details**
*
* This function executes an effect and resolves to an `Exit` object. The `Exit`
* type provides detailed information about the result of the effect:
* - If the effect succeeds, the `Exit` will be of type `Success` and include
*   the value produced by the effect.
* - If the effect fails, the `Exit` will be of type `Failure` and contain a
*   `Cause` object, detailing the failure.
*
* Using this function allows you to examine both successful results and failure
* cases in a unified way, while still leveraging `Promise` for handling the
* asynchronous behavior of the effect.
*
* **When to Use**
*
* Use this function when you need to understand the outcome of an effect,
* whether it succeeded or failed, and want to work with this result using
* `Promise` syntax. This is particularly useful when integrating with systems
* that rely on promises but need more detailed error handling than a simple
* rejection.
*
* **Example** (Handling Results as Exit)
*
* ```ts
* import { Effect } from "effect"
*
* // Execute a successful effect and get the Exit result as a Promise
* Effect.runPromiseExit(Effect.succeed(1)).then(console.log)
* // Output:
* // {
* //   _id: "Exit",
* //   _tag: "Success",
* //   value: 1
* // }
*
* // Execute a failing effect and get the Exit result as a Promise
* Effect.runPromiseExit(Effect.fail("my error")).then(console.log)
* // Output:
* // {
* //   _id: "Exit",
* //   _tag: "Failure",
* //   cause: {
* //     _id: "Cause",
* //     _tag: "Fail",
* //     failure: "my error"
* //   }
* // }
* ```
*
* @since 2.0.0
* @category Running Effects
*/
const runPromiseExit = unsafeRunPromiseExitEffect;
/**
* Executes an effect synchronously, running it immediately and returning the
* result.
*
* **Details**
*
* This function evaluates the provided effect synchronously, returning its
* result directly. It is ideal for effects that do not fail or include
* asynchronous operations. If the effect does fail or involves async tasks, it
* will throw an error. Execution stops at the point of failure or asynchronous
* operation, making it unsuitable for effects that require asynchronous
* handling.
*
* **Important**: Attempting to run effects that involve asynchronous operations
* or failures will result in exceptions being thrown, so use this function with
* care for purely synchronous and error-free effects.
*
* **When to Use**
*
* Use this function when:
* - You are sure that the effect will not fail or involve asynchronous
*   operations.
* - You need a direct, synchronous result from the effect.
* - You are working within a context where asynchronous effects are not
*   allowed.
*
* Avoid using this function for effects that can fail or require asynchronous
* handling. For such cases, consider using {@link runPromise} or
* {@link runSyncExit}.
*
* **Example** (Synchronous Logging)
*
* ```ts
* import { Effect } from "effect"
*
* const program = Effect.sync(() => {
*   console.log("Hello, World!")
*   return 1
* })
*
* const result = Effect.runSync(program)
* // Output: Hello, World!
*
* console.log(result)
* // Output: 1
* ```
*
* **Example** (Incorrect Usage with Failing or Async Effects)
*
* ```ts
* import { Effect } from "effect"
*
* try {
*   // Attempt to run an effect that fails
*   Effect.runSync(Effect.fail("my error"))
* } catch (e) {
*   console.error(e)
* }
* // Output:
* // (FiberFailure) Error: my error
*
* try {
*   // Attempt to run an effect that involves async work
*   Effect.runSync(Effect.promise(() => Promise.resolve(1)))
* } catch (e) {
*   console.error(e)
* }
* // Output:
* // (FiberFailure) AsyncFiberException: Fiber #0 cannot be resolved synchronously. This is caused by using runSync on an effect that performs async work
* ```
*
* @see {@link runSyncExit} for a version that returns an `Exit` type instead of
* throwing an error.
*
* @since 2.0.0
* @category Running Effects
*/
const runSync = unsafeRunSyncEffect;
/**
* Runs an effect synchronously and returns the result as an `Exit` type.
*
* **Details**
*
* This function executes the provided effect synchronously and returns an `Exit`
* type that encapsulates the outcome of the effect:
* - If the effect succeeds, the result is wrapped in a `Success`.
* - If the effect fails, it returns a `Failure` containing a `Cause` that explains
*   the failure.
*
* If the effect involves asynchronous operations, this function will return a `Failure`
* with a `Die` cause, indicating that it cannot resolve the effect synchronously.
* This makes the function suitable for use only with effects that are synchronous
* in nature.
*
* **When to Use**
*
* Use this function when:
* - You want to handle both success and failure outcomes in a structured way using the `Exit` type.
* - You are working with effects that are purely synchronous and do not involve asynchronous operations.
* - You need to debug or inspect failures, including their causes, in a detailed manner.
*
* Avoid using this function for effects that involve asynchronous operations, as it will fail with a `Die` cause.
*
* **Example** (Handling Results as Exit)
*
* ```ts
* import { Effect } from "effect"
*
* console.log(Effect.runSyncExit(Effect.succeed(1)))
* // Output:
* // {
* //   _id: "Exit",
* //   _tag: "Success",
* //   value: 1
* // }
*
* console.log(Effect.runSyncExit(Effect.fail("my error")))
* // Output:
* // {
* //   _id: "Exit",
* //   _tag: "Failure",
* //   cause: {
* //     _id: "Cause",
* //     _tag: "Fail",
* //     failure: "my error"
* //   }
* // }
* ```
*
* **Example** (Asynchronous Operation Resulting in Die)
*
* ```ts
* import { Effect } from "effect"
*
* console.log(Effect.runSyncExit(Effect.promise(() => Promise.resolve(1))))
* // Output:
* // {
* //   _id: 'Exit',
* //   _tag: 'Failure',
* //   cause: {
* //     _id: 'Cause',
* //     _tag: 'Die',
* //     defect: [Fiber #0 cannot be resolved synchronously. This is caused by using runSync on an effect that performs async work] {
* //       fiber: [FiberRuntime],
* //       _tag: 'AsyncFiberException',
* //       name: 'AsyncFiberException'
* //     }
* //   }
* // }
* ```
*
* @since 2.0.0
* @category Running Effects
*/
const runSyncExit = unsafeRunSyncExitEffect;
/**
* Combines multiple effects and accumulates both successes and failures.
*
* **Details**
*
* This function allows you to combine multiple effects, continuing through all
* effects even if some of them fail. Unlike other functions that stop execution
* upon encountering an error, this function collects all errors into a `Cause`.
* The final result includes all successes and the accumulated failures.
*
* By default, effects are executed sequentially, but you can control
* concurrency and batching behavior using the `options` parameter. This
* provides flexibility in scenarios where you want to maximize performance or
* ensure specific ordering.
*
* **Example**
*
* ```ts
* import { Effect, Console } from "effect"
*
* const task1 = Console.log("task1").pipe(Effect.as(1))
* const task2 = Effect.fail("Oh uh!").pipe(Effect.as(2))
* const task3 = Console.log("task2").pipe(Effect.as(3))
* const task4 = Effect.fail("Oh no!").pipe(Effect.as(4))
*
* const program = task1.pipe(
*   Effect.validate(task2),
*   Effect.validate(task3),
*   Effect.validate(task4)
* )
*
* Effect.runPromiseExit(program).then(console.log)
* // Output:
* // task1
* // task2
* // {
* //   _id: 'Exit',
* //   _tag: 'Failure',
* //   cause: {
* //     _id: 'Cause',
* //     _tag: 'Sequential',
* //     left: { _id: 'Cause', _tag: 'Fail', failure: 'Oh uh!' },
* //     right: { _id: 'Cause', _tag: 'Fail', failure: 'Oh no!' }
* //   }
* // }
* ```
*
* @see {@link zip} for a version that stops at the first error.
*
* @since 2.0.0
* @category Error Accumulation
*/
const validate = validate$1;
/**
* Sequentially combines two effects using a specified combiner function while
* accumulating errors.
*
* **Details**
*
* This function combines two effects, `self` and `that`, into a single effect
* by applying the provided combiner function to their results. If both effects
* succeed, the combiner function is applied to their results to produce the
* final value. If either effect fails, the failures are accumulated into a
* combined `Cause`.
*
* By default, effects are executed sequentially. However, the execution mode
* can be controlled using the `options` parameter to enable concurrency,
* batching, or customized finalizer behavior.
*
* @since 2.0.0
* @category Error Accumulation
*/
const validateWith = validateWith$1;
/**
* Combines two effects into a single effect, producing a tuple of their
* results.
*
* **Details**
*
* This function combines two effects, `self` and `that`, into one. It executes
* the first effect (`self`) and then the second effect (`that`), collecting
* their results into a tuple. Both effects must succeed for the resulting
* effect to succeed. If either effect fails, the entire operation fails.
*
* By default, the effects are executed sequentially. If the `concurrent` option
* is set to `true`, the effects will run concurrently, potentially improving
* performance for independent operations.
*
* **Example** (Combining Two Effects Sequentially)
*
* ```ts
* import { Effect } from "effect"
*
* const task1 = Effect.succeed(1).pipe(
*   Effect.delay("200 millis"),
*   Effect.tap(Effect.log("task1 done"))
* )
* const task2 = Effect.succeed("hello").pipe(
*   Effect.delay("100 millis"),
*   Effect.tap(Effect.log("task2 done"))
* )
*
* // Combine the two effects together
* //
* //      ┌─── Effect<[number, string], never, never>
* //      ▼
* const program = Effect.zip(task1, task2)
*
* Effect.runPromise(program).then(console.log)
* // Output:
* // timestamp=... level=INFO fiber=#0 message="task1 done"
* // timestamp=... level=INFO fiber=#0 message="task2 done"
* // [ 1, 'hello' ]
* ```
*
* **Example** (Combining Two Effects Concurrently)
*
* ```ts
* import { Effect } from "effect"
*
* const task1 = Effect.succeed(1).pipe(
*   Effect.delay("200 millis"),
*   Effect.tap(Effect.log("task1 done"))
* )
* const task2 = Effect.succeed("hello").pipe(
*   Effect.delay("100 millis"),
*   Effect.tap(Effect.log("task2 done"))
* )
*
* // Run both effects concurrently using the concurrent option
* const program = Effect.zip(task1, task2, { concurrent: true })
*
* Effect.runPromise(program).then(console.log)
* // Output:
* // timestamp=... level=INFO fiber=#0 message="task2 done"
* // timestamp=... level=INFO fiber=#0 message="task1 done"
* // [ 1, 'hello' ]
* ```
*
* @see {@link zipWith} for a version that combines the results with a custom
* function.
* @see {@link validate} for a version that accumulates errors.
*
* @since 2.0.0
* @category Zipping
*/
const zip = zipOptions;
/**
* Executes two effects sequentially, returning the result of the first effect
* and ignoring the result of the second.
*
* **Details**
*
* This function allows you to run two effects in sequence, where the result of
* the first effect is preserved, and the result of the second effect is
* discarded. By default, the two effects are executed sequentially. If you need
* them to run concurrently, you can pass the `{ concurrent: true }` option.
*
* The second effect will always be executed, even though its result is ignored.
* This makes it useful for cases where you want to execute an effect for its
* side effects while keeping the result of another effect.
*
* **When to Use**
*
* Use this function when you are only interested in the result of the first
* effect but still need to run the second effect for its side effects, such as
* logging or performing a cleanup action.
*
* **Example**
*
* ```ts
* import { Effect } from "effect"
*
* const task1 = Effect.succeed(1).pipe(
*   Effect.delay("200 millis"),
*   Effect.tap(Effect.log("task1 done"))
* )
* const task2 = Effect.succeed("hello").pipe(
*   Effect.delay("100 millis"),
*   Effect.tap(Effect.log("task2 done"))
* )
*
* const program = Effect.zipLeft(task1, task2)
*
* Effect.runPromise(program).then(console.log)
* // Output:
* // timestamp=... level=INFO fiber=#0 message="task1 done"
* // timestamp=... level=INFO fiber=#0 message="task2 done"
* // 1
* ```
*
* @see {@link zipRight} for a version that returns the result of the second
* effect.
*
* @since 2.0.0
* @category Zipping
*/
const zipLeft = zipLeftOptions;
/**
* Executes two effects sequentially, returning the result of the second effect
* while ignoring the result of the first.
*
* **Details**
*
* This function allows you to run two effects in sequence, keeping the result
* of the second effect and discarding the result of the first. By default, the
* two effects are executed sequentially. If you need them to run concurrently,
* you can pass the `{ concurrent: true }` option.
*
* The first effect will always be executed, even though its result is ignored.
* This makes it useful for scenarios where the first effect is needed for its
* side effects, but only the result of the second effect is important.
*
* **When to Use**
*
* Use this function when you are only interested in the result of the second
* effect but still need to run the first effect for its side effects, such as
* initialization or setup tasks.
*
* **Example**
*
* ```ts
* import { Effect } from "effect"
*
* const task1 = Effect.succeed(1).pipe(
*   Effect.delay("200 millis"),
*   Effect.tap(Effect.log("task1 done"))
* )
* const task2 = Effect.succeed("hello").pipe(
*   Effect.delay("100 millis"),
*   Effect.tap(Effect.log("task2 done"))
* )
*
* const program = Effect.zipRight(task1, task2)
*
* Effect.runPromise(program).then(console.log)
* // Output:
* // timestamp=... level=INFO fiber=#0 message="task1 done"
* // timestamp=... level=INFO fiber=#0 message="task2 done"
* // hello
* ```
*
* @see {@link zipLeft} for a version that returns the result of the first
* effect.
*
* @since 2.0.0
* @category Zipping
*/
const zipRight = zipRightOptions;
/**
* Combines two effects sequentially and applies a function to their results to
* produce a single value.
*
* **Details**
*
* This function runs two effects in sequence (or concurrently, if the `{
* concurrent: true }` option is provided) and combines their results using a
* provided function. Unlike {@link zip}, which returns a tuple of the results,
* this function processes the results with a custom function to produce a
* single output.
*
* **Example** (Combining Effects with a Custom Function)
*
* ```ts
* import { Effect } from "effect"
*
* const task1 = Effect.succeed(1).pipe(
*   Effect.delay("200 millis"),
*   Effect.tap(Effect.log("task1 done"))
* )
* const task2 = Effect.succeed("hello").pipe(
*   Effect.delay("100 millis"),
*   Effect.tap(Effect.log("task2 done"))
* )
*
* const task3 = Effect.zipWith(
*   task1,
*   task2,
*   // Combines results into a single value
*   (number, string) => number + string.length
* )
*
* Effect.runPromise(task3).then(console.log)
* // Output:
* // timestamp=... level=INFO fiber=#3 message="task1 done"
* // timestamp=... level=INFO fiber=#2 message="task2 done"
* // 6
* ```
*
* @since 2.0.0
* @category Zipping
*/
const zipWith = zipWithOptions;
/**
* @category Requests & Batching
* @since 2.0.0
*/
const blocked = blocked$1;
/**
* @category Requests & Batching
* @since 2.0.0
*/
const runRequestBlock = runRequestBlock$1;
/**
* @category Requests & Batching
* @since 2.0.0
*/
const step = step$1;
/**
* @since 2.0.0
* @category Requests & Batching
*/
const request = /* @__PURE__ */ dual((args$1) => isRequest(args$1[0]), fromRequest);
/**
* @since 2.0.0
* @category Requests & Batching
*/
const cacheRequestResult = cacheRequest;
/**
* @since 2.0.0
* @category Requests & Batching
*/
const withRequestBatching = withRequestBatching$1;
/**
* @since 2.0.0
* @category Requests & Batching
*/
const withRequestCaching = withRequestCaching$1;
/**
* @since 2.0.0
* @category Requests & Batching
*/
const withRequestCache = withRequestCache$1;
/**
* @since 2.0.0
* @category Tracing
*/
const tracer = tracer$1;
/**
* @since 2.0.0
* @category Tracing
*/
const tracerWith = tracerWith$3;
/**
* @since 2.0.0
* @category Tracing
*/
const withTracer = withTracer$1;
/**
* @since 2.0.0
* @category Tracing
*/
const withTracerScoped = withTracerScoped$1;
/**
* Disable the tracer for the given Effect.
*
* **Example**
*
* ```ts
* import { Effect } from "effect"
*
* Effect.succeed(42).pipe(
*   Effect.withSpan("my-span"),
*   // the span will not be registered with the tracer
*   Effect.withTracerEnabled(false)
* )
* ```
*
* @since 2.0.0
* @category Tracing
*/
const withTracerEnabled = withTracerEnabled$1;
/**
* @since 2.0.0
* @category Tracing
*/
const withTracerTiming = withTracerTiming$1;
/**
* Adds annotations to each span in the effect for enhanced traceability.
*
* **Details**
*
* This function lets you attach key-value annotations to all spans generated
* during the execution of an effect. Annotations provide additional context,
* such as metadata or labels, which can help you understand and debug
* asynchronous workflows more effectively.
*
* You can either pass a single key-value pair or a record of key-value pairs to
* annotate the spans. These annotations can then be visualized in tracing tools
* that support span annotations.
*
* @since 2.0.0
* @category Tracing
*/
const annotateSpans = annotateSpans$1;
/**
* Adds annotations to the currently active span for traceability.
*
* **Details**
*
* This function adds key-value annotations to the currently active span in the
* effect's trace. These annotations help provide more context about the
* operation being executed at a specific point in time. Unlike
* {@link annotateSpans}, which applies to all spans in an effect, this function
* focuses solely on the active span.
*
* You can either pass a single key-value pair or a record of key-value pairs to
* annotate the span. These annotations are useful for adding metadata to
* operations, especially in systems with detailed observability requirements.
*
* @since 2.0.0
* @category Tracing
*/
const annotateCurrentSpan = annotateCurrentSpan$1;
/**
* @since 2.0.0
* @category Tracing
*/
const currentSpan = currentSpan$1;
/**
* @since 2.0.0
* @category Tracing
*/
const currentParentSpan = currentParentSpan$1;
/**
* @since 2.0.0
* @category Tracing
*/
const spanAnnotations = spanAnnotations$1;
/**
* @since 2.0.0
* @category Tracing
*/
const spanLinks = spanLinks$1;
/**
* For all spans in this effect, add a link with the provided span.
*
* @since 2.0.0
* @category Tracing
*/
const linkSpans = linkSpans$1;
/**
* Add span links to the current span.
*
* @since 3.14.0
* @category Tracing
*/
const linkSpanCurrent = linkSpanCurrent$1;
/**
* Create a new span for tracing.
*
* @since 2.0.0
* @category Tracing
*/
const makeSpan = makeSpan$1;
/**
* Create a new span for tracing, and automatically close it when the Scope
* finalizes.
*
* The span is not added to the current span stack, so no child spans will be
* created for it.
*
* @since 2.0.0
* @category Tracing
*/
const makeSpanScoped = makeSpanScoped$1;
/**
* Create a new span for tracing, and automatically close it when the effect
* completes.
*
* The span is not added to the current span stack, so no child spans will be
* created for it.
*
* @since 2.0.0
* @category Tracing
*/
const useSpan = useSpan$1;
/**
* Wraps the effect with a new span for tracing.
*
* @since 2.0.0
* @category Tracing
*/
const withSpan = withSpan$1;
/**
* Wraps a function that returns an effect with a new span for tracing.
*
* **Example**
*
* ```ts
* import { Effect } from "effect"
*
* const getTodo = Effect.functionWithSpan({
*   body: (id: number) => Effect.succeed(`Got todo ${id}!`),
*   options: (id) => ({
*     name: `getTodo-${id}`,
*     attributes: { id }
*   })
* })
* ```
*
* @since 3.2.0
* @category Tracing
*/
const functionWithSpan = functionWithSpan$1;
/**
* Wraps the effect with a new span for tracing.
*
* The span is ended when the Scope is finalized.
*
* @since 2.0.0
* @category Tracing
*/
const withSpanScoped = withSpanScoped$1;
/**
* Adds the provided span to the current span stack.
*
* @since 2.0.0
* @category Tracing
*/
const withParentSpan = withParentSpan$1;
/**
* Safely handles nullable values by creating an effect that fails for `null` or
* `undefined`.
*
* **Details**
*
* This function ensures that an input value is non-null and non-undefined
* before processing it. If the value is valid, the effect succeeds with the
* value. If the value is `null` or `undefined`, the effect fails with a
* `NoSuchElementException`. This is particularly useful for avoiding
* null-related errors by clearly separating valid values from invalid ones in
* effectful computations.
*
* The failure with `NoSuchElementException` allows you to explicitly handle
* cases where a value is expected but not provided, leading to safer and more
* predictable code.
*
* **When to Use**
*
* Use this function when working with values that may be `null` or `undefined`
* and you want to ensure that only non-null values are processed. It helps
* enforce null-safety and makes error handling more explicit.
*
* **Example**
*
* ```ts
* import { Effect } from "effect"
*
* //      ┌─── Effect<number, NoSuchElementException, never>
* //      ▼
* const maybe1 = Effect.fromNullable(1)
*
* Effect.runPromiseExit(maybe1).then(console.log)
* // Output:
* // { _id: 'Exit', _tag: 'Success', value: 1 }
*
* //      ┌─── Effect<number, NoSuchElementException, never>
* //      ▼
* const maybe2 = Effect.fromNullable(null as number | null)
*
* Effect.runPromiseExit(maybe2).then(console.log)
* // Output:
* // {
* //   _id: 'Exit',
* //   _tag: 'Failure',
* //   cause: {
* //     _id: 'Cause',
* //     _tag: 'Fail',
* //     failure: { _tag: 'NoSuchElementException' }
* //   }
* // }
* ```
*
* @since 2.0.0
* @category Optional Wrapping & Unwrapping
*/
const fromNullable = fromNullable$1;
/**
* Converts an effect that may fail with a `NoSuchElementException` into an
* effect that succeeds with an `Option`.
*
* **Details**
*
* This function transforms an effect that might fail with
* `Cause.NoSuchElementException` into an effect that succeeds with an `Option`
* type. If the original effect succeeds, its value is wrapped in `Option.some`.
* If it fails specifically due to a `NoSuchElementException`, the failure is
* mapped to `Option.none`. Other types of failures remain unchanged and are
* passed through as they are.
*
* This is useful when working with effects where you want to gracefully handle
* the absence of a value while preserving other potential failures.
*
* **When to Use**
*
* Use this function when you need to handle missing values as `Option.none`
* rather than throwing or propagating errors like `NoSuchElementException`.
* It’s ideal for scenarios where you want to explicitly represent optionality
* in a type-safe way while retaining other failure information.
*
* **Example**
*
* ```ts
* import { Effect } from "effect"
*
* //      ┌─── Effect<number, NoSuchElementException, never>
* //      ▼
* const maybe1 = Effect.fromNullable(1)
*
* //      ┌─── Effect<Option<number>, never, never>
* //      ▼
* const option1 = Effect.optionFromOptional(maybe1)
*
* Effect.runPromise(option1).then(console.log)
* // Output: { _id: 'Option', _tag: 'Some', value: 1 }
*
* //      ┌─── Effect<number, NoSuchElementException, never>
* //      ▼
* const maybe2 = Effect.fromNullable(null as number | null)
*
* //      ┌─── Effect<Option<number>, never, never>
* //      ▼
* const option2 = Effect.optionFromOptional(maybe2)
*
* Effect.runPromise(option2).then(console.log)
* // Output: { _tag: 'None' }
* ```
*
* @since 2.0.0
* @category Optional Wrapping & Unwrapping
*/
const optionFromOptional = optionFromOptional$1;
/**
* Same as {@link fn}, but allows you to create a function that is not traced, for when performance is critical.
*
* @see {@link fn} for a version that includes tracing.
*
* @since 3.12.0
* @category Tracing
*/
const fnUntraced = fnUntraced$1;

//#endregion
//#region ../../node_modules/.bun/effect@3.17.14/node_modules/effect/dist/esm/internal/encoding/common.js
/** @internal */
const DecodeExceptionTypeId$1 = /* @__PURE__ */ Symbol.for("effect/Encoding/errors/Decode");
/** @internal */
const DecodeException$1 = (input, message) => {
	const out = {
		_tag: "DecodeException",
		[DecodeExceptionTypeId$1]: DecodeExceptionTypeId$1,
		input
	};
	if (isString(message)) out.message = message;
	return out;
};
/** @internal */
const isDecodeException$1 = (u) => hasProperty(u, DecodeExceptionTypeId$1);
/** @internal */
const EncodeExceptionTypeId$1 = /* @__PURE__ */ Symbol.for("effect/Encoding/errors/Encode");
/** @internal */
const EncodeException$1 = (input, message) => {
	const out = {
		_tag: "EncodeException",
		[EncodeExceptionTypeId$1]: EncodeExceptionTypeId$1,
		input
	};
	if (isString(message)) out.message = message;
	return out;
};
/** @internal */
const isEncodeException$1 = (u) => hasProperty(u, EncodeExceptionTypeId$1);
/** @interal */
const encoder = /* @__PURE__ */ new TextEncoder();
/** @interal */
const decoder = /* @__PURE__ */ new TextDecoder();

//#endregion
//#region ../../node_modules/.bun/effect@3.17.14/node_modules/effect/dist/esm/internal/encoding/base64.js
/** @internal */
const encode$2 = (bytes) => {
	const length$1 = bytes.length;
	let result = "";
	let i;
	for (i = 2; i < length$1; i += 3) {
		result += base64abc[bytes[i - 2] >> 2];
		result += base64abc[(bytes[i - 2] & 3) << 4 | bytes[i - 1] >> 4];
		result += base64abc[(bytes[i - 1] & 15) << 2 | bytes[i] >> 6];
		result += base64abc[bytes[i] & 63];
	}
	if (i === length$1 + 1) {
		result += base64abc[bytes[i - 2] >> 2];
		result += base64abc[(bytes[i - 2] & 3) << 4];
		result += "==";
	}
	if (i === length$1) {
		result += base64abc[bytes[i - 2] >> 2];
		result += base64abc[(bytes[i - 2] & 3) << 4 | bytes[i - 1] >> 4];
		result += base64abc[(bytes[i - 1] & 15) << 2];
		result += "=";
	}
	return result;
};
/** @internal */
const decode$2 = (str) => {
	const stripped = stripCrlf(str);
	const length$1 = stripped.length;
	if (length$1 % 4 !== 0) return left(DecodeException$1(stripped, `Length must be a multiple of 4, but is ${length$1}`));
	const index = stripped.indexOf("=");
	if (index !== -1 && (index < length$1 - 2 || index === length$1 - 2 && stripped[length$1 - 1] !== "=")) return left(DecodeException$1(stripped, "Found a '=' character, but it is not at the end"));
	try {
		const missingOctets = stripped.endsWith("==") ? 2 : stripped.endsWith("=") ? 1 : 0;
		const result = new Uint8Array(3 * (length$1 / 4) - missingOctets);
		for (let i = 0, j = 0; i < length$1; i += 4, j += 3) {
			const buffer = getBase64Code(stripped.charCodeAt(i)) << 18 | getBase64Code(stripped.charCodeAt(i + 1)) << 12 | getBase64Code(stripped.charCodeAt(i + 2)) << 6 | getBase64Code(stripped.charCodeAt(i + 3));
			result[j] = buffer >> 16;
			result[j + 1] = buffer >> 8 & 255;
			result[j + 2] = buffer & 255;
		}
		return right(result);
	} catch (e) {
		return left(DecodeException$1(stripped, e instanceof Error ? e.message : "Invalid input"));
	}
};
/** @internal */
const stripCrlf = (str) => str.replace(/[\n\r]/g, "");
/** @internal */
function getBase64Code(charCode) {
	if (charCode >= base64codes.length) throw new TypeError(`Invalid character ${String.fromCharCode(charCode)}`);
	const code = base64codes[charCode];
	if (code === 255) throw new TypeError(`Invalid character ${String.fromCharCode(charCode)}`);
	return code;
}
/** @internal */
const base64abc = [
	"A",
	"B",
	"C",
	"D",
	"E",
	"F",
	"G",
	"H",
	"I",
	"J",
	"K",
	"L",
	"M",
	"N",
	"O",
	"P",
	"Q",
	"R",
	"S",
	"T",
	"U",
	"V",
	"W",
	"X",
	"Y",
	"Z",
	"a",
	"b",
	"c",
	"d",
	"e",
	"f",
	"g",
	"h",
	"i",
	"j",
	"k",
	"l",
	"m",
	"n",
	"o",
	"p",
	"q",
	"r",
	"s",
	"t",
	"u",
	"v",
	"w",
	"x",
	"y",
	"z",
	"0",
	"1",
	"2",
	"3",
	"4",
	"5",
	"6",
	"7",
	"8",
	"9",
	"+",
	"/"
];
/** @internal */
const base64codes = [
	255,
	255,
	255,
	255,
	255,
	255,
	255,
	255,
	255,
	255,
	255,
	255,
	255,
	255,
	255,
	255,
	255,
	255,
	255,
	255,
	255,
	255,
	255,
	255,
	255,
	255,
	255,
	255,
	255,
	255,
	255,
	255,
	255,
	255,
	255,
	255,
	255,
	255,
	255,
	255,
	255,
	255,
	255,
	62,
	255,
	255,
	255,
	63,
	52,
	53,
	54,
	55,
	56,
	57,
	58,
	59,
	60,
	61,
	255,
	255,
	255,
	0,
	255,
	255,
	255,
	0,
	1,
	2,
	3,
	4,
	5,
	6,
	7,
	8,
	9,
	10,
	11,
	12,
	13,
	14,
	15,
	16,
	17,
	18,
	19,
	20,
	21,
	22,
	23,
	24,
	25,
	255,
	255,
	255,
	255,
	255,
	255,
	26,
	27,
	28,
	29,
	30,
	31,
	32,
	33,
	34,
	35,
	36,
	37,
	38,
	39,
	40,
	41,
	42,
	43,
	44,
	45,
	46,
	47,
	48,
	49,
	50,
	51
];

//#endregion
//#region ../../node_modules/.bun/effect@3.17.14/node_modules/effect/dist/esm/internal/encoding/base64Url.js
/** @internal */
const encode$1 = (data) => encode$2(data).replace(/=/g, "").replace(/\+/g, "-").replace(/\//g, "_");
/** @internal */
const decode$1 = (str) => {
	const stripped = stripCrlf(str);
	const length$1 = stripped.length;
	if (length$1 % 4 === 1) return left(DecodeException$1(stripped, `Length should be a multiple of 4, but is ${length$1}`));
	if (!/^[-_A-Z0-9]*?={0,2}$/i.test(stripped)) return left(DecodeException$1(stripped, "Invalid input"));
	let sanitized = length$1 % 4 === 2 ? `${stripped}==` : length$1 % 4 === 3 ? `${stripped}=` : stripped;
	sanitized = sanitized.replace(/-/g, "+").replace(/_/g, "/");
	return decode$2(sanitized);
};

//#endregion
//#region ../../node_modules/.bun/effect@3.17.14/node_modules/effect/dist/esm/internal/encoding/hex.js
/** @internal */
const encode = (bytes) => {
	let result = "";
	for (let i = 0; i < bytes.length; ++i) result += bytesToHex[bytes[i]];
	return result;
};
/** @internal */
const decode = (str) => {
	const bytes = new TextEncoder().encode(str);
	if (bytes.length % 2 !== 0) return left(DecodeException$1(str, `Length must be a multiple of 2, but is ${bytes.length}`));
	try {
		const length$1 = bytes.length / 2;
		const result = new Uint8Array(length$1);
		for (let i = 0; i < length$1; i++) {
			const a = fromHexChar(bytes[i * 2]);
			const b = fromHexChar(bytes[i * 2 + 1]);
			result[i] = a << 4 | b;
		}
		return right(result);
	} catch (e) {
		return left(DecodeException$1(str, e instanceof Error ? e.message : "Invalid input"));
	}
};
/** @internal */
const bytesToHex = [
	"00",
	"01",
	"02",
	"03",
	"04",
	"05",
	"06",
	"07",
	"08",
	"09",
	"0a",
	"0b",
	"0c",
	"0d",
	"0e",
	"0f",
	"10",
	"11",
	"12",
	"13",
	"14",
	"15",
	"16",
	"17",
	"18",
	"19",
	"1a",
	"1b",
	"1c",
	"1d",
	"1e",
	"1f",
	"20",
	"21",
	"22",
	"23",
	"24",
	"25",
	"26",
	"27",
	"28",
	"29",
	"2a",
	"2b",
	"2c",
	"2d",
	"2e",
	"2f",
	"30",
	"31",
	"32",
	"33",
	"34",
	"35",
	"36",
	"37",
	"38",
	"39",
	"3a",
	"3b",
	"3c",
	"3d",
	"3e",
	"3f",
	"40",
	"41",
	"42",
	"43",
	"44",
	"45",
	"46",
	"47",
	"48",
	"49",
	"4a",
	"4b",
	"4c",
	"4d",
	"4e",
	"4f",
	"50",
	"51",
	"52",
	"53",
	"54",
	"55",
	"56",
	"57",
	"58",
	"59",
	"5a",
	"5b",
	"5c",
	"5d",
	"5e",
	"5f",
	"60",
	"61",
	"62",
	"63",
	"64",
	"65",
	"66",
	"67",
	"68",
	"69",
	"6a",
	"6b",
	"6c",
	"6d",
	"6e",
	"6f",
	"70",
	"71",
	"72",
	"73",
	"74",
	"75",
	"76",
	"77",
	"78",
	"79",
	"7a",
	"7b",
	"7c",
	"7d",
	"7e",
	"7f",
	"80",
	"81",
	"82",
	"83",
	"84",
	"85",
	"86",
	"87",
	"88",
	"89",
	"8a",
	"8b",
	"8c",
	"8d",
	"8e",
	"8f",
	"90",
	"91",
	"92",
	"93",
	"94",
	"95",
	"96",
	"97",
	"98",
	"99",
	"9a",
	"9b",
	"9c",
	"9d",
	"9e",
	"9f",
	"a0",
	"a1",
	"a2",
	"a3",
	"a4",
	"a5",
	"a6",
	"a7",
	"a8",
	"a9",
	"aa",
	"ab",
	"ac",
	"ad",
	"ae",
	"af",
	"b0",
	"b1",
	"b2",
	"b3",
	"b4",
	"b5",
	"b6",
	"b7",
	"b8",
	"b9",
	"ba",
	"bb",
	"bc",
	"bd",
	"be",
	"bf",
	"c0",
	"c1",
	"c2",
	"c3",
	"c4",
	"c5",
	"c6",
	"c7",
	"c8",
	"c9",
	"ca",
	"cb",
	"cc",
	"cd",
	"ce",
	"cf",
	"d0",
	"d1",
	"d2",
	"d3",
	"d4",
	"d5",
	"d6",
	"d7",
	"d8",
	"d9",
	"da",
	"db",
	"dc",
	"dd",
	"de",
	"df",
	"e0",
	"e1",
	"e2",
	"e3",
	"e4",
	"e5",
	"e6",
	"e7",
	"e8",
	"e9",
	"ea",
	"eb",
	"ec",
	"ed",
	"ee",
	"ef",
	"f0",
	"f1",
	"f2",
	"f3",
	"f4",
	"f5",
	"f6",
	"f7",
	"f8",
	"f9",
	"fa",
	"fb",
	"fc",
	"fd",
	"fe",
	"ff"
];
/** @internal */
const fromHexChar = (byte) => {
	if (48 <= byte && byte <= 57) return byte - 48;
	if (97 <= byte && byte <= 102) return byte - 97 + 10;
	if (65 <= byte && byte <= 70) return byte - 65 + 10;
	throw new TypeError("Invalid input");
};

//#endregion
//#region ../../node_modules/.bun/effect@3.17.14/node_modules/effect/dist/esm/Encoding.js
/**
* Encodes the given value into a base64 (RFC4648) `string`.
*
* @category encoding
* @since 2.0.0
*/
const encodeBase64 = (input) => typeof input === "string" ? encode$2(encoder.encode(input)) : encode$2(input);
/**
* Decodes a base64 (RFC4648) encoded `string` into a `Uint8Array`.
*
* @category decoding
* @since 2.0.0
*/
const decodeBase64 = (str) => decode$2(str);
/**
* Decodes a base64 (RFC4648) encoded `string` into a UTF-8 `string`.
*
* @category decoding
* @since 2.0.0
*/
const decodeBase64String = (str) => map$16(decodeBase64(str), (_) => decoder.decode(_));
/**
* Encodes the given value into a base64 (URL) `string`.
*
* @category encoding
* @since 2.0.0
*/
const encodeBase64Url = (input) => typeof input === "string" ? encode$1(encoder.encode(input)) : encode$1(input);
/**
* Decodes a base64 (URL) encoded `string` into a `Uint8Array`.
*
* @category decoding
* @since 2.0.0
*/
const decodeBase64Url = (str) => decode$1(str);
/**
* Decodes a base64 (URL) encoded `string` into a UTF-8 `string`.
*
* @category decoding
* @since 2.0.0
*/
const decodeBase64UrlString = (str) => map$16(decodeBase64Url(str), (_) => decoder.decode(_));
/**
* Encodes the given value into a hex `string`.
*
* @category encoding
* @since 2.0.0
*/
const encodeHex = (input) => typeof input === "string" ? encode(encoder.encode(input)) : encode(input);
/**
* Decodes a hex encoded `string` into a `Uint8Array`.
*
* @category decoding
* @since 2.0.0
*/
const decodeHex = (str) => decode(str);
/**
* Decodes a hex encoded `string` into a UTF-8 `string`.
*
* @category decoding
* @since 2.0.0
*/
const decodeHexString = (str) => map$16(decodeHex(str), (_) => decoder.decode(_));
/**
* @since 2.0.0
* @category symbols
*/
const DecodeExceptionTypeId = DecodeExceptionTypeId$1;
/**
* Creates a checked exception which occurs when decoding fails.
*
* @since 2.0.0
* @category errors
*/
const DecodeException = DecodeException$1;
/**
* Returns `true` if the specified value is an `DecodeException`, `false` otherwise.
*
* @since 2.0.0
* @category refinements
*/
const isDecodeException = isDecodeException$1;
/**
* @since 3.12.0
* @category symbols
*/
const EncodeExceptionTypeId = EncodeExceptionTypeId$1;
/**
* Creates a checked exception which occurs when encoding fails.
*
* @since 3.12.0
* @category errors
*/
const EncodeException = EncodeException$1;
/**
* Returns `true` if the specified value is an `EncodeException`, `false` otherwise.
*
* @since 3.12.0
* @category refinements
*/
const isEncodeException = isEncodeException$1;

//#endregion
//#region ../../node_modules/.bun/effect@3.17.14/node_modules/effect/dist/esm/Struct.js
/**
* Create a new object by picking properties of an existing object.
*
* @example
* ```ts
* import * as assert from "node:assert"
* import { pipe, Struct } from "effect"
*
* assert.deepStrictEqual(pipe({ a: "a", b: 1, c: true }, Struct.pick("a", "b")), { a: "a", b: 1 })
* assert.deepStrictEqual(Struct.pick({ a: "a", b: 1, c: true }, "a", "b"), { a: "a", b: 1 })
* ```
*
* @since 2.0.0
*/
const pick = /* @__PURE__ */ dual((args$1) => isObject$1(args$1[0]), (s, ...keys$5) => {
	const out = {};
	for (const k of keys$5) if (k in s) out[k] = s[k];
	return out;
});
/**
* Create a new object by omitting properties of an existing object.
*
* @example
* ```ts
* import * as assert from "node:assert"
* import { pipe, Struct } from "effect"
*
* assert.deepStrictEqual(pipe({ a: "a", b: 1, c: true }, Struct.omit("c")), { a: "a", b: 1 })
* assert.deepStrictEqual(Struct.omit({ a: "a", b: 1, c: true }, "c"), { a: "a", b: 1 })
* ```
*
* @since 2.0.0
*/
const omit = /* @__PURE__ */ dual((args$1) => isObject$1(args$1[0]), (s, ...keys$5) => {
	const out = { ...s };
	for (const k of keys$5) delete out[k];
	return out;
});
/**
* Given a struct of `Equivalence`s returns a new `Equivalence` that compares values of a struct
* by applying each `Equivalence` to the corresponding property of the struct.
*
* Alias of {@link Equivalence.struct}.
*
* @example
* ```ts
* import * as assert from "node:assert"
* import { Struct, String, Number } from "effect"
*
* const PersonEquivalence = Struct.getEquivalence({
*   name: String.Equivalence,
*   age: Number.Equivalence
* })
*
* assert.deepStrictEqual(
*   PersonEquivalence({ name: "John", age: 25 }, { name: "John", age: 25 }),
*   true
* )
* assert.deepStrictEqual(
*   PersonEquivalence({ name: "John", age: 25 }, { name: "John", age: 40 }),
*   false
* )
* ```
*
* @category combinators
* @since 2.0.0
*/
const getEquivalence = struct$3;
/**
* This function creates and returns a new `Order` for a struct of values based on the given `Order`s
* for each property in the struct.
*
* Alias of {@link order.struct}.
*
* @category combinators
* @since 2.0.0
*/
const getOrder = struct$2;

//#endregion
//#region ../../node_modules/.bun/@effect+schema@0.75.5+0487cae5baa0fa19/node_modules/@effect/schema/dist/esm/internal/util.js
/** @internal */
const getKeysForIndexSignature = (input, parameter) => {
	switch (parameter._tag) {
		case "StringKeyword":
		case "TemplateLiteral": return Object.keys(input);
		case "SymbolKeyword": return Object.getOwnPropertySymbols(input);
		case "Refinement": return getKeysForIndexSignature(input, parameter.from);
	}
};
/**
* JavaScript does not store the insertion order of properties in a way that
* combines both string and symbol keys. The internal order groups string keys
* and symbol keys separately. Hence concatenating the keys is fine.
*
* @internal
*/
const ownKeys = (o) => Object.keys(o).concat(Object.getOwnPropertySymbols(o));
/** @internal */
const memoizeThunk = (f) => {
	let done$8 = false;
	let a;
	return () => {
		if (done$8) return a;
		a = f();
		done$8 = true;
		return a;
	};
};
/** @internal */
const formatDate = (date) => {
	try {
		return date.toISOString();
	} catch (e) {
		return String(date);
	}
};
/** @internal */
const formatUnknown$1 = (u) => {
	if (isString(u)) return JSON.stringify(u);
	else if (isNumber$1(u) || u == null || isBoolean$1(u) || isSymbol(u)) return String(u);
	else if (isDate(u)) return formatDate(u);
	else if (isBigInt(u)) return String(u) + "n";
	else if (!isArray(u) && hasProperty(u, "toString") && isFunction(u["toString"]) && u["toString"] !== Object.prototype.toString) return u["toString"]();
	try {
		JSON.stringify(u);
		if (isArray(u)) return `[${u.map(formatUnknown$1).join(",")}]`;
		else return `{${ownKeys(u).map((k) => `${isString(k) ? JSON.stringify(k) : String(k)}:${formatUnknown$1(u[k])}`).join(",")}}`;
	} catch (e) {
		return String(u);
	}
};
/** @internal */
const formatPropertyKey$1 = (name) => typeof name === "string" ? JSON.stringify(name) : String(name);
/** @internal */
const isNonEmpty = (x) => Array.isArray(x);
/** @internal */
const isSingle = (x) => !Array.isArray(x);
/** @internal */
const formatPathKey = (key) => `[${formatPropertyKey$1(key)}]`;
/** @internal */
const formatPath = (path) => isNonEmpty(path) ? path.map(formatPathKey).join("") : formatPathKey(path);

//#endregion
//#region ../../node_modules/.bun/@effect+schema@0.75.5+0487cae5baa0fa19/node_modules/@effect/schema/dist/esm/internal/errors.js
const getErrorMessage = (reason, details, path, ast) => {
	let out = reason;
	if (path && isNonEmptyReadonlyArray(path)) out += `\nat path: ${formatPath(path)}`;
	if (details !== void 0) out += `\ndetails: ${details}`;
	if (ast) out += `\nschema (${ast._tag}): ${ast}`;
	return out;
};
/** @internal */
const getASTUnsupportedKeySchema = (ast) => getErrorMessage("Unsupported key schema", void 0, void 0, ast);
/** @internal */
const getASTUnsupportedLiteral = (literal) => getErrorMessage("Unsupported literal", `literal value: ${formatUnknown$1(literal)}`);
/** @internal */
const getASTDuplicateIndexSignatureErrorMessage = (type) => getErrorMessage("Duplicate index signature", `${type} index signature`);
/** @internal */
const getASTIndexSignatureParameterErrorMessage = /* @__PURE__ */ getErrorMessage("Unsupported index signature parameter", "An index signature parameter type must be `string`, `symbol`, a template literal type or a refinement of the previous types");
/** @internal */
const getASTRequiredElementFollowinAnOptionalElementErrorMessage = /* @__PURE__ */ getErrorMessage("Invalid element", "A required element cannot follow an optional element. ts(1257)");
/** @internal */
const getASTDuplicatePropertySignatureTransformationErrorMessage = (key) => getErrorMessage("Duplicate property signature transformation", `Duplicate key ${formatUnknown$1(key)}`);
/** @internal */
const getASTDuplicatePropertySignatureErrorMessage = (key) => getErrorMessage("Duplicate property signature", `Duplicate key ${formatUnknown$1(key)}`);

//#endregion
//#region ../../node_modules/.bun/@effect+schema@0.75.5+0487cae5baa0fa19/node_modules/@effect/schema/dist/esm/AST.js
/**
* @category annotations
* @since 0.67.0
*/
const TypeAnnotationId = /* @__PURE__ */ Symbol.for("@effect/schema/annotation/Type");
/**
* @category annotations
* @since 0.67.0
*/
const MessageAnnotationId = /* @__PURE__ */ Symbol.for("@effect/schema/annotation/Message");
/**
* @category annotations
* @since 0.67.0
*/
const MissingMessageAnnotationId = /* @__PURE__ */ Symbol.for("@effect/schema/annotation/MissingMessage");
/**
* @category annotations
* @since 0.67.0
*/
const IdentifierAnnotationId = /* @__PURE__ */ Symbol.for("@effect/schema/annotation/Identifier");
/**
* @category annotations
* @since 0.67.0
*/
const TitleAnnotationId = /* @__PURE__ */ Symbol.for("@effect/schema/annotation/Title");
/**
* @category annotations
* @since 0.67.0
*/
const DescriptionAnnotationId = /* @__PURE__ */ Symbol.for("@effect/schema/annotation/Description");
/**
* @category annotations
* @since 0.67.0
*/
const ExamplesAnnotationId = /* @__PURE__ */ Symbol.for("@effect/schema/annotation/Examples");
/**
* @category annotations
* @since 0.67.0
*/
const DefaultAnnotationId = /* @__PURE__ */ Symbol.for("@effect/schema/annotation/Default");
/**
* @category annotations
* @since 0.67.0
*/
const JSONSchemaAnnotationId = /* @__PURE__ */ Symbol.for("@effect/schema/annotation/JSONSchema");
/**
* @category annotations
* @since 0.67.0
*/
const DocumentationAnnotationId = /* @__PURE__ */ Symbol.for("@effect/schema/annotation/Documentation");
/**
* @category annotations
* @since 0.67.0
*/
const ConcurrencyAnnotationId = /* @__PURE__ */ Symbol.for("@effect/schema/annotation/Concurrency");
/**
* @category annotations
* @since 0.67.0
*/
const BatchingAnnotationId = /* @__PURE__ */ Symbol.for("@effect/schema/annotation/Batching");
/**
* @category annotations
* @since 0.67.0
*/
const ParseIssueTitleAnnotationId = /* @__PURE__ */ Symbol.for("@effect/schema/annotation/ParseIssueTitle");
/**
* @category annotations
* @since 0.68.3
*/
const ParseOptionsAnnotationId = /* @__PURE__ */ Symbol.for("@effect/schema/annotation/ParseOptions");
/**
* @category annotations
* @since 0.70.1
*/
const DecodingFallbackAnnotationId = /* @__PURE__ */ Symbol.for("@effect/schema/annotation/DecodingFallback");
/** @internal */
const SurrogateAnnotationId = /* @__PURE__ */ Symbol.for("@effect/schema/annotation/Surrogate");
/** @internal */
const StableFilterAnnotationId = /* @__PURE__ */ Symbol.for("@effect/schema/annotation/StableFilter");
/**
* @category annotations
* @since 0.67.0
*/
const getAnnotation = /* @__PURE__ */ dual(2, (annotated, key) => Object.prototype.hasOwnProperty.call(annotated.annotations, key) ? some$4(annotated.annotations[key]) : none$7());
/**
* @category annotations
* @since 0.67.0
*/
const getMessageAnnotation = /* @__PURE__ */ getAnnotation(MessageAnnotationId);
/**
* @category annotations
* @since 0.67.0
*/
const getMissingMessageAnnotation = /* @__PURE__ */ getAnnotation(MissingMessageAnnotationId);
/**
* @category annotations
* @since 0.67.0
*/
const getTitleAnnotation = /* @__PURE__ */ getAnnotation(TitleAnnotationId);
/**
* @category annotations
* @since 0.67.0
*/
const getIdentifierAnnotation = /* @__PURE__ */ getAnnotation(IdentifierAnnotationId);
/**
* @category annotations
* @since 0.67.0
*/
const getDescriptionAnnotation = /* @__PURE__ */ getAnnotation(DescriptionAnnotationId);
/**
* @category annotations
* @since 0.67.0
*/
const getConcurrencyAnnotation = /* @__PURE__ */ getAnnotation(ConcurrencyAnnotationId);
/**
* @category annotations
* @since 0.67.0
*/
const getBatchingAnnotation = /* @__PURE__ */ getAnnotation(BatchingAnnotationId);
/**
* @category annotations
* @since 0.67.0
*/
const getParseIssueTitleAnnotation$1 = /* @__PURE__ */ getAnnotation(ParseIssueTitleAnnotationId);
/**
* @category annotations
* @since 0.68.3
*/
const getParseOptionsAnnotation = /* @__PURE__ */ getAnnotation(ParseOptionsAnnotationId);
/**
* @category annotations
* @since 0.70.1
*/
const getDecodingFallbackAnnotation = /* @__PURE__ */ getAnnotation(DecodingFallbackAnnotationId);
/** @internal */
const getSurrogateAnnotation = /* @__PURE__ */ getAnnotation(SurrogateAnnotationId);
const getStableFilterAnnotation = /* @__PURE__ */ getAnnotation(StableFilterAnnotationId);
/** @internal */
const hasStableFilter = (annotated) => exists$3(getStableFilterAnnotation(annotated), (b) => b === true);
const JSONIdentifierAnnotationId = /* @__PURE__ */ Symbol.for("@effect/schema/annotation/JSONIdentifier");
/** @internal */
const getJSONIdentifierAnnotation = /* @__PURE__ */ getAnnotation(JSONIdentifierAnnotationId);
/**
* @category model
* @since 0.67.0
*/
var Declaration = class {
	typeParameters;
	decodeUnknown;
	encodeUnknown;
	annotations;
	/**
	* @since 0.67.0
	*/
	_tag = "Declaration";
	constructor(typeParameters, decodeUnknown, encodeUnknown, annotations$1 = {}) {
		this.typeParameters = typeParameters;
		this.decodeUnknown = decodeUnknown;
		this.encodeUnknown = encodeUnknown;
		this.annotations = annotations$1;
	}
	/**
	* @since 0.67.0
	*/
	toString() {
		return getOrElse$5(getExpected(this), () => "<declaration schema>");
	}
	/**
	* @since 0.67.0
	*/
	toJSON() {
		return {
			_tag: this._tag,
			typeParameters: this.typeParameters.map((ast) => ast.toJSON()),
			annotations: toJSONAnnotations(this.annotations)
		};
	}
};
const createASTGuard = (tag) => (ast) => ast._tag === tag;
/**
* @category model
* @since 0.67.0
*/
var Literal = class {
	literal;
	annotations;
	/**
	* @since 0.67.0
	*/
	_tag = "Literal";
	constructor(literal, annotations$1 = {}) {
		this.literal = literal;
		this.annotations = annotations$1;
	}
	/**
	* @since 0.67.0
	*/
	toString() {
		return getOrElse$5(getExpected(this), () => formatUnknown$1(this.literal));
	}
	/**
	* @since 0.67.0
	*/
	toJSON() {
		return {
			_tag: this._tag,
			literal: isBigInt(this.literal) ? String(this.literal) : this.literal,
			annotations: toJSONAnnotations(this.annotations)
		};
	}
};
/**
* @category guards
* @since 0.67.0
*/
const isLiteral = /* @__PURE__ */ createASTGuard("Literal");
/**
* @category model
* @since 0.67.0
*/
var UniqueSymbol = class {
	symbol;
	annotations;
	/**
	* @since 0.67.0
	*/
	_tag = "UniqueSymbol";
	constructor(symbol$2, annotations$1 = {}) {
		this.symbol = symbol$2;
		this.annotations = annotations$1;
	}
	/**
	* @since 0.67.0
	*/
	toString() {
		return getOrElse$5(getExpected(this), () => formatUnknown$1(this.symbol));
	}
	/**
	* @since 0.67.0
	*/
	toJSON() {
		return {
			_tag: this._tag,
			symbol: String(this.symbol),
			annotations: toJSONAnnotations(this.annotations)
		};
	}
};
/**
* @category model
* @since 0.67.0
*/
var UndefinedKeyword = class {
	annotations;
	/**
	* @since 0.67.0
	*/
	_tag = "UndefinedKeyword";
	constructor(annotations$1 = {}) {
		this.annotations = annotations$1;
	}
	/**
	* @since 0.67.0
	*/
	toString() {
		return formatKeyword(this);
	}
	/**
	* @since 0.67.0
	*/
	toJSON() {
		return {
			_tag: this._tag,
			annotations: toJSONAnnotations(this.annotations)
		};
	}
};
/**
* @category constructors
* @since 0.67.0
*/
const undefinedKeyword = /* @__PURE__ */ new UndefinedKeyword({ [TitleAnnotationId]: "undefined" });
/**
* @category model
* @since 0.67.0
*/
var VoidKeyword = class {
	annotations;
	/**
	* @since 0.67.0
	*/
	_tag = "VoidKeyword";
	constructor(annotations$1 = {}) {
		this.annotations = annotations$1;
	}
	/**
	* @since 0.67.0
	*/
	toString() {
		return formatKeyword(this);
	}
	/**
	* @since 0.67.0
	*/
	toJSON() {
		return {
			_tag: this._tag,
			annotations: toJSONAnnotations(this.annotations)
		};
	}
};
/**
* @category constructors
* @since 0.67.0
*/
const voidKeyword = /* @__PURE__ */ new VoidKeyword({ [TitleAnnotationId]: "void" });
/**
* @category model
* @since 0.67.0
*/
var NeverKeyword = class {
	annotations;
	/**
	* @since 0.67.0
	*/
	_tag = "NeverKeyword";
	constructor(annotations$1 = {}) {
		this.annotations = annotations$1;
	}
	/**
	* @since 0.67.0
	*/
	toString() {
		return formatKeyword(this);
	}
	/**
	* @since 0.67.0
	*/
	toJSON() {
		return {
			_tag: this._tag,
			annotations: toJSONAnnotations(this.annotations)
		};
	}
};
/**
* @category constructors
* @since 0.67.0
*/
const neverKeyword = /* @__PURE__ */ new NeverKeyword({ [TitleAnnotationId]: "never" });
/**
* @category model
* @since 0.67.0
*/
var UnknownKeyword = class {
	annotations;
	/**
	* @since 0.67.0
	*/
	_tag = "UnknownKeyword";
	constructor(annotations$1 = {}) {
		this.annotations = annotations$1;
	}
	/**
	* @since 0.67.0
	*/
	toString() {
		return formatKeyword(this);
	}
	/**
	* @since 0.67.0
	*/
	toJSON() {
		return {
			_tag: this._tag,
			annotations: toJSONAnnotations(this.annotations)
		};
	}
};
/**
* @category constructors
* @since 0.67.0
*/
const unknownKeyword = /* @__PURE__ */ new UnknownKeyword({ [TitleAnnotationId]: "unknown" });
/**
* @category model
* @since 0.67.0
*/
var AnyKeyword = class {
	annotations;
	/**
	* @since 0.67.0
	*/
	_tag = "AnyKeyword";
	constructor(annotations$1 = {}) {
		this.annotations = annotations$1;
	}
	/**
	* @since 0.67.0
	*/
	toString() {
		return formatKeyword(this);
	}
	/**
	* @since 0.67.0
	*/
	toJSON() {
		return {
			_tag: this._tag,
			annotations: toJSONAnnotations(this.annotations)
		};
	}
};
/**
* @category constructors
* @since 0.67.0
*/
const anyKeyword = /* @__PURE__ */ new AnyKeyword({ [TitleAnnotationId]: "any" });
/**
* @category model
* @since 0.67.0
*/
var StringKeyword = class {
	annotations;
	/**
	* @since 0.67.0
	*/
	_tag = "StringKeyword";
	constructor(annotations$1 = {}) {
		this.annotations = annotations$1;
	}
	/**
	* @since 0.67.0
	*/
	toString() {
		return formatKeyword(this);
	}
	/**
	* @since 0.67.0
	*/
	toJSON() {
		return {
			_tag: this._tag,
			annotations: toJSONAnnotations(this.annotations)
		};
	}
};
/**
* @category constructors
* @since 0.67.0
*/
const stringKeyword = /* @__PURE__ */ new StringKeyword({
	[TitleAnnotationId]: "string",
	[DescriptionAnnotationId]: "a string"
});
/**
* @category guards
* @since 0.67.0
*/
const isStringKeyword = /* @__PURE__ */ createASTGuard("StringKeyword");
/**
* @category model
* @since 0.67.0
*/
var NumberKeyword = class {
	annotations;
	/**
	* @since 0.67.0
	*/
	_tag = "NumberKeyword";
	constructor(annotations$1 = {}) {
		this.annotations = annotations$1;
	}
	/**
	* @since 0.67.0
	*/
	toString() {
		return formatKeyword(this);
	}
	/**
	* @since 0.67.0
	*/
	toJSON() {
		return {
			_tag: this._tag,
			annotations: toJSONAnnotations(this.annotations)
		};
	}
};
/**
* @category constructors
* @since 0.67.0
*/
const numberKeyword = /* @__PURE__ */ new NumberKeyword({
	[TitleAnnotationId]: "number",
	[DescriptionAnnotationId]: "a number"
});
/**
* @category guards
* @since 0.67.0
*/
const isNumberKeyword = /* @__PURE__ */ createASTGuard("NumberKeyword");
/**
* @category model
* @since 0.67.0
*/
var BooleanKeyword = class {
	annotations;
	/**
	* @since 0.67.0
	*/
	_tag = "BooleanKeyword";
	constructor(annotations$1 = {}) {
		this.annotations = annotations$1;
	}
	/**
	* @since 0.67.0
	*/
	toString() {
		return formatKeyword(this);
	}
	/**
	* @since 0.67.0
	*/
	toJSON() {
		return {
			_tag: this._tag,
			annotations: toJSONAnnotations(this.annotations)
		};
	}
};
/**
* @category constructors
* @since 0.67.0
*/
const booleanKeyword = /* @__PURE__ */ new BooleanKeyword({
	[TitleAnnotationId]: "boolean",
	[DescriptionAnnotationId]: "a boolean"
});
/**
* @category model
* @since 0.67.0
*/
var BigIntKeyword = class {
	annotations;
	/**
	* @since 0.67.0
	*/
	_tag = "BigIntKeyword";
	constructor(annotations$1 = {}) {
		this.annotations = annotations$1;
	}
	/**
	* @since 0.67.0
	*/
	toString() {
		return formatKeyword(this);
	}
	/**
	* @since 0.67.0
	*/
	toJSON() {
		return {
			_tag: this._tag,
			annotations: toJSONAnnotations(this.annotations)
		};
	}
};
/**
* @category constructors
* @since 0.67.0
*/
const bigIntKeyword = /* @__PURE__ */ new BigIntKeyword({
	[TitleAnnotationId]: "bigint",
	[DescriptionAnnotationId]: "a bigint"
});
/**
* @category model
* @since 0.67.0
*/
var SymbolKeyword = class {
	annotations;
	/**
	* @since 0.67.0
	*/
	_tag = "SymbolKeyword";
	constructor(annotations$1 = {}) {
		this.annotations = annotations$1;
	}
	/**
	* @since 0.67.0
	*/
	toString() {
		return formatKeyword(this);
	}
	/**
	* @since 0.67.0
	*/
	toJSON() {
		return {
			_tag: this._tag,
			annotations: toJSONAnnotations(this.annotations)
		};
	}
};
/**
* @category constructors
* @since 0.67.0
*/
const symbolKeyword = /* @__PURE__ */ new SymbolKeyword({
	[TitleAnnotationId]: "symbol",
	[DescriptionAnnotationId]: "a symbol"
});
/**
* @category guards
* @since 0.67.0
*/
const isSymbolKeyword = /* @__PURE__ */ createASTGuard("SymbolKeyword");
/**
* @category model
* @since 0.67.0
*/
var ObjectKeyword = class {
	annotations;
	/**
	* @since 0.67.0
	*/
	_tag = "ObjectKeyword";
	constructor(annotations$1 = {}) {
		this.annotations = annotations$1;
	}
	/**
	* @since 0.67.0
	*/
	toString() {
		return formatKeyword(this);
	}
	/**
	* @since 0.67.0
	*/
	toJSON() {
		return {
			_tag: this._tag,
			annotations: toJSONAnnotations(this.annotations)
		};
	}
};
/**
* @category constructors
* @since 0.67.0
*/
const objectKeyword = /* @__PURE__ */ new ObjectKeyword({
	[TitleAnnotationId]: "object",
	[DescriptionAnnotationId]: "an object in the TypeScript meaning, i.e. the `object` type"
});
/**
* @category model
* @since 0.68.0
*/
var Type$1 = class {
	type;
	annotations;
	constructor(type, annotations$1 = {}) {
		this.type = type;
		this.annotations = annotations$1;
	}
	/**
	* @since 0.68.0
	*/
	toJSON() {
		return {
			type: this.type.toJSON(),
			annotations: toJSONAnnotations(this.annotations)
		};
	}
	/**
	* @since 0.68.0
	*/
	toString() {
		return String(this.type);
	}
};
/**
* @category model
* @since 0.68.0
*/
var OptionalType = class extends Type$1 {
	isOptional;
	constructor(type, isOptional, annotations$1 = {}) {
		super(type, annotations$1);
		this.isOptional = isOptional;
	}
	/**
	* @since 0.68.0
	*/
	toJSON() {
		return {
			type: this.type.toJSON(),
			isOptional: this.isOptional,
			annotations: toJSONAnnotations(this.annotations)
		};
	}
	/**
	* @since 0.68.0
	*/
	toString() {
		return String(this.type) + (this.isOptional ? "?" : "");
	}
};
const getRestASTs = (rest) => rest.map((annotatedAST) => annotatedAST.type);
/**
* @category model
* @since 0.67.0
*/
var TupleType = class {
	elements;
	rest;
	isReadonly;
	annotations;
	/**
	* @since 0.67.0
	*/
	_tag = "TupleType";
	constructor(elements, rest, isReadonly, annotations$1 = {}) {
		this.elements = elements;
		this.rest = rest;
		this.isReadonly = isReadonly;
		this.annotations = annotations$1;
		let hasOptionalElement = false;
		let hasIllegalRequiredElement = false;
		for (const e of elements) if (e.isOptional) hasOptionalElement = true;
		else if (hasOptionalElement) {
			hasIllegalRequiredElement = true;
			break;
		}
		if (hasIllegalRequiredElement || hasOptionalElement && rest.length > 1) throw new Error(getASTRequiredElementFollowinAnOptionalElementErrorMessage);
	}
	/**
	* @since 0.67.0
	*/
	toString() {
		return getOrElse$5(getExpected(this), () => formatTuple(this));
	}
	/**
	* @since 0.67.0
	*/
	toJSON() {
		return {
			_tag: this._tag,
			elements: this.elements.map((e) => e.toJSON()),
			rest: this.rest.map((ast) => ast.toJSON()),
			isReadonly: this.isReadonly,
			annotations: toJSONAnnotations(this.annotations)
		};
	}
};
const formatTuple = (ast) => {
	const formattedElements = ast.elements.map(String).join(", ");
	return matchLeft(ast.rest, {
		onEmpty: () => `readonly [${formattedElements}]`,
		onNonEmpty: (head$4, tail) => {
			const formattedHead = String(head$4);
			const wrappedHead = formattedHead.includes(" | ") ? `(${formattedHead})` : formattedHead;
			if (tail.length > 0) {
				const formattedTail = tail.map(String).join(", ");
				if (ast.elements.length > 0) return `readonly [${formattedElements}, ...${wrappedHead}[], ${formattedTail}]`;
				else return `readonly [...${wrappedHead}[], ${formattedTail}]`;
			} else if (ast.elements.length > 0) return `readonly [${formattedElements}, ...${wrappedHead}[]]`;
			else return `ReadonlyArray<${formattedHead}>`;
		}
	});
};
/**
* @category model
* @since 0.67.0
*/
var PropertySignature = class extends OptionalType {
	name;
	isReadonly;
	constructor(name, type, isOptional, isReadonly, annotations$1) {
		super(type, isOptional, annotations$1);
		this.name = name;
		this.isReadonly = isReadonly;
	}
	/**
	* @since 0.68.18
	*/
	toString() {
		return (this.isReadonly ? "readonly " : "") + String(this.name) + (this.isOptional ? "?" : "") + ": " + this.type;
	}
	/**
	* @since 0.67.0
	*/
	toJSON() {
		return {
			name: String(this.name),
			type: this.type.toJSON(),
			isOptional: this.isOptional,
			isReadonly: this.isReadonly,
			annotations: toJSONAnnotations(this.annotations)
		};
	}
};
/**
* @since 0.67.0
*/
const isParameter = (ast) => {
	switch (ast._tag) {
		case "StringKeyword":
		case "SymbolKeyword":
		case "TemplateLiteral": return true;
		case "Refinement": return isParameter(ast.from);
	}
	return false;
};
/**
* @category model
* @since 0.67.0
*/
var IndexSignature = class {
	type;
	isReadonly;
	/**
	* @since 0.67.0
	*/
	parameter;
	constructor(parameter, type, isReadonly) {
		this.type = type;
		this.isReadonly = isReadonly;
		if (isParameter(parameter)) this.parameter = parameter;
		else throw new Error(getASTIndexSignatureParameterErrorMessage);
	}
	/**
	* @since 0.68.18
	*/
	toString() {
		return (this.isReadonly ? "readonly " : "") + `[x: ${this.parameter}]: ${this.type}`;
	}
	/**
	* @since 0.67.0
	*/
	toJSON() {
		return {
			parameter: this.parameter.toJSON(),
			type: this.type.toJSON(),
			isReadonly: this.isReadonly
		};
	}
};
/**
* @category model
* @since 0.67.0
*/
var TypeLiteral = class {
	annotations;
	/**
	* @since 0.67.0
	*/
	_tag = "TypeLiteral";
	/**
	* @since 0.67.0
	*/
	propertySignatures;
	/**
	* @since 0.67.0
	*/
	indexSignatures;
	constructor(propertySignatures, indexSignatures, annotations$1 = {}) {
		this.annotations = annotations$1;
		const keys$5 = {};
		for (let i = 0; i < propertySignatures.length; i++) {
			const name = propertySignatures[i].name;
			if (Object.prototype.hasOwnProperty.call(keys$5, name)) throw new Error(getASTDuplicatePropertySignatureErrorMessage(name));
			keys$5[name] = null;
		}
		const parameters = {
			string: false,
			symbol: false
		};
		for (let i = 0; i < indexSignatures.length; i++) {
			const parameter = getParameterBase(indexSignatures[i].parameter);
			if (isStringKeyword(parameter)) {
				if (parameters.string) throw new Error(getASTDuplicateIndexSignatureErrorMessage("string"));
				parameters.string = true;
			} else if (isSymbolKeyword(parameter)) {
				if (parameters.symbol) throw new Error(getASTDuplicateIndexSignatureErrorMessage("symbol"));
				parameters.symbol = true;
			}
		}
		this.propertySignatures = propertySignatures;
		this.indexSignatures = indexSignatures;
	}
	/**
	* @since 0.67.0
	*/
	toString() {
		return getOrElse$5(getExpected(this), () => formatTypeLiteral(this));
	}
	/**
	* @since 0.67.0
	*/
	toJSON() {
		return {
			_tag: this._tag,
			propertySignatures: this.propertySignatures.map((ps) => ps.toJSON()),
			indexSignatures: this.indexSignatures.map((ps) => ps.toJSON()),
			annotations: toJSONAnnotations(this.annotations)
		};
	}
};
const formatIndexSignatures = (iss) => iss.map(String).join("; ");
const formatTypeLiteral = (ast) => {
	if (ast.propertySignatures.length > 0) {
		const pss = ast.propertySignatures.map(String).join("; ");
		if (ast.indexSignatures.length > 0) return `{ ${pss}; ${formatIndexSignatures(ast.indexSignatures)} }`;
		else return `{ ${pss} }`;
	} else if (ast.indexSignatures.length > 0) return `{ ${formatIndexSignatures(ast.indexSignatures)} }`;
	else return "{}";
};
const sortCandidates = /* @__PURE__ */ sort(/* @__PURE__ */ mapInput(Order$3, (ast) => {
	switch (ast._tag) {
		case "AnyKeyword": return 0;
		case "UnknownKeyword": return 1;
		case "ObjectKeyword": return 2;
		case "StringKeyword":
		case "NumberKeyword":
		case "BooleanKeyword":
		case "BigIntKeyword":
		case "SymbolKeyword": return 3;
	}
	return 4;
}));
const literalMap = {
	string: "StringKeyword",
	number: "NumberKeyword",
	boolean: "BooleanKeyword",
	bigint: "BigIntKeyword"
};
/** @internal */
const flatten = (candidates) => flatMap$10(candidates, (ast) => isUnion(ast) ? flatten(ast.types) : [ast]);
/** @internal */
const unify = (candidates) => {
	const cs = sortCandidates(candidates);
	const out = [];
	const uniques = {};
	const literals = [];
	for (const ast of cs) switch (ast._tag) {
		case "NeverKeyword": break;
		case "AnyKeyword": return [anyKeyword];
		case "UnknownKeyword": return [unknownKeyword];
		case "ObjectKeyword":
		case "UndefinedKeyword":
		case "VoidKeyword":
		case "StringKeyword":
		case "NumberKeyword":
		case "BooleanKeyword":
		case "BigIntKeyword":
		case "SymbolKeyword":
			if (!uniques[ast._tag]) {
				uniques[ast._tag] = ast;
				out.push(ast);
			}
			break;
		case "Literal": {
			const type = typeof ast.literal;
			switch (type) {
				case "string":
				case "number":
				case "bigint":
				case "boolean": {
					const _tag = literalMap[type];
					if (!uniques[_tag] && !literals.includes(ast.literal)) {
						literals.push(ast.literal);
						out.push(ast);
					}
					break;
				}
				case "object":
					if (!literals.includes(ast.literal)) {
						literals.push(ast.literal);
						out.push(ast);
					}
					break;
			}
			break;
		}
		case "UniqueSymbol":
			if (!uniques["SymbolKeyword"] && !literals.includes(ast.symbol)) {
				literals.push(ast.symbol);
				out.push(ast);
			}
			break;
		case "TupleType":
			if (!uniques["ObjectKeyword"]) out.push(ast);
			break;
		case "TypeLiteral":
			if (ast.propertySignatures.length === 0 && ast.indexSignatures.length === 0) {
				if (!uniques["{}"]) {
					uniques["{}"] = ast;
					out.push(ast);
				}
			} else if (!uniques["ObjectKeyword"]) out.push(ast);
			break;
		default: out.push(ast);
	}
	return out;
};
/**
* @category model
* @since 0.67.0
*/
var Union$1 = class Union$1 {
	types;
	annotations;
	static make = (types, annotations$1) => {
		return isMembers(types) ? new Union$1(types, annotations$1) : types.length === 1 ? types[0] : neverKeyword;
	};
	/** @internal */
	static unify = (candidates, annotations$1) => {
		return Union$1.make(unify(flatten(candidates)), annotations$1);
	};
	/**
	* @since 0.67.0
	*/
	_tag = "Union";
	constructor(types, annotations$1 = {}) {
		this.types = types;
		this.annotations = annotations$1;
	}
	/**
	* @since 0.67.0
	*/
	toString() {
		return getOrElse$5(getExpected(this), () => this.types.map(String).join(" | "));
	}
	/**
	* @since 0.67.0
	*/
	toJSON() {
		return {
			_tag: this._tag,
			types: this.types.map((ast) => ast.toJSON()),
			annotations: toJSONAnnotations(this.annotations)
		};
	}
};
/** @internal */
const isMembers = (as$4) => as$4.length > 1;
/**
* @category guards
* @since 0.67.0
*/
const isUnion = /* @__PURE__ */ createASTGuard("Union");
const toJSONMemoMap = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("@effect/schema/AST/toJSONMemoMap"), () => /* @__PURE__ */ new WeakMap());
/**
* @category model
* @since 0.67.0
*/
var Suspend = class {
	f;
	annotations;
	/**
	* @since 0.67.0
	*/
	_tag = "Suspend";
	constructor(f, annotations$1 = {}) {
		this.f = f;
		this.annotations = annotations$1;
		this.f = memoizeThunk(f);
	}
	/**
	* @since 0.67.0
	*/
	toString() {
		return getExpected(this).pipe(orElse$5(() => flatMap$11(liftThrowable(this.f)(), (ast) => getExpected(ast))), getOrElse$5(() => "<suspended schema>"));
	}
	/**
	* @since 0.67.0
	*/
	toJSON() {
		const ast = this.f();
		let out = toJSONMemoMap.get(ast);
		if (out) return out;
		toJSONMemoMap.set(ast, { _tag: this._tag });
		out = {
			_tag: this._tag,
			ast: ast.toJSON(),
			annotations: toJSONAnnotations(this.annotations)
		};
		toJSONMemoMap.set(ast, out);
		return out;
	}
};
/**
* @category model
* @since 0.67.0
*/
var Refinement$1 = class {
	from;
	filter;
	annotations;
	/**
	* @since 0.67.0
	*/
	_tag = "Refinement";
	constructor(from, filter$7, annotations$1 = {}) {
		this.from = from;
		this.filter = filter$7;
		this.annotations = annotations$1;
	}
	/**
	* @since 0.67.0
	*/
	toString() {
		return getOrElse$5(getExpected(this), () => `{ ${this.from} | filter }`);
	}
	/**
	* @since 0.67.0
	*/
	toJSON() {
		return {
			_tag: this._tag,
			from: this.from.toJSON(),
			annotations: toJSONAnnotations(this.annotations)
		};
	}
};
/**
* @category guards
* @since 0.67.0
*/
const isRefinement$1 = /* @__PURE__ */ createASTGuard("Refinement");
/**
* @since 0.67.0
*/
const defaultParseOption = {};
/**
* @category model
* @since 0.67.0
*/
var Transformation$1 = class {
	from;
	to;
	transformation;
	annotations;
	/**
	* @since 0.67.0
	*/
	_tag = "Transformation";
	constructor(from, to, transformation, annotations$1 = {}) {
		this.from = from;
		this.to = to;
		this.transformation = transformation;
		this.annotations = annotations$1;
	}
	/**
	* @since 0.67.0
	*/
	toString() {
		return getOrElse$5(getExpected(this), () => `(${String(this.from)} <-> ${String(this.to)})`);
	}
	/**
	* @since 0.67.0
	*/
	toJSON() {
		return {
			_tag: this._tag,
			from: this.from.toJSON(),
			to: this.to.toJSON(),
			annotations: toJSONAnnotations(this.annotations)
		};
	}
};
/**
* @category guards
* @since 0.67.0
*/
const isTransformation$1 = /* @__PURE__ */ createASTGuard("Transformation");
/**
* @category model
* @since 0.67.0
*/
var FinalTransformation = class {
	decode;
	encode;
	/**
	* @since 0.67.0
	*/
	_tag = "FinalTransformation";
	constructor(decode$4, encode$3) {
		this.decode = decode$4;
		this.encode = encode$3;
	}
};
/**
* Represents a `PropertySignature -> PropertySignature` transformation
*
* The semantic of `decode` is:
* - `none()` represents the absence of the key/value pair
* - `some(value)` represents the presence of the key/value pair
*
* The semantic of `encode` is:
* - `none()` you don't want to output the key/value pair
* - `some(value)` you want to output the key/value pair
*
* @category model
* @since 0.67.0
*/
var PropertySignatureTransformation$1 = class {
	from;
	to;
	decode;
	encode;
	constructor(from, to, decode$4, encode$3) {
		this.from = from;
		this.to = to;
		this.decode = decode$4;
		this.encode = encode$3;
	}
};
/**
* @category model
* @since 0.67.0
*/
var TypeLiteralTransformation = class {
	propertySignatureTransformations;
	/**
	* @since 0.67.0
	*/
	_tag = "TypeLiteralTransformation";
	constructor(propertySignatureTransformations) {
		this.propertySignatureTransformations = propertySignatureTransformations;
		const fromKeys = {};
		const toKeys = {};
		for (const pst of propertySignatureTransformations) {
			const from = pst.from;
			if (fromKeys[from]) throw new Error(getASTDuplicatePropertySignatureTransformationErrorMessage(from));
			fromKeys[from] = true;
			const to = pst.to;
			if (toKeys[to]) throw new Error(getASTDuplicatePropertySignatureTransformationErrorMessage(to));
			toKeys[to] = true;
		}
	}
};
/**
* Merges a set of new annotations with existing ones, potentially overwriting
* any duplicates.
*
* @since 0.67.0
*/
const annotations = (ast, annotations$1) => {
	const d = Object.getOwnPropertyDescriptors(ast);
	d.annotations.value = {
		...ast.annotations,
		...annotations$1
	};
	return Object.create(Object.getPrototypeOf(ast), d);
};
const STRING_KEYWORD_PATTERN = ".*";
const NUMBER_KEYWORD_PATTERN = "[+-]?\\d*\\.?\\d+(?:[Ee][+-]?\\d+)?";
/**
* @since 0.67.0
*/
const getTemplateLiteralRegExp = (ast) => {
	let pattern$1 = `^${escape(ast.head)}`;
	for (const span$1 of ast.spans) {
		if (isStringKeyword(span$1.type)) pattern$1 += STRING_KEYWORD_PATTERN;
		else if (isNumberKeyword(span$1.type)) pattern$1 += NUMBER_KEYWORD_PATTERN;
		pattern$1 += escape(span$1.literal);
	}
	pattern$1 += "$";
	return new RegExp(pattern$1);
};
/** @internal */
const record = (key, value) => {
	const propertySignatures = [];
	const indexSignatures = [];
	const go$2 = (key$1) => {
		switch (key$1._tag) {
			case "NeverKeyword": break;
			case "StringKeyword":
			case "SymbolKeyword":
			case "TemplateLiteral":
			case "Refinement":
				indexSignatures.push(new IndexSignature(key$1, value, true));
				break;
			case "Literal":
				if (isString(key$1.literal) || isNumber$1(key$1.literal)) propertySignatures.push(new PropertySignature(key$1.literal, value, false, true));
				else throw new Error(getASTUnsupportedLiteral(key$1.literal));
				break;
			case "Enums":
				for (const [_, name] of key$1.enums) propertySignatures.push(new PropertySignature(name, value, false, true));
				break;
			case "UniqueSymbol":
				propertySignatures.push(new PropertySignature(key$1.symbol, value, false, true));
				break;
			case "Union":
				key$1.types.forEach(go$2);
				break;
			default: throw new Error(getASTUnsupportedKeySchema(key$1));
		}
	};
	go$2(key);
	return {
		propertySignatures,
		indexSignatures
	};
};
/**
* @since 0.67.0
*/
const typeAST = (ast) => {
	switch (ast._tag) {
		case "Declaration": {
			const typeParameters = changeMap(ast.typeParameters, typeAST);
			return typeParameters === ast.typeParameters ? ast : new Declaration(typeParameters, ast.decodeUnknown, ast.encodeUnknown, ast.annotations);
		}
		case "TupleType": {
			const elements = changeMap(ast.elements, (e) => {
				const type = typeAST(e.type);
				return type === e.type ? e : new OptionalType(type, e.isOptional);
			});
			const restASTs = getRestASTs(ast.rest);
			const rest = changeMap(restASTs, typeAST);
			return elements === ast.elements && rest === restASTs ? ast : new TupleType(elements, rest.map((type) => new Type$1(type)), ast.isReadonly, ast.annotations);
		}
		case "TypeLiteral": {
			const propertySignatures = changeMap(ast.propertySignatures, (p) => {
				const type = typeAST(p.type);
				return type === p.type ? p : new PropertySignature(p.name, type, p.isOptional, p.isReadonly);
			});
			const indexSignatures = changeMap(ast.indexSignatures, (is) => {
				const type = typeAST(is.type);
				return type === is.type ? is : new IndexSignature(is.parameter, type, is.isReadonly);
			});
			return propertySignatures === ast.propertySignatures && indexSignatures === ast.indexSignatures ? ast : new TypeLiteral(propertySignatures, indexSignatures, ast.annotations);
		}
		case "Union": {
			const types = changeMap(ast.types, typeAST);
			return types === ast.types ? ast : Union$1.make(types, ast.annotations);
		}
		case "Suspend": return new Suspend(() => typeAST(ast.f()), ast.annotations);
		case "Refinement": {
			const from = typeAST(ast.from);
			return from === ast.from ? ast : new Refinement$1(from, ast.filter, ast.annotations);
		}
		case "Transformation": return typeAST(ast.to);
	}
	return ast;
};
/** @internal */
const blackListAnnotations = (annotationIds) => (annotated) => {
	const out = { ...annotated.annotations };
	for (const id$2 of annotationIds) delete out[id$2];
	return out;
};
/** @internal */
const getJSONIdentifier = (annotated) => orElse$5(getJSONIdentifierAnnotation(annotated), () => getIdentifierAnnotation(annotated));
const createJSONIdentifierAnnotation = (annotated) => match$10(getJSONIdentifier(annotated), {
	onNone: () => void 0,
	onSome: (identifier$1) => ({ [JSONIdentifierAnnotationId]: identifier$1 })
});
function changeMap(as$4, f) {
	let changed = false;
	const out = allocate(as$4.length);
	for (let i = 0; i < as$4.length; i++) {
		const a = as$4[i];
		const fa = f(a);
		if (fa !== a) changed = true;
		out[i] = fa;
	}
	return changed ? out : as$4;
}
const encodedAST_ = (ast, isBound) => {
	switch (ast._tag) {
		case "Declaration": {
			const typeParameters = changeMap(ast.typeParameters, (ast$1) => encodedAST_(ast$1, isBound));
			return typeParameters === ast.typeParameters ? ast : new Declaration(typeParameters, ast.decodeUnknown, ast.encodeUnknown, ast.annotations);
		}
		case "TupleType": {
			const elements = changeMap(ast.elements, (e) => {
				const type = encodedAST_(e.type, isBound);
				return type === e.type ? e : new OptionalType(type, e.isOptional);
			});
			const restASTs = getRestASTs(ast.rest);
			const rest = changeMap(restASTs, (ast$1) => encodedAST_(ast$1, isBound));
			return elements === ast.elements && rest === restASTs ? ast : new TupleType(elements, rest.map((ast$1) => new Type$1(ast$1)), ast.isReadonly, createJSONIdentifierAnnotation(ast));
		}
		case "TypeLiteral": {
			const propertySignatures = changeMap(ast.propertySignatures, (ps) => {
				const type = encodedAST_(ps.type, isBound);
				return type === ps.type ? ps : new PropertySignature(ps.name, type, ps.isOptional, ps.isReadonly);
			});
			const indexSignatures = changeMap(ast.indexSignatures, (is) => {
				const type = encodedAST_(is.type, isBound);
				return type === is.type ? is : new IndexSignature(is.parameter, type, is.isReadonly);
			});
			return propertySignatures === ast.propertySignatures && indexSignatures === ast.indexSignatures ? ast : new TypeLiteral(propertySignatures, indexSignatures, createJSONIdentifierAnnotation(ast));
		}
		case "Union": {
			const types = changeMap(ast.types, (ast$1) => encodedAST_(ast$1, isBound));
			return types === ast.types ? ast : Union$1.make(types, createJSONIdentifierAnnotation(ast));
		}
		case "Suspend": return new Suspend(() => encodedAST_(ast.f(), isBound), createJSONIdentifierAnnotation(ast));
		case "Refinement": {
			const from = encodedAST_(ast.from, isBound);
			if (isBound) {
				if (from === ast.from) return ast;
				if (!isTransformation$1(ast.from) && hasStableFilter(ast)) return new Refinement$1(from, ast.filter);
			}
			return from;
		}
		case "Transformation": return encodedAST_(ast.from, isBound);
	}
	return ast;
};
/**
* @since 0.67.0
*/
const encodedAST = (ast) => encodedAST_(ast, false);
const toJSONAnnotations = (annotations$1) => {
	const out = {};
	for (const k of Object.getOwnPropertySymbols(annotations$1)) out[String(k)] = annotations$1[k];
	return out;
};
/** @internal */
const getParameterBase = (ast) => {
	switch (ast._tag) {
		case "StringKeyword":
		case "SymbolKeyword":
		case "TemplateLiteral": return ast;
		case "Refinement": return getParameterBase(ast.from);
	}
};
const formatKeyword = (ast) => getOrElse$5(getExpected(ast), () => ast._tag);
const getExpected = (ast) => {
	return getIdentifierAnnotation(ast).pipe(orElse$5(() => getTitleAnnotation(ast)), orElse$5(() => getDescriptionAnnotation(ast)));
};

//#endregion
//#region ../../node_modules/.bun/@effect+schema@0.75.5+0487cae5baa0fa19/node_modules/@effect/schema/dist/esm/internal/filters.js
/** @internal */
const GreaterThanTypeId$1 = /* @__PURE__ */ Symbol.for("@effect/schema/TypeId/GreaterThan");
/** @internal */
const GreaterThanOrEqualToTypeId$1 = /* @__PURE__ */ Symbol.for("@effect/schema/TypeId/GreaterThanOrEqualTo");
/** @internal */
const LessThanTypeId$1 = /* @__PURE__ */ Symbol.for("@effect/schema/TypeId/LessThan");
/** @internal */
const LessThanOrEqualToTypeId$1 = /* @__PURE__ */ Symbol.for("@effect/schema/TypeId/LessThanOrEqualTo");
/** @internal */
const IntTypeId$1 = /* @__PURE__ */ Symbol.for("@effect/schema/TypeId/Int");
/** @internal */
const BetweenTypeId$1 = /* @__PURE__ */ Symbol.for("@effect/schema/TypeId/Between");
/** @internal */
const GreaterThanBigintTypeId = /* @__PURE__ */ Symbol.for("@effect/schema/TypeId/GreaterThanBigint");
/** @internal */
const GreaterThanOrEqualToBigIntTypeId$1 = /* @__PURE__ */ Symbol.for("@effect/schema/TypeId/GreaterThanOrEqualToBigint");
/** @internal */
const LessThanBigIntTypeId$1 = /* @__PURE__ */ Symbol.for("@effect/schema/TypeId/LessThanBigint");
/** @internal */
const LessThanOrEqualToBigIntTypeId$1 = /* @__PURE__ */ Symbol.for("@effect/schema/TypeId/LessThanOrEqualToBigint");
/** @internal */
const BetweenBigintTypeId = /* @__PURE__ */ Symbol.for("@effect/schema/TypeId/BetweenBigint");
/** @internal */
const MinLengthTypeId$1 = /* @__PURE__ */ Symbol.for("@effect/schema/TypeId/MinLength");
/** @internal */
const MaxLengthTypeId$1 = /* @__PURE__ */ Symbol.for("@effect/schema/TypeId/MaxLength");
/** @internal */
const LengthTypeId$1 = /* @__PURE__ */ Symbol.for("@effect/schema/TypeId/Length");
/** @internal */
const MinItemsTypeId$1 = /* @__PURE__ */ Symbol.for("@effect/schema/TypeId/MinItems");
/** @internal */
const MaxItemsTypeId$1 = /* @__PURE__ */ Symbol.for("@effect/schema/TypeId/MaxItems");
/** @internal */
const ItemsCountTypeId$1 = /* @__PURE__ */ Symbol.for("@effect/schema/TypeId/ItemsCount");

//#endregion
//#region ../../node_modules/.bun/@effect+schema@0.75.5+0487cae5baa0fa19/node_modules/@effect/schema/dist/esm/Arbitrary.js
/**
* @category hooks
* @since 0.67.0
*/
const ArbitraryHookId = /* @__PURE__ */ Symbol.for("@effect/schema/ArbitraryHookId");

//#endregion
//#region ../../node_modules/.bun/@effect+schema@0.75.5+0487cae5baa0fa19/node_modules/@effect/schema/dist/esm/TreeFormatter.js
const make$1 = (value, forest = []) => ({
	value,
	forest
});
/**
* @category formatting
* @since 0.67.0
*/
const formatIssue = (issue) => map$1(go$1(issue), (tree) => drawTree(tree));
/**
* @category formatting
* @since 0.67.0
*/
const formatIssueSync = (issue) => runSync(formatIssue(issue));
const drawTree = (tree) => tree.value + draw("\n", tree.forest);
const draw = (indentation, forest) => {
	let r = "";
	const len = forest.length;
	let tree;
	for (let i = 0; i < len; i++) {
		tree = forest[i];
		const isLast = i === len - 1;
		r += indentation + (isLast ? "└" : "├") + "─ " + tree.value;
		r += draw(indentation + (len > 1 && !isLast ? "│  " : "   "), tree.forest);
	}
	return r;
};
const formatTransformationKind = (kind) => {
	switch (kind) {
		case "Encoded": return "Encoded side transformation failure";
		case "Transformation": return "Transformation process failure";
		case "Type": return "Type side transformation failure";
	}
};
const formatRefinementKind = (kind) => {
	switch (kind) {
		case "From": return "From side refinement failure";
		case "Predicate": return "Predicate refinement failure";
	}
};
const getAnnotated = (issue) => "ast" in issue ? some$4(issue.ast) : none$7();
const getCurrentMessage = (issue) => getAnnotated(issue).pipe(flatMap$11(getMessageAnnotation), flatMap$1((annotation) => {
	const out = annotation(issue);
	return isString(out) ? succeed$1({
		message: out,
		override: false
	}) : isEffect(out) ? map$1(out, (message) => ({
		message,
		override: false
	})) : isString(out.message) ? succeed$1({
		message: out.message,
		override: out.override
	}) : map$1(out.message, (message) => ({
		message,
		override: out.override
	}));
}));
const createParseIssueGuard = (tag) => (issue) => issue._tag === tag;
const isComposite = /* @__PURE__ */ createParseIssueGuard("Composite");
const isRefinement = /* @__PURE__ */ createParseIssueGuard("Refinement");
const isTransformation = /* @__PURE__ */ createParseIssueGuard("Transformation");
/** @internal */
const getMessage = (issue) => getCurrentMessage(issue).pipe(flatMap$1((currentMessage) => {
	return !currentMessage.override && (isComposite(issue) || isRefinement(issue) && issue.kind === "From" || isTransformation(issue) && issue.kind !== "Transformation") ? isTransformation(issue) || isRefinement(issue) ? getMessage(issue.issue) : none$7() : succeed$1(currentMessage.message);
}));
const getParseIssueTitleAnnotation = (issue) => getAnnotated(issue).pipe(flatMap$11(getParseIssueTitleAnnotation$1), filterMap$5((annotation) => fromNullable$2(annotation(issue))));
/** @internal */
const formatTypeMessage = (e) => getMessage(e).pipe(orElse$1(() => getParseIssueTitleAnnotation(e)), catchAll(() => succeed$1(e.message ?? `Expected ${String(e.ast)}, actual ${formatUnknown$1(e.actual)}`)));
const getParseIssueTitle = (issue) => getOrElse$5(getParseIssueTitleAnnotation(issue), () => String(issue.ast));
/** @internal */
const formatForbiddenMessage = (e) => e.message ?? "is forbidden";
/** @internal */
const formatUnexpectedMessage = (e) => e.message ?? "is unexpected";
/** @internal */
const formatMissingMessage = (e) => getMissingMessageAnnotation(e.ast).pipe(flatMap$1((annotation) => {
	const out = annotation();
	return isString(out) ? succeed$1(out) : out;
}), catchAll(() => succeed$1(e.message ?? "is missing")));
const getTree = (issue, onFailure) => matchEffect(getMessage(issue), {
	onFailure,
	onSuccess: (message) => succeed$1(make$1(message))
});
const go$1 = (e) => {
	switch (e._tag) {
		case "Type": return map$1(formatTypeMessage(e), make$1);
		case "Forbidden": return succeed$1(make$1(getParseIssueTitle(e), [make$1(formatForbiddenMessage(e))]));
		case "Unexpected": return succeed$1(make$1(formatUnexpectedMessage(e)));
		case "Missing": return map$1(formatMissingMessage(e), make$1);
		case "Transformation": return getTree(e, () => map$1(go$1(e.issue), (tree) => make$1(getParseIssueTitle(e), [make$1(formatTransformationKind(e.kind), [tree])])));
		case "Refinement": return getTree(e, () => map$1(go$1(e.issue), (tree) => make$1(getParseIssueTitle(e), [make$1(formatRefinementKind(e.kind), [tree])])));
		case "Pointer": return map$1(go$1(e.issue), (tree) => make$1(formatPath(e.path), [tree]));
		case "Composite": {
			const parseIssueTitle = getParseIssueTitle(e);
			return getTree(e, () => isNonEmpty(e.issues) ? map$1(forEach(e.issues, go$1), (forest) => make$1(parseIssueTitle, forest)) : map$1(go$1(e.issues), (tree) => make$1(parseIssueTitle, [tree])));
		}
	}
};

//#endregion
//#region ../../node_modules/.bun/@effect+schema@0.75.5+0487cae5baa0fa19/node_modules/@effect/schema/dist/esm/ParseResult.js
/**
* @category model
* @since 0.68.0
*/
var Pointer = class {
	path;
	actual;
	issue;
	/**
	* @since 0.68.0
	*/
	_tag = "Pointer";
	constructor(path, actual, issue) {
		this.path = path;
		this.actual = actual;
		this.issue = issue;
	}
};
/**
* Error that occurs when an unexpected key or index is present.
*
* @category model
* @since 0.67.0
*/
var Unexpected = class {
	actual;
	message;
	/**
	* @since 0.67.0
	*/
	_tag = "Unexpected";
	constructor(actual, message) {
		this.actual = actual;
		this.message = message;
	}
};
/**
* Error that occurs when a required key or index is missing.
*
* @category model
* @since 0.67.0
*/
var Missing = class {
	ast;
	message;
	/**
	* @since 0.67.0
	*/
	_tag = "Missing";
	/**
	* @since 0.68.0
	*/
	actual = void 0;
	constructor(ast, message) {
		this.ast = ast;
		this.message = message;
	}
};
/**
* Error that contains multiple issues.
*
* @category model
* @since 0.68.0
*/
var Composite = class {
	ast;
	actual;
	issues;
	output;
	/**
	* @since 0.68.0
	*/
	_tag = "Composite";
	constructor(ast, actual, issues, output) {
		this.ast = ast;
		this.actual = actual;
		this.issues = issues;
		this.output = output;
	}
};
/**
* Error that occurs when a refinement has an error.
*
* @category model
* @since 0.67.0
*/
var Refinement = class {
	ast;
	actual;
	kind;
	issue;
	/**
	* @since 0.67.0
	*/
	_tag = "Refinement";
	constructor(ast, actual, kind, issue) {
		this.ast = ast;
		this.actual = actual;
		this.kind = kind;
		this.issue = issue;
	}
};
/**
* Error that occurs when a transformation has an error.
*
* @category model
* @since 0.67.0
*/
var Transformation = class {
	ast;
	actual;
	kind;
	issue;
	/**
	* @since 0.67.0
	*/
	_tag = "Transformation";
	constructor(ast, actual, kind, issue) {
		this.ast = ast;
		this.actual = actual;
		this.kind = kind;
		this.issue = issue;
	}
};
/**
* The `Type` variant of the `ParseIssue` type represents an error that occurs when the `actual` value is not of the expected type.
* The `ast` field specifies the expected type, and the `actual` field contains the value that caused the error.
*
* @category model
* @since 0.67.0
*/
var Type = class {
	ast;
	actual;
	message;
	/**
	* @since 0.67.0
	*/
	_tag = "Type";
	constructor(ast, actual, message) {
		this.ast = ast;
		this.actual = actual;
		this.message = message;
	}
};
/**
* The `Forbidden` variant of the `ParseIssue` type represents a forbidden operation, such as when encountering an Effect that is not allowed to execute (e.g., using `runSync`).
*
* @category model
* @since 0.67.0
*/
var Forbidden = class {
	ast;
	actual;
	message;
	/**
	* @since 0.67.0
	*/
	_tag = "Forbidden";
	constructor(ast, actual, message) {
		this.ast = ast;
		this.actual = actual;
		this.message = message;
	}
};
/**
* @category type id
* @since 0.68.0
*/
const ParseErrorTypeId = /* @__PURE__ */ Symbol.for("@effect/schema/ParseErrorTypeId");
/**
* @since 0.67.0
*/
var ParseError = class extends TaggedError("ParseError") {
	/**
	* @since 0.68.0
	*/
	[ParseErrorTypeId] = ParseErrorTypeId;
	get message() {
		return this.toString();
	}
	/**
	* @since 0.67.0
	*/
	toString() {
		return formatIssueSync(this.issue);
	}
	/**
	* @since 0.67.0
	*/
	toJSON() {
		return {
			_id: "ParseError",
			message: this.toString()
		};
	}
	/**
	* @since 0.67.0
	*/
	[NodeInspectSymbol]() {
		return this.toJSON();
	}
};
/**
* @category constructors
* @since 0.67.0
*/
const parseError = (issue) => new ParseError({ issue });
/**
* @category constructors
* @since 0.67.0
*/
const succeed = right;
/**
* @category constructors
* @since 0.67.0
*/
const fail = left;
const _try = try_$2;
/**
* @category constructors
* @since 0.67.0
*/
const fromOption = fromOption$3;
/**
* @category optimisation
* @since 0.67.0
*/
const flatMap = /* @__PURE__ */ dual(2, (self, f) => {
	const s = self;
	if (s["_tag"] === "Left") return s;
	if (s["_tag"] === "Right") return f(s.right);
	return flatMap$1(self, f);
});
/**
* @category optimisation
* @since 0.67.0
*/
const map = /* @__PURE__ */ dual(2, (self, f) => {
	const s = self;
	if (s["_tag"] === "Left") return s;
	if (s["_tag"] === "Right") return right(f(s.right));
	return map$1(self, f);
});
/**
* @category optimisation
* @since 0.67.0
*/
const mapError = /* @__PURE__ */ dual(2, (self, f) => {
	const s = self;
	if (s["_tag"] === "Left") return left(f(s.left));
	if (s["_tag"] === "Right") return s;
	return mapError$1(self, f);
});
/**
* @category optimisation
* @since 0.67.0
*/
const eitherOrUndefined = (self) => {
	const s = self;
	if (s["_tag"] === "Left" || s["_tag"] === "Right") return s;
};
/**
* @category optimisation
* @since 0.67.0
*/
const orElse = /* @__PURE__ */ dual(2, (self, f) => {
	const s = self;
	if (s["_tag"] === "Left") return f(s.left);
	if (s["_tag"] === "Right") return s;
	return catchAll(self, f);
});
/** @internal */
const mergeInternalOptions = (options, overrideOptions) => {
	if (overrideOptions === void 0 || isNumber$1(overrideOptions)) return options;
	if (options === void 0) return overrideOptions;
	return {
		...options,
		...overrideOptions
	};
};
const getEither = (ast, isDecoding, options) => {
	const parser = goMemo(ast, isDecoding);
	return (u, overrideOptions) => parser(u, mergeInternalOptions(options, overrideOptions));
};
const getSync = (ast, isDecoding, options) => {
	const parser = getEither(ast, isDecoding, options);
	return (input, overrideOptions) => getOrThrowWith$1(parser(input, overrideOptions), parseError);
};
/**
* @throws `ParseError`
* @category validation
* @since 0.67.0
*/
const validateSync = (schema$1, options) => getSync(typeAST(schema$1.ast), true, options);
const decodeMemoMap = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("@effect/schema/Parser/decodeMemoMap"), () => /* @__PURE__ */ new WeakMap());
const encodeMemoMap = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("@effect/schema/Parser/encodeMemoMap"), () => /* @__PURE__ */ new WeakMap());
const goMemo = (ast, isDecoding) => {
	const memoMap = isDecoding ? decodeMemoMap : encodeMemoMap;
	const memo = memoMap.get(ast);
	if (memo) return memo;
	const raw = go(ast, isDecoding);
	const parseOptionsAnnotation = getParseOptionsAnnotation(ast);
	const parserWithOptions = isSome(parseOptionsAnnotation) ? (i, options) => raw(i, mergeInternalOptions(options, parseOptionsAnnotation.value)) : raw;
	const decodingFallbackAnnotation = getDecodingFallbackAnnotation(ast);
	const parser = isDecoding && isSome(decodingFallbackAnnotation) ? (i, options) => handleForbidden(orElse(parserWithOptions(i, options), decodingFallbackAnnotation.value), ast, i, options) : parserWithOptions;
	memoMap.set(ast, parser);
	return parser;
};
const getConcurrency = (ast) => getOrUndefined(getConcurrencyAnnotation(ast));
const getBatching = (ast) => getOrUndefined(getBatchingAnnotation(ast));
const go = (ast, isDecoding) => {
	switch (ast._tag) {
		case "Refinement": if (isDecoding) {
			const from = goMemo(ast.from, true);
			return (i, options) => {
				options = options ?? defaultParseOption;
				const allErrors = options?.errors === "all";
				const result = flatMap(orElse(from(i, options), (ef) => {
					const issue = new Refinement(ast, i, "From", ef);
					if (allErrors && hasStableFilter(ast)) return match$10(ast.filter(i, options, ast), {
						onNone: () => left(issue),
						onSome: (ep) => left(new Composite(ast, i, [issue, new Refinement(ast, i, "Predicate", ep)]))
					});
					return left(issue);
				}), (a) => match$10(ast.filter(a, options, ast), {
					onNone: () => right(a),
					onSome: (ep) => left(new Refinement(ast, i, "Predicate", ep))
				}));
				return handleForbidden(result, ast, i, options);
			};
		} else {
			const from = goMemo(typeAST(ast), true);
			const to = goMemo(dropRightRefinement(ast.from), false);
			return (i, options) => handleForbidden(flatMap(from(i, options), (a) => to(a, options)), ast, i, options);
		}
		case "Transformation": {
			const transform$3 = getFinalTransformation(ast.transformation, isDecoding);
			const from = isDecoding ? goMemo(ast.from, true) : goMemo(ast.to, false);
			const to = isDecoding ? goMemo(ast.to, true) : goMemo(ast.from, false);
			return (i, options) => handleForbidden(flatMap(mapError(from(i, options), (e) => new Transformation(ast, i, isDecoding ? "Encoded" : "Type", e)), (a) => flatMap(mapError(transform$3(a, options ?? defaultParseOption, ast, i), (e) => new Transformation(ast, i, "Transformation", e)), (i2) => mapError(to(i2, options), (e) => new Transformation(ast, i, isDecoding ? "Type" : "Encoded", e)))), ast, i, options);
		}
		case "Declaration": {
			const parse = isDecoding ? ast.decodeUnknown(...ast.typeParameters) : ast.encodeUnknown(...ast.typeParameters);
			return (i, options) => handleForbidden(parse(i, options ?? defaultParseOption, ast), ast, i, options);
		}
		case "Literal": return fromRefinement(ast, (u) => u === ast.literal);
		case "UniqueSymbol": return fromRefinement(ast, (u) => u === ast.symbol);
		case "UndefinedKeyword": return fromRefinement(ast, isUndefined);
		case "NeverKeyword": return fromRefinement(ast, isNever);
		case "UnknownKeyword":
		case "AnyKeyword":
		case "VoidKeyword": return right;
		case "StringKeyword": return fromRefinement(ast, isString);
		case "NumberKeyword": return fromRefinement(ast, isNumber$1);
		case "BooleanKeyword": return fromRefinement(ast, isBoolean$1);
		case "BigIntKeyword": return fromRefinement(ast, isBigInt);
		case "SymbolKeyword": return fromRefinement(ast, isSymbol);
		case "ObjectKeyword": return fromRefinement(ast, isObject$1);
		case "Enums": return fromRefinement(ast, (u) => ast.enums.some(([_, value]) => value === u));
		case "TemplateLiteral": {
			const regex = getTemplateLiteralRegExp(ast);
			return fromRefinement(ast, (u) => isString(u) && regex.test(u));
		}
		case "TupleType": {
			const elements = ast.elements.map((e) => goMemo(e.type, isDecoding));
			const rest = ast.rest.map((annotatedAST) => goMemo(annotatedAST.type, isDecoding));
			let requiredTypes = ast.elements.filter((e) => !e.isOptional);
			if (ast.rest.length > 0) requiredTypes = requiredTypes.concat(ast.rest.slice(1));
			const requiredLen = requiredTypes.length;
			const expectedIndexes = ast.elements.length > 0 ? ast.elements.map((_, i) => i).join(" | ") : "never";
			const concurrency = getConcurrency(ast);
			const batching = getBatching(ast);
			return (input, options) => {
				if (!isArray(input)) return left(new Type(ast, input));
				const allErrors = options?.errors === "all";
				const es = [];
				let stepKey = 0;
				const output = [];
				const len = input.length;
				for (let i$1 = len; i$1 <= requiredLen - 1; i$1++) {
					const e = new Pointer(i$1, input, new Missing(requiredTypes[i$1 - len]));
					if (allErrors) {
						es.push([stepKey++, e]);
						continue;
					} else return left(new Composite(ast, input, e, output));
				}
				if (ast.rest.length === 0) for (let i$1 = ast.elements.length; i$1 <= len - 1; i$1++) {
					const e = new Pointer(i$1, input, new Unexpected(input[i$1], `is unexpected, expected: ${expectedIndexes}`));
					if (allErrors) {
						es.push([stepKey++, e]);
						continue;
					} else return left(new Composite(ast, input, e, output));
				}
				let i = 0;
				let queue = void 0;
				for (; i < elements.length; i++) if (len < i + 1) {
					if (ast.elements[i].isOptional) continue;
				} else {
					const parser = elements[i];
					const te = parser(input[i], options);
					const eu = eitherOrUndefined(te);
					if (eu) {
						if (isLeft(eu)) {
							const e = new Pointer(i, input, eu.left);
							if (allErrors) {
								es.push([stepKey++, e]);
								continue;
							} else return left(new Composite(ast, input, e, sortByIndex(output)));
						}
						output.push([stepKey++, eu.right]);
					} else {
						const nk = stepKey++;
						const index = i;
						if (!queue) queue = [];
						queue.push(({ es: es$1, output: output$1 }) => flatMap$1(either(te), (t) => {
							if (isLeft(t)) {
								const e = new Pointer(index, input, t.left);
								if (allErrors) {
									es$1.push([nk, e]);
									return _void;
								} else return left(new Composite(ast, input, e, sortByIndex(output$1)));
							}
							output$1.push([nk, t.right]);
							return _void;
						}));
					}
				}
				if (isNonEmptyReadonlyArray(rest)) {
					const [head$4, ...tail] = rest;
					for (; i < len - tail.length; i++) {
						const te = head$4(input[i], options);
						const eu = eitherOrUndefined(te);
						if (eu) if (isLeft(eu)) {
							const e = new Pointer(i, input, eu.left);
							if (allErrors) {
								es.push([stepKey++, e]);
								continue;
							} else return left(new Composite(ast, input, e, sortByIndex(output)));
						} else output.push([stepKey++, eu.right]);
						else {
							const nk = stepKey++;
							const index = i;
							if (!queue) queue = [];
							queue.push(({ es: es$1, output: output$1 }) => flatMap$1(either(te), (t) => {
								if (isLeft(t)) {
									const e = new Pointer(index, input, t.left);
									if (allErrors) {
										es$1.push([nk, e]);
										return _void;
									} else return left(new Composite(ast, input, e, sortByIndex(output$1)));
								} else {
									output$1.push([nk, t.right]);
									return _void;
								}
							}));
						}
					}
					for (let j = 0; j < tail.length; j++) {
						i += j;
						if (len < i + 1) continue;
						else {
							const te = tail[j](input[i], options);
							const eu = eitherOrUndefined(te);
							if (eu) {
								if (isLeft(eu)) {
									const e = new Pointer(i, input, eu.left);
									if (allErrors) {
										es.push([stepKey++, e]);
										continue;
									} else return left(new Composite(ast, input, e, sortByIndex(output)));
								}
								output.push([stepKey++, eu.right]);
							} else {
								const nk = stepKey++;
								const index = i;
								if (!queue) queue = [];
								queue.push(({ es: es$1, output: output$1 }) => flatMap$1(either(te), (t) => {
									if (isLeft(t)) {
										const e = new Pointer(index, input, t.left);
										if (allErrors) {
											es$1.push([nk, e]);
											return _void;
										} else return left(new Composite(ast, input, e, sortByIndex(output$1)));
									}
									output$1.push([nk, t.right]);
									return _void;
								}));
							}
						}
					}
				}
				const computeResult = ({ es: es$1, output: output$1 }) => isNonEmptyArray(es$1) ? left(new Composite(ast, input, sortByIndex(es$1), sortByIndex(output$1))) : right(sortByIndex(output$1));
				if (queue && queue.length > 0) {
					const cqueue = queue;
					return suspend(() => {
						const state = {
							es: copy$1(es),
							output: copy$1(output)
						};
						return flatMap$1(forEach(cqueue, (f) => f(state), {
							concurrency,
							batching,
							discard: true
						}), () => computeResult(state));
					});
				}
				return computeResult({
					output,
					es
				});
			};
		}
		case "TypeLiteral": {
			if (ast.propertySignatures.length === 0 && ast.indexSignatures.length === 0) return fromRefinement(ast, isNotNullable);
			const propertySignatures = [];
			const expectedKeysMap = {};
			const expectedKeys = [];
			for (const ps of ast.propertySignatures) {
				propertySignatures.push([goMemo(ps.type, isDecoding), ps]);
				expectedKeysMap[ps.name] = null;
				expectedKeys.push(ps.name);
			}
			const indexSignatures = ast.indexSignatures.map((is) => [
				goMemo(is.parameter, isDecoding),
				goMemo(is.type, isDecoding),
				is.parameter
			]);
			const expectedAST = Union$1.make(ast.indexSignatures.map((is) => is.parameter).concat(expectedKeys.map((key) => isSymbol(key) ? new UniqueSymbol(key) : new Literal(key))));
			const expected = goMemo(expectedAST, isDecoding);
			const concurrency = getConcurrency(ast);
			const batching = getBatching(ast);
			return (input, options) => {
				if (!isRecord(input)) return left(new Type(ast, input));
				const allErrors = options?.errors === "all";
				const es = [];
				let stepKey = 0;
				const onExcessPropertyError = options?.onExcessProperty === "error";
				const onExcessPropertyPreserve = options?.onExcessProperty === "preserve";
				const output = {};
				let inputKeys;
				if (onExcessPropertyError || onExcessPropertyPreserve) {
					inputKeys = ownKeys(input);
					for (const key of inputKeys) {
						const eu = eitherOrUndefined(expected(key, options));
						if (isLeft(eu)) if (onExcessPropertyError) {
							const e = new Pointer(key, input, new Unexpected(input[key], `is unexpected, expected: ${String(expectedAST)}`));
							if (allErrors) {
								es.push([stepKey++, e]);
								continue;
							} else return left(new Composite(ast, input, e, output));
						} else output[key] = input[key];
					}
				}
				let queue = void 0;
				const isExact = options?.exact === true;
				for (let i = 0; i < propertySignatures.length; i++) {
					const ps = propertySignatures[i][1];
					const name = ps.name;
					const hasKey = Object.prototype.hasOwnProperty.call(input, name);
					if (!hasKey) {
						if (ps.isOptional) continue;
						else if (isExact) {
							const e = new Pointer(name, input, new Missing(ps));
							if (allErrors) {
								es.push([stepKey++, e]);
								continue;
							} else return left(new Composite(ast, input, e, output));
						}
					}
					const parser = propertySignatures[i][0];
					const te = parser(input[name], options);
					const eu = eitherOrUndefined(te);
					if (eu) {
						if (isLeft(eu)) {
							const e = new Pointer(name, input, hasKey ? eu.left : new Missing(ps));
							if (allErrors) {
								es.push([stepKey++, e]);
								continue;
							} else return left(new Composite(ast, input, e, output));
						}
						output[name] = eu.right;
					} else {
						const nk = stepKey++;
						const index = name;
						if (!queue) queue = [];
						queue.push(({ es: es$1, output: output$1 }) => flatMap$1(either(te), (t) => {
							if (isLeft(t)) {
								const e = new Pointer(index, input, hasKey ? t.left : new Missing(ps));
								if (allErrors) {
									es$1.push([nk, e]);
									return _void;
								} else return left(new Composite(ast, input, e, output$1));
							}
							output$1[index] = t.right;
							return _void;
						}));
					}
				}
				for (let i = 0; i < indexSignatures.length; i++) {
					const indexSignature = indexSignatures[i];
					const parameter = indexSignature[0];
					const type = indexSignature[1];
					const keys$5 = getKeysForIndexSignature(input, indexSignature[2]);
					for (const key of keys$5) {
						const keu = eitherOrUndefined(parameter(key, options));
						if (keu && isRight(keu)) {
							const vpr = type(input[key], options);
							const veu = eitherOrUndefined(vpr);
							if (veu) {
								if (isLeft(veu)) {
									const e = new Pointer(key, input, veu.left);
									if (allErrors) {
										es.push([stepKey++, e]);
										continue;
									} else return left(new Composite(ast, input, e, output));
								} else if (!Object.prototype.hasOwnProperty.call(expectedKeysMap, key)) output[key] = veu.right;
							} else {
								const nk = stepKey++;
								const index = key;
								if (!queue) queue = [];
								queue.push(({ es: es$1, output: output$1 }) => flatMap$1(either(vpr), (tv) => {
									if (isLeft(tv)) {
										const e = new Pointer(index, input, tv.left);
										if (allErrors) {
											es$1.push([nk, e]);
											return _void;
										} else return left(new Composite(ast, input, e, output$1));
									} else {
										if (!Object.prototype.hasOwnProperty.call(expectedKeysMap, key)) output$1[key] = tv.right;
										return _void;
									}
								}));
							}
						}
					}
				}
				const computeResult = ({ es: es$1, output: output$1 }) => {
					if (isNonEmptyArray(es$1)) return left(new Composite(ast, input, sortByIndex(es$1), output$1));
					if (options?.propertyOrder === "original") {
						const keys$5 = inputKeys || ownKeys(input);
						for (const name of expectedKeys) if (keys$5.indexOf(name) === -1) keys$5.push(name);
						const out = {};
						for (const key of keys$5) if (Object.prototype.hasOwnProperty.call(output$1, key)) out[key] = output$1[key];
						return right(out);
					}
					return right(output$1);
				};
				if (queue && queue.length > 0) {
					const cqueue = queue;
					return suspend(() => {
						const state = {
							es: copy$1(es),
							output: Object.assign({}, output)
						};
						return flatMap$1(forEach(cqueue, (f) => f(state), {
							concurrency,
							batching,
							discard: true
						}), () => computeResult(state));
					});
				}
				return computeResult({
					es,
					output
				});
			};
		}
		case "Union": {
			const searchTree = getSearchTree(ast.types, isDecoding);
			const ownKeys$1 = ownKeys(searchTree.keys);
			const len = ownKeys$1.length;
			const map$17 = /* @__PURE__ */ new Map();
			for (let i = 0; i < ast.types.length; i++) map$17.set(ast.types[i], goMemo(ast.types[i], isDecoding));
			const concurrency = getConcurrency(ast) ?? 1;
			const batching = getBatching(ast);
			return (input, options) => {
				const es = [];
				let stepKey = 0;
				let candidates = [];
				if (len > 0) if (isObject(input)) for (let i = 0; i < len; i++) {
					const name = ownKeys$1[i];
					const buckets = searchTree.keys[name].buckets;
					if (Object.prototype.hasOwnProperty.call(input, name)) {
						const literal = String(input[name]);
						if (Object.prototype.hasOwnProperty.call(buckets, literal)) candidates = candidates.concat(buckets[literal]);
						else {
							const literals = Union$1.make(searchTree.keys[name].literals);
							es.push([stepKey++, new Composite(new TypeLiteral([new PropertySignature(name, literals, false, true)], []), input, new Pointer(name, input, new Type(literals, input[name])))]);
						}
					} else {
						const literals = Union$1.make(searchTree.keys[name].literals);
						const fakeps = new PropertySignature(name, literals, false, true);
						es.push([stepKey++, new Composite(new TypeLiteral([fakeps], []), input, new Pointer(name, input, new Missing(fakeps)))]);
					}
				}
				else es.push([stepKey++, new Type(ast, input)]);
				if (searchTree.otherwise.length > 0) candidates = candidates.concat(searchTree.otherwise);
				let queue = void 0;
				for (let i = 0; i < candidates.length; i++) {
					const candidate = candidates[i];
					const pr = map$17.get(candidate)(input, options);
					const eu = !queue || queue.length === 0 ? eitherOrUndefined(pr) : void 0;
					if (eu) if (isRight(eu)) return eu;
					else es.push([stepKey++, eu.left]);
					else {
						const nk = stepKey++;
						if (!queue) queue = [];
						queue.push((state) => suspend(() => {
							if ("finalResult" in state) return _void;
							else return flatMap$1(either(pr), (t) => {
								if (isRight(t)) state.finalResult = t;
								else state.es.push([nk, t.left]);
								return _void;
							});
						}));
					}
				}
				const computeResult = (es$1) => isNonEmptyArray(es$1) ? es$1.length === 1 && es$1[0][1]._tag === "Type" ? left(es$1[0][1]) : left(new Composite(ast, input, sortByIndex(es$1))) : left(new Type(ast, input));
				if (queue && queue.length > 0) {
					const cqueue = queue;
					return suspend(() => {
						const state = { es: copy$1(es) };
						return flatMap$1(forEach(cqueue, (f) => f(state), {
							concurrency,
							batching,
							discard: true
						}), () => {
							if ("finalResult" in state) return state.finalResult;
							return computeResult(state.es);
						});
					});
				}
				return computeResult(es);
			};
		}
		case "Suspend": {
			const get$12 = memoizeThunk(() => goMemo(annotations(ast.f(), ast.annotations), isDecoding));
			return (a, options) => get$12()(a, options);
		}
	}
};
const isObject = (input) => typeof input === "object" && input !== null;
const fromRefinement = (ast, refinement) => (u) => refinement(u) ? right(u) : left(new Type(ast, u));
/** @internal */
const getLiterals = (ast, isDecoding) => {
	switch (ast._tag) {
		case "Declaration": {
			const annotation = getSurrogateAnnotation(ast);
			if (isSome(annotation)) return getLiterals(annotation.value, isDecoding);
			break;
		}
		case "TypeLiteral": {
			const out = [];
			for (let i = 0; i < ast.propertySignatures.length; i++) {
				const propertySignature = ast.propertySignatures[i];
				const type = isDecoding ? encodedAST(propertySignature.type) : typeAST(propertySignature.type);
				if (isLiteral(type) && !propertySignature.isOptional) out.push([propertySignature.name, type]);
			}
			return out;
		}
		case "TupleType": {
			const out = [];
			for (let i = 0; i < ast.elements.length; i++) {
				const element = ast.elements[i];
				const type = isDecoding ? encodedAST(element.type) : typeAST(element.type);
				if (isLiteral(type) && !element.isOptional) out.push([i, type]);
			}
			return out;
		}
		case "Refinement": return getLiterals(ast.from, isDecoding);
		case "Suspend": return getLiterals(ast.f(), isDecoding);
		case "Transformation": return getLiterals(isDecoding ? ast.from : ast.to, isDecoding);
	}
	return [];
};
/**
* The purpose of the algorithm is to narrow down the pool of possible candidates for decoding as much as possible.
*
* This function separates the schemas into two groups, `keys` and `otherwise`:
*
* - `keys`: the schema has at least one property with a literal value
* - `otherwise`: the schema has no properties with a literal value
*
* If a schema has at least one property with a literal value, so it ends up in `keys`, first a namespace is created for
* the name of the property containing the literal, and then within this namespace a "bucket" is created for the literal
* value in which to store all the schemas that have the same property and literal value.
*
* @internal
*/
const getSearchTree = (members, isDecoding) => {
	const keys$5 = {};
	const otherwise = [];
	for (let i = 0; i < members.length; i++) {
		const member = members[i];
		const tags = getLiterals(member, isDecoding);
		if (tags.length > 0) for (let j = 0; j < tags.length; j++) {
			const [key, literal] = tags[j];
			const hash$1 = String(literal.literal);
			keys$5[key] = keys$5[key] || {
				buckets: {},
				literals: []
			};
			const buckets = keys$5[key].buckets;
			if (Object.prototype.hasOwnProperty.call(buckets, hash$1)) {
				if (j < tags.length - 1) continue;
				buckets[hash$1].push(member);
				keys$5[key].literals.push(literal);
			} else {
				buckets[hash$1] = [member];
				keys$5[key].literals.push(literal);
				break;
			}
		}
		else otherwise.push(member);
	}
	return {
		keys: keys$5,
		otherwise
	};
};
const dropRightRefinement = (ast) => isRefinement$1(ast) ? dropRightRefinement(ast.from) : ast;
const handleForbidden = (effect, ast, actual, options) => {
	const eu = eitherOrUndefined(effect);
	if (eu) return eu;
	if (options?.isEffectAllowed === true) return effect;
	try {
		return runSync(either(effect));
	} catch (e) {
		return left(new Forbidden(ast, actual, "cannot be be resolved synchronously, this is caused by using runSync on an effect that performs async work"));
	}
};
const compare = ([a], [b]) => a > b ? 1 : a < b ? -1 : 0;
function sortByIndex(es) {
	return es.sort(compare).map((t) => t[1]);
}
/** @internal */
const getFinalTransformation = (transformation, isDecoding) => {
	switch (transformation._tag) {
		case "FinalTransformation": return isDecoding ? transformation.decode : transformation.encode;
		case "ComposeTransformation": return right;
		case "TypeLiteralTransformation": return (input) => {
			let out = right(input);
			for (const pst of transformation.propertySignatureTransformations) {
				const [from, to] = isDecoding ? [pst.from, pst.to] : [pst.to, pst.from];
				const transformation$1 = isDecoding ? pst.decode : pst.encode;
				const f = (input$1) => {
					const o = transformation$1(Object.prototype.hasOwnProperty.call(input$1, from) ? some$4(input$1[from]) : none$7());
					delete input$1[from];
					if (isSome(o)) input$1[to] = o.value;
					return input$1;
				};
				out = map(out, f);
			}
			return out;
		};
	}
};

//#endregion
//#region ../../node_modules/.bun/@effect+schema@0.75.5+0487cae5baa0fa19/node_modules/@effect/schema/dist/esm/Equivalence.js
/**
* @category hooks
* @since 0.67.0
*/
const EquivalenceHookId = /* @__PURE__ */ Symbol.for("@effect/schema/EquivalenceHookId");

//#endregion
//#region ../../node_modules/.bun/@effect+schema@0.75.5+0487cae5baa0fa19/node_modules/@effect/schema/dist/esm/Pretty.js
/**
* @category hooks
* @since 0.67.0
*/
const PrettyHookId = /* @__PURE__ */ Symbol.for("@effect/schema/PrettyHookId");
const getHook = /* @__PURE__ */ getAnnotation(PrettyHookId);
const getMatcher = (defaultPretty) => (ast) => match$10(getHook(ast), {
	onNone: () => defaultPretty,
	onSome: (handler) => handler()
});
const formatUnknown = /* @__PURE__ */ getMatcher(formatUnknown$1);

//#endregion
//#region ../../node_modules/.bun/@effect+schema@0.75.5+0487cae5baa0fa19/node_modules/@effect/schema/dist/esm/Schema.js
/**
* @since 0.67.0
* @category symbol
*/
const TypeId = /* @__PURE__ */ Symbol.for("@effect/schema/Schema");
/**
* @category constructors
* @since 0.67.0
*/
const make = (ast) => class SchemaClass {
	[TypeId] = variance;
	static Type;
	static Encoded;
	static Context;
	static [TypeId] = variance;
	static ast = ast;
	static annotations(annotations$1) {
		return make(mergeSchemaAnnotations(this.ast, annotations$1));
	}
	static pipe() {
		return pipeArguments(this, arguments);
	}
	static toString() {
		return String(ast);
	}
};
const variance = {
	_A: (_) => _,
	_I: (_) => _,
	_R: (_) => _
};
const toASTAnnotations = (annotations$1) => {
	if (!annotations$1) return {};
	const out = {};
	const custom$2 = Object.getOwnPropertySymbols(annotations$1);
	for (const sym of custom$2) out[sym] = annotations$1[sym];
	if (annotations$1.typeId !== void 0) {
		const typeId = annotations$1.typeId;
		if (typeof typeId === "object") {
			out[TypeAnnotationId] = typeId.id;
			out[typeId.id] = typeId.annotation;
		} else out[TypeAnnotationId] = typeId;
	}
	const move = (from, to) => {
		if (annotations$1[from] !== void 0) out[to] = annotations$1[from];
	};
	move("message", MessageAnnotationId);
	move("missingMessage", MissingMessageAnnotationId);
	move("identifier", IdentifierAnnotationId);
	move("title", TitleAnnotationId);
	move("description", DescriptionAnnotationId);
	move("examples", ExamplesAnnotationId);
	move("default", DefaultAnnotationId);
	move("documentation", DocumentationAnnotationId);
	move("jsonSchema", JSONSchemaAnnotationId);
	move("arbitrary", ArbitraryHookId);
	move("pretty", PrettyHookId);
	move("equivalence", EquivalenceHookId);
	move("concurrency", ConcurrencyAnnotationId);
	move("batching", BatchingAnnotationId);
	move("parseIssueTitle", ParseIssueTitleAnnotationId);
	move("parseOptions", ParseOptionsAnnotationId);
	move("decodingFallback", DecodingFallbackAnnotationId);
	return out;
};
const mergeSchemaAnnotations = (ast, annotations$1) => annotations(ast, toASTAnnotations(annotations$1));
/**
* Tests if a value is a `Schema`.
*
* @category guards
* @since 0.67.0
*/
const isSchema = (u) => hasProperty(u, TypeId) && isObject$1(u[TypeId]);
const declareConstructor = (typeParameters, options, annotations$1) => make(new Declaration(typeParameters.map((tp) => tp.ast), (...typeParameters$1) => options.decode(...typeParameters$1.map(make)), (...typeParameters$1) => options.encode(...typeParameters$1.map(make)), toASTAnnotations(annotations$1)));
const declarePrimitive = (is, annotations$1) => {
	const decodeUnknown = () => (input, _, ast) => is(input) ? succeed(input) : fail(new Type(ast, input));
	const encodeUnknown = decodeUnknown;
	return make(new Declaration([], decodeUnknown, encodeUnknown, toASTAnnotations(annotations$1)));
};
/**
* The constraint `R extends Schema.Context<P[number]>` enforces dependencies solely from `typeParameters`.
* This ensures that when you call `Schema.to` or `Schema.from`, you receive a schema with a `never` context.
*
* @category constructors
* @since 0.67.0
*/
const declare = function() {
	if (Array.isArray(arguments[0])) {
		const typeParameters = arguments[0];
		const options = arguments[1];
		const annotations$2 = arguments[2];
		return declareConstructor(typeParameters, options, annotations$2);
	}
	const is = arguments[0];
	const annotations$1 = arguments[1];
	return declarePrimitive(is, annotations$1);
};
/**
* @category primitives
* @since 0.67.0
*/
var Undefined = class extends make(undefinedKeyword) {};
/**
* @category primitives
* @since 0.67.0
*/
var Never = class extends make(neverKeyword) {};
/**
* @category primitives
* @since 0.67.0
*/
var Unknown = class extends make(unknownKeyword) {};
/**
* @category primitives
* @since 0.67.0
*/
var Any = class extends make(anyKeyword) {};
/** @ignore */
var String$ = class extends make(stringKeyword) {};
/** @ignore */
var Number$ = class extends make(numberKeyword) {};
const getDefaultUnionAST = (members) => Union$1.make(members.map((m) => m.ast));
const makeUnionClass = (members, ast = getDefaultUnionAST(members)) => class UnionClass extends make(ast) {
	static annotations(annotations$1) {
		return makeUnionClass(this.members, mergeSchemaAnnotations(this.ast, annotations$1));
	}
	static members = [...members];
};
function Union(...members) {
	return isMembers(members) ? makeUnionClass(members) : isNonEmptyReadonlyArray(members) ? members[0] : Never;
}
/**
* @category combinators
* @since 0.67.0
*/
const UndefinedOr = (self) => Union(self, Undefined);
var ElementImpl = class ElementImpl {
	ast;
	from;
	[TypeId];
	_Token;
	constructor(ast, from) {
		this.ast = ast;
		this.from = from;
	}
	annotations(annotations$1) {
		return new ElementImpl(new OptionalType(this.ast.type, this.ast.isOptional, {
			...this.ast.annotations,
			...toASTAnnotations(annotations$1)
		}), this.from);
	}
	toString() {
		return `${this.ast.type}${this.ast.isOptional ? "?" : ""}`;
	}
};
const getDefaultTupleTypeAST = (elements, rest) => new TupleType(elements.map((el) => isSchema(el) ? new OptionalType(el.ast, false) : el.ast), rest.map((el) => isSchema(el) ? new Type$1(el.ast) : el.ast), true);
const makeTupleTypeClass = (elements, rest, ast = getDefaultTupleTypeAST(elements, rest)) => class TupleTypeClass extends make(ast) {
	static annotations(annotations$1) {
		return makeTupleTypeClass(this.elements, this.rest, mergeSchemaAnnotations(this.ast, annotations$1));
	}
	static elements = [...elements];
	static rest = [...rest];
};
function Tuple(...args$1) {
	return Array.isArray(args$1[0]) ? makeTupleTypeClass(args$1[0], args$1.slice(1)) : makeTupleTypeClass(args$1, []);
}
const formatPropertySignatureToken = (isOptional) => isOptional ? "\"?:\"" : "\":\"";
/**
* @category PropertySignature
* @since 0.67.0
*/
var PropertySignatureDeclaration = class extends OptionalType {
	isReadonly;
	defaultValue;
	/**
	* @since 0.67.0
	*/
	_tag = "PropertySignatureDeclaration";
	constructor(type, isOptional, isReadonly, annotations$1, defaultValue) {
		super(type, isOptional, annotations$1);
		this.isReadonly = isReadonly;
		this.defaultValue = defaultValue;
	}
	/**
	* @since 0.67.0
	*/
	toString() {
		const token = formatPropertySignatureToken(this.isOptional);
		const type = String(this.type);
		return `PropertySignature<${token}, ${type}, never, ${token}, ${type}>`;
	}
};
/**
* @category PropertySignature
* @since 0.67.0
*/
var FromPropertySignature = class extends OptionalType {
	isReadonly;
	fromKey;
	constructor(type, isOptional, isReadonly, annotations$1, fromKey) {
		super(type, isOptional, annotations$1);
		this.isReadonly = isReadonly;
		this.fromKey = fromKey;
	}
};
/**
* @category PropertySignature
* @since 0.67.0
*/
var ToPropertySignature = class extends OptionalType {
	isReadonly;
	defaultValue;
	constructor(type, isOptional, isReadonly, annotations$1, defaultValue) {
		super(type, isOptional, annotations$1);
		this.isReadonly = isReadonly;
		this.defaultValue = defaultValue;
	}
};
const formatPropertyKey = (p) => {
	if (p === void 0) return "never";
	if (isString(p)) return JSON.stringify(p);
	return String(p);
};
/**
* @category PropertySignature
* @since 0.67.0
*/
var PropertySignatureTransformation = class {
	from;
	to;
	decode;
	encode;
	/**
	* @since 0.67.0
	*/
	_tag = "PropertySignatureTransformation";
	constructor(from, to, decode$4, encode$3) {
		this.from = from;
		this.to = to;
		this.decode = decode$4;
		this.encode = encode$3;
	}
	/**
	* @since 0.67.0
	*/
	toString() {
		return `PropertySignature<${formatPropertySignatureToken(this.to.isOptional)}, ${this.to.type}, ${formatPropertyKey(this.from.fromKey)}, ${formatPropertySignatureToken(this.from.isOptional)}, ${this.from.type}>`;
	}
};
const mergeSignatureAnnotations = (ast, annotations$1) => {
	switch (ast._tag) {
		case "PropertySignatureDeclaration": return new PropertySignatureDeclaration(ast.type, ast.isOptional, ast.isReadonly, {
			...ast.annotations,
			...annotations$1
		}, ast.defaultValue);
		case "PropertySignatureTransformation": return new PropertySignatureTransformation(new FromPropertySignature(ast.from.type, ast.from.isOptional, ast.from.isReadonly, ast.from.annotations), new ToPropertySignature(ast.to.type, ast.to.isOptional, ast.to.isReadonly, {
			...ast.to.annotations,
			...annotations$1
		}, ast.to.defaultValue), ast.decode, ast.encode);
	}
};
/**
* @since 0.68.0
* @category symbol
*/
const PropertySignatureTypeId = /* @__PURE__ */ Symbol.for("@effect/schema/PropertySignature");
/**
* @since 0.69.3
* @category guards
*/
const isPropertySignature = (u) => hasProperty(u, PropertySignatureTypeId);
var PropertySignatureImpl = class PropertySignatureImpl {
	ast;
	[TypeId];
	[PropertySignatureTypeId] = null;
	_TypeToken;
	_Key;
	_EncodedToken;
	_HasDefault;
	constructor(ast) {
		this.ast = ast;
	}
	pipe() {
		return pipeArguments(this, arguments);
	}
	annotations(annotations$1) {
		return new PropertySignatureImpl(mergeSignatureAnnotations(this.ast, toASTAnnotations(annotations$1)));
	}
	toString() {
		return String(this.ast);
	}
};
var PropertySignatureWithFromImpl = class PropertySignatureWithFromImpl extends PropertySignatureImpl {
	from;
	constructor(ast, from) {
		super(ast);
		this.from = from;
	}
	annotations(annotations$1) {
		return new PropertySignatureWithFromImpl(mergeSignatureAnnotations(this.ast, toASTAnnotations(annotations$1)), this.from);
	}
};
/**
* @category PropertySignature
* @since 0.69.0
*/
const optional = (self) => {
	const ast = self.ast === undefinedKeyword || self.ast === neverKeyword ? undefinedKeyword : UndefinedOr(self).ast;
	return new PropertySignatureWithFromImpl(new PropertySignatureDeclaration(ast, true, true, {}, void 0), self);
};
const getDefaultTypeLiteralAST = (fields, records) => {
	const ownKeys$1 = ownKeys(fields);
	const pss = [];
	if (ownKeys$1.length > 0) {
		const from = [];
		const to = [];
		const transformations = [];
		for (let i = 0; i < ownKeys$1.length; i++) {
			const key = ownKeys$1[i];
			const field = fields[key];
			if (isPropertySignature(field)) {
				const ast = field.ast;
				switch (ast._tag) {
					case "PropertySignatureDeclaration": {
						const type = ast.type;
						const isOptional = ast.isOptional;
						const toAnnotations = ast.annotations;
						from.push(new PropertySignature(key, type, isOptional, true));
						to.push(new PropertySignature(key, typeAST(type), isOptional, true, toAnnotations));
						pss.push(new PropertySignature(key, type, isOptional, true, toAnnotations));
						break;
					}
					case "PropertySignatureTransformation": {
						const fromKey = ast.from.fromKey ?? key;
						from.push(new PropertySignature(fromKey, ast.from.type, ast.from.isOptional, true, ast.from.annotations));
						to.push(new PropertySignature(key, ast.to.type, ast.to.isOptional, true, ast.to.annotations));
						transformations.push(new PropertySignatureTransformation$1(fromKey, key, ast.decode, ast.encode));
						break;
					}
				}
			} else {
				from.push(new PropertySignature(key, field.ast, false, true));
				to.push(new PropertySignature(key, typeAST(field.ast), false, true));
				pss.push(new PropertySignature(key, field.ast, false, true));
			}
		}
		if (isNonEmptyReadonlyArray(transformations)) {
			const issFrom = [];
			const issTo = [];
			for (const r of records) {
				const { indexSignatures, propertySignatures } = record(r.key.ast, r.value.ast);
				propertySignatures.forEach((ps) => {
					from.push(ps);
					to.push(new PropertySignature(ps.name, typeAST(ps.type), ps.isOptional, ps.isReadonly, ps.annotations));
				});
				indexSignatures.forEach((is) => {
					issFrom.push(is);
					issTo.push(new IndexSignature(is.parameter, typeAST(is.type), is.isReadonly));
				});
			}
			return new Transformation$1(new TypeLiteral(from, issFrom, { [TitleAnnotationId]: "Struct (Encoded side)" }), new TypeLiteral(to, issTo, { [TitleAnnotationId]: "Struct (Type side)" }), new TypeLiteralTransformation(transformations));
		}
	}
	const iss = [];
	for (const r of records) {
		const { indexSignatures, propertySignatures } = record(r.key.ast, r.value.ast);
		propertySignatures.forEach((ps) => pss.push(ps));
		indexSignatures.forEach((is) => iss.push(is));
	}
	return new TypeLiteral(pss, iss);
};
const lazilyMergeDefaults = (fields, out) => {
	const ownKeys$1 = ownKeys(fields);
	for (const key of ownKeys$1) {
		const field = fields[key];
		if (out[key] === void 0 && isPropertySignature(field)) {
			const ast = field.ast;
			const defaultValue = ast._tag === "PropertySignatureDeclaration" ? ast.defaultValue : ast.to.defaultValue;
			if (defaultValue !== void 0) out[key] = defaultValue();
		}
	}
	return out;
};
const makeTypeLiteralClass = (fields, records, ast = getDefaultTypeLiteralAST(fields, records)) => {
	return class TypeLiteralClass extends make(ast) {
		static annotations(annotations$1) {
			return makeTypeLiteralClass(this.fields, this.records, mergeSchemaAnnotations(this.ast, annotations$1));
		}
		static fields = { ...fields };
		static records = [...records];
		static make = (props, options) => {
			const propsWithDefaults = lazilyMergeDefaults(fields, { ...props });
			return getDisableValidationMakeOption(options) ? propsWithDefaults : validateSync(this)(propsWithDefaults);
		};
		static pick(...keys$5) {
			return Struct(pick(fields, ...keys$5));
		}
		static omit(...keys$5) {
			return Struct(omit(fields, ...keys$5));
		}
	};
};
function Struct(fields, ...records) {
	return makeTypeLiteralClass(fields, records);
}
const preserveRefinementAnnotations = /* @__PURE__ */ blackListAnnotations([IdentifierAnnotationId]);
/**
* @since 0.68.8
* @category symbol
*/
const refineTypeId = /* @__PURE__ */ Symbol.for("@effect/schema/refine");
const makeRefineClass = (from, filter$7, ast) => class RefineClass extends make(ast) {
	static annotations(annotations$1) {
		return makeRefineClass(this.from, this.filter, mergeSchemaAnnotations(this.ast, annotations$1));
	}
	static [refineTypeId] = from;
	static from = from;
	static filter = filter$7;
	static make = (a, options) => {
		return getDisableValidationMakeOption(options) ? a : validateSync(this)(a);
	};
};
const fromFilterPredicateReturnTypeItem = (item, ast, input) => {
	if (isBoolean$1(item)) return item ? none$7() : some$4(new Type(ast, input));
	if (isString(item)) return some$4(new Type(ast, input, item));
	if (item !== void 0) {
		if ("_tag" in item) return some$4(item);
		const issue = new Type(ast, input, item.message);
		return some$4(isNonEmptyReadonlyArray(item.path) ? new Pointer(item.path, input, issue) : issue);
	}
	return none$7();
};
const toFilterParseIssue = (out, ast, input) => {
	if (isSingle(out)) return fromFilterPredicateReturnTypeItem(out, ast, input);
	if (isNonEmptyReadonlyArray(out)) {
		const issues = filterMap$4(out, (issue) => fromFilterPredicateReturnTypeItem(issue, ast, input));
		if (isNonEmptyReadonlyArray(issues)) return some$4(issues.length === 1 ? issues[0] : new Composite(ast, input, issues));
	}
	return none$7();
};
function filter(predicate, annotations$1) {
	return (self) => {
		function filter$7(input, options, ast$1) {
			return toFilterParseIssue(predicate(input, options, ast$1), ast$1, input);
		}
		const ast = new Refinement$1(self.ast, filter$7, toASTAnnotations(annotations$1));
		return makeRefineClass(self, filter$7, ast);
	};
}
const makeTransformationClass = (from, to, ast) => class TransformationClass extends make(ast) {
	static annotations(annotations$1) {
		return makeTransformationClass(this.from, this.to, mergeSchemaAnnotations(this.ast, annotations$1));
	}
	static from = from;
	static to = to;
};
/**
* Create a new `Schema` by transforming the input and output of an existing `Schema`
* using the provided decoding functions.
*
* @category transformations
* @since 0.67.0
*/
const transformOrFail = /* @__PURE__ */ dual((args$1) => isSchema(args$1[0]) && isSchema(args$1[1]), (from, to, options) => makeTransformationClass(from, to, new Transformation$1(from.ast, to.ast, new FinalTransformation(options.decode, options.encode))));
/**
* Create a new `Schema` by transforming the input and output of an existing `Schema`
* using the provided mapping functions.
*
* @category transformations
* @since 0.67.0
*/
const transform = /* @__PURE__ */ dual((args$1) => isSchema(args$1[0]) && isSchema(args$1[1]), (from, to, options) => transformOrFail(from, to, {
	strict: true,
	decode: (fromA, _options, _ast, toA) => succeed(options.decode(fromA, toA)),
	encode: (toI, _options, _ast, toA) => succeed(options.encode(toI, toA))
}));
/**
* @category type id
* @since 0.67.0
*/
const MaxLengthTypeId = MaxLengthTypeId$1;
/**
* @category type id
* @since 0.67.0
*/
const MinLengthTypeId = MinLengthTypeId$1;
/**
* @category type id
* @since 0.67.0
*/
const PatternTypeId = /* @__PURE__ */ Symbol.for("@effect/schema/TypeId/Pattern");
/**
* @category string filters
* @since 0.67.0
*/
const pattern = (regex, annotations$1) => (self) => {
	const pattern$1 = regex.source;
	return self.pipe(filter((a) => {
		regex.lastIndex = 0;
		return regex.test(a);
	}, {
		typeId: {
			id: PatternTypeId,
			annotation: { regex }
		},
		description: `a string matching the pattern ${pattern$1}`,
		jsonSchema: { pattern: pattern$1 },
		arbitrary: () => (fc) => fc.stringMatching(regex),
		...annotations$1
	}));
};
/**
* @category type id
* @since 0.67.0
*/
const LengthTypeId = LengthTypeId$1;
const JsonString = /* @__PURE__ */ String$.annotations({
	[IdentifierAnnotationId]: "JsonString",
	[TitleAnnotationId]: "JsonString",
	[DescriptionAnnotationId]: "a JSON string"
});
/**
* @category type id
* @since 0.67.0
*/
const FiniteTypeId = /* @__PURE__ */ Symbol.for("@effect/schema/TypeId/Finite");
/**
* Ensures that the provided value is a finite number.
*
* This schema filters out non-finite numeric values, allowing only finite numbers to pass through.
*
* @category number filters
* @since 0.67.0
*/
const finite = (annotations$1) => (self) => self.pipe(filter((a) => Number.isFinite(a), {
	typeId: FiniteTypeId,
	description: "a finite number",
	...annotations$1
}));
/**
* @category type id
* @since 0.67.0
*/
const GreaterThanTypeId = GreaterThanTypeId$1;
/**
* @category type id
* @since 0.67.0
*/
const GreaterThanOrEqualToTypeId = GreaterThanOrEqualToTypeId$1;
/**
* This filter checks whether the provided number is greater than or equal to the specified minimum.
*
* @category number filters
* @since 0.67.0
*/
const greaterThanOrEqualTo = (min$2, annotations$1) => (self) => self.pipe(filter((a) => a >= min$2, {
	typeId: GreaterThanOrEqualToTypeId,
	description: min$2 === 0 ? "a non-negative number" : `a number greater than or equal to ${min$2}`,
	jsonSchema: { minimum: min$2 },
	...annotations$1
}));
/**
* @category type id
* @since 0.67.0
*/
const IntTypeId = IntTypeId$1;
/**
* @category number filters
* @since 0.67.0
*/
const int = (annotations$1) => (self) => self.pipe(filter((a) => Number.isSafeInteger(a), {
	typeId: IntTypeId,
	title: "integer",
	description: "an integer",
	jsonSchema: { type: "integer" },
	...annotations$1
}));
/**
* @category type id
* @since 0.67.0
*/
const LessThanTypeId = LessThanTypeId$1;
/**
* @category type id
* @since 0.67.0
*/
const LessThanOrEqualToTypeId = LessThanOrEqualToTypeId$1;
/**
* This schema checks whether the provided number is less than or equal to the specified maximum.
*
* @category number filters
* @since 0.67.0
*/
const lessThanOrEqualTo = (max$4, annotations$1) => (self) => self.pipe(filter((a) => a <= max$4, {
	typeId: LessThanOrEqualToTypeId,
	description: max$4 === 0 ? "a non-positive number" : `a number less than or equal to ${max$4}`,
	jsonSchema: { maximum: max$4 },
	...annotations$1
}));
/**
* @category type id
* @since 0.67.0
*/
const BetweenTypeId = BetweenTypeId$1;
/**
* @category number filters
* @since 0.67.0
*/
const nonNegative = (annotations$1) => greaterThanOrEqualTo(0, annotations$1);
/**
* @category number constructors
* @since 0.67.0
*/
var NonNegative = class extends Number$.pipe(/* @__PURE__ */ nonNegative({
	identifier: "NonNegative",
	title: "NonNegative"
})) {};
/**
* @category type id
* @since 0.67.0
*/
const GreaterThanBigIntTypeId = GreaterThanBigintTypeId;
/**
* @category type id
* @since 0.67.0
*/
const GreaterThanOrEqualToBigIntTypeId = GreaterThanOrEqualToBigIntTypeId$1;
/**
* @category type id
* @since 0.67.0
*/
const LessThanBigIntTypeId = LessThanBigIntTypeId$1;
/**
* @category type id
* @since 0.67.0
*/
const LessThanOrEqualToBigIntTypeId = LessThanOrEqualToBigIntTypeId$1;
/**
* @category type id
* @since 0.67.0
*/
const BetweenBigIntTypeId = BetweenBigintTypeId;
const hrTime = /* @__PURE__ */ Tuple(/* @__PURE__ */ NonNegative.pipe(/* @__PURE__ */ finite({
	[TitleAnnotationId]: "seconds",
	[DescriptionAnnotationId]: "seconds"
})), /* @__PURE__ */ NonNegative.pipe(/* @__PURE__ */ finite({
	[TitleAnnotationId]: "nanos",
	[DescriptionAnnotationId]: "nanos"
})));
/**
* @category Uint8Array constructors
* @since 0.67.0
*/
const Uint8ArrayFromSelf = /* @__PURE__ */ declare(isUint8Array, {
	identifier: "Uint8ArrayFromSelf",
	pretty: () => (u8arr) => `new Uint8Array(${JSON.stringify(Array.from(u8arr))})`,
	arbitrary: () => (fc) => fc.uint8Array(),
	equivalence: () => getEquivalence$3(equals)
});
const makeUint8ArrayTransformation = (id$2, decode$4, encode$3) => transformOrFail(String$.annotations({ description: "a string that will be parsed into a Uint8Array" }), Uint8ArrayFromSelf, {
	strict: true,
	decode: (s, _, ast) => mapLeft(decode$4(s), (decodeException) => new Type(ast, s, decodeException.message)),
	encode: (u) => succeed(encode$3(u))
}).annotations({ identifier: id$2 });
/**
* Decodes a base64 (RFC4648) encoded string into a `Uint8Array`.
*
* @category Uint8Array transformations
* @since 0.67.0
*/
const Uint8ArrayFromBase64 = /* @__PURE__ */ makeUint8ArrayTransformation("Uint8ArrayFromBase64", decodeBase64, encodeBase64);
/**
* Decodes a base64 (URL) encoded string into a `Uint8Array`.
*
* @category Uint8Array transformations
* @since 0.67.0
*/
const Uint8ArrayFromBase64Url = /* @__PURE__ */ makeUint8ArrayTransformation("Uint8ArrayFromBase64Url", decodeBase64Url, encodeBase64Url);
/**
* Decodes a hex encoded string into a `Uint8Array`.
*
* @category Uint8Array transformations
* @since 0.67.0
*/
const Uint8ArrayFromHex = /* @__PURE__ */ makeUint8ArrayTransformation("Uint8ArrayFromHex", decodeHex, encodeHex);
const makeEncodingTransformation = (id$2, decode$4, encode$3) => transformOrFail(String$.annotations({ description: `A string that is interpreted as being ${id$2}-encoded and will be decoded into a UTF-8 string` }), String$, {
	strict: true,
	decode: (s, _, ast) => mapLeft(decode$4(s), (decodeException) => new Type(ast, s, decodeException.message)),
	encode: (u) => succeed(encode$3(u))
}).annotations({ identifier: `StringFrom${id$2}` });
/**
* Decodes a base64 (RFC4648) encoded string into a UTF-8 string.
*
* @category string transformations
* @since 0.67.0
*/
const StringFromBase64 = /* @__PURE__ */ makeEncodingTransformation("Base64", decodeBase64String, encodeBase64);
/**
* Decodes a base64 (URL) encoded string into a UTF-8 string.
*
* @category string transformations
* @since 0.67.0
*/
const StringFromBase64Url = /* @__PURE__ */ makeEncodingTransformation("Base64Url", decodeBase64UrlString, encodeBase64Url);
/**
* Decodes a hex encoded string into a UTF-8 string.
*
* @category string transformations
* @since 0.67.0
*/
const StringFromHex = /* @__PURE__ */ makeEncodingTransformation("Hex", decodeHexString, encodeHex);
/**
* @category type id
* @since 0.67.0
*/
const MinItemsTypeId = MinItemsTypeId$1;
/**
* @category type id
* @since 0.67.0
*/
const MaxItemsTypeId = MaxItemsTypeId$1;
/**
* @category type id
* @since 0.67.0
*/
const ItemsCountTypeId = ItemsCountTypeId$1;
const getDisableValidationMakeOption = (options) => isBoolean$1(options) ? options : options?.disableValidation ?? false;

//#endregion
//#region runtime/effect.ts
var import_cjs = /* @__PURE__ */ __toESM(require_cjs(), 1);
const createInsertSchema = (_table) => Unknown;
const createSelectSchema = (_table) => Unknown;
const IdWithPrefix = (prefix) => String$.pipe(pattern(/* @__PURE__ */ new RegExp(`^${prefix}_[0-9A-Za-z]{12}$`)));
const JsonValue = Unknown;
const IanaTimezone = String$.pipe(filter((tz) => {
	try {
		new Intl.DateTimeFormat(void 0, { timeZone: tz });
		return true;
	} catch {
		return false;
	}
}, { message: () => "Invalid IANA timezone" }));
const DineroSnapshot = Struct({
	amount: Number$,
	currency: optional(Struct({
		code: String$,
		base: Number$,
		exponent: Number$
	})),
	scale: optional(Number$)
});
const DineroType = transform(DineroSnapshot, Any, {
	decode: (snap) => (0, import_cjs.dinero)(snap),
	encode: (d) => (0, import_cjs.toSnapshot)(d)
});
const Percentage = Number$.pipe(greaterThanOrEqualTo(0), lessThanOrEqualTo(100));
const NonNegativeInt = Number$.pipe(int(), greaterThanOrEqualTo(0));
const UsersInsert = createInsertSchema(schema.users);
const UsersSelect = createSelectSchema(schema.users);
const OrganizationsInsert = createInsertSchema(schema.organizations);
const OrganizationsSelect = createSelectSchema(schema.organizations);
const CurrencyInsert = createInsertSchema(schema.currency);
const CurrencySelect = createSelectSchema(schema.currency);
const RegionInsert = createInsertSchema(schema.region);
const RegionSelect = createSelectSchema(schema.region);
const RegionCountryInsert = createInsertSchema(schema.regionCountry);
const RegionCountrySelect = createSelectSchema(schema.regionCountry);
const RegionPaymentProviderInsert = createInsertSchema(schema.regionPaymentProvider);
const RegionPaymentProviderSelect = createSelectSchema(schema.regionPaymentProvider);
const LocationTypeInsert = createInsertSchema(schema.locationType);
const LocationTypeSelect = createSelectSchema(schema.locationType);
const AddressInsert = createInsertSchema(schema.address);
const AddressSelect = createSelectSchema(schema.address);
const OrganizationSettingsInsert = createInsertSchema(schema.organizationSettings);
const OrganizationSettingsSelect = createSelectSchema(schema.organizationSettings);
const BrandProfileInsert = createInsertSchema(schema.brandProfile);
const BrandProfileSelect = createSelectSchema(schema.brandProfile);
const StockLocationInsert = createInsertSchema(schema.stockLocation);
const StockLocationSelect = createSelectSchema(schema.stockLocation);
const SalesChannelInsert = createInsertSchema(schema.salesChannel);
const SalesChannelSelect = createSelectSchema(schema.salesChannel);
const SalesChannelStockLocationInsert = createInsertSchema(schema.salesChannelStockLocation);
const SalesChannelStockLocationSelect = createSelectSchema(schema.salesChannelStockLocation);
const ProductTypeInsert = createInsertSchema(schema.productType);
const ProductTypeSelect = createSelectSchema(schema.productType);
const ProductCategoryInsert = createInsertSchema(schema.productCategory);
const ProductCategorySelect = createSelectSchema(schema.productCategory);
const ProductInsert = createInsertSchema(schema.product);
const ProductSelect = createSelectSchema(schema.product);
const ProductVariantInsert = createInsertSchema(schema.productVariant);
const ProductVariantSelect = createSelectSchema(schema.productVariant);
const ProductGroupInsert = createInsertSchema(schema.productGroup);
const ProductGroupSelect = createSelectSchema(schema.productGroup);
const ProductGroupProductInsert = createInsertSchema(schema.productGroupProduct);
const ProductGroupProductSelect = createSelectSchema(schema.productGroupProduct);
const ProductCategoryProductInsert = createInsertSchema(schema.productCategoryProduct);
const ProductCategoryProductSelect = createSelectSchema(schema.productCategoryProduct);
const ProductTagInsert = createInsertSchema(schema.productTag);
const ProductTagSelect = createSelectSchema(schema.productTag);
const PriceSetInsert = createInsertSchema(schema.priceSet);
const PriceSetSelect = createSelectSchema(schema.priceSet);
const PriceInsert = createInsertSchema(schema.price);
const PriceSelect = createSelectSchema(schema.price);
const ProductVariantPriceSetInsert = createInsertSchema(schema.productVariantPriceSet);
const ProductVariantPriceSetSelect = createSelectSchema(schema.productVariantPriceSet);
const ProductSalesChannelInsert = createInsertSchema(schema.productSalesChannel);
const ProductSalesChannelSelect = createSelectSchema(schema.productSalesChannel);
const TaxRateInsert = createInsertSchema(schema.taxRate);
const TaxRateSelect = createSelectSchema(schema.taxRate);
const ProductVariantTaxRateInsert = createInsertSchema(schema.productVariantTaxRate);
const ProductVariantTaxRateSelect = createSelectSchema(schema.productVariantTaxRate);
const FeeInsert = createInsertSchema(schema.fee);
const FeeSelect = createSelectSchema(schema.fee);
const PaymentProviderInsert = createInsertSchema(schema.paymentProvider);
const PaymentProviderSelect = createSelectSchema(schema.paymentProvider);
const PaymentCollectionInsert = createInsertSchema(schema.paymentCollection);
const PaymentCollectionSelect = createSelectSchema(schema.paymentCollection);
const PaymentIntentInsert = createInsertSchema(schema.paymentIntent);
const PaymentIntentSelect = createSelectSchema(schema.paymentIntent);
const PaymentAttemptInsert = createInsertSchema(schema.paymentAttempt);
const PaymentAttemptSelect = createSelectSchema(schema.paymentAttempt);
const PaymentMethodInsert = createInsertSchema(schema.paymentMethod);
const PaymentMethodSelect = createSelectSchema(schema.paymentMethod);
const RefundReasonInsert = createInsertSchema(schema.refundReason);
const RefundReasonSelect = createSelectSchema(schema.refundReason);
const RefundInsert = createInsertSchema(schema.refund);
const RefundSelect = createSelectSchema(schema.refund);
const InvoiceInsert = createInsertSchema(schema.invoice);
const InvoiceSelect = createSelectSchema(schema.invoice);
const SubscriptionInsert = createInsertSchema(schema.subscription);
const SubscriptionSelect = createSelectSchema(schema.subscription);
const SubscriptionSchedulePhaseInsert = createInsertSchema(schema.subscriptionSchedulePhase);
const SubscriptionSchedulePhaseSelect = createSelectSchema(schema.subscriptionSchedulePhase);
const InstallmentInsert = createInsertSchema(schema.installment);
const InstallmentSelect = createSelectSchema(schema.installment);

//#endregion
export { AddressInsert, AddressSelect, BrandProfileInsert, BrandProfileSelect, CurrencyInsert, CurrencySelect, DineroType, FeeInsert, FeeSelect, IanaTimezone, IdWithPrefix, InstallmentInsert, InstallmentSelect, InvoiceInsert, InvoiceSelect, JsonValue, LocationTypeInsert, LocationTypeSelect, NonNegativeInt, OrganizationSettingsInsert, OrganizationSettingsSelect, OrganizationsInsert, OrganizationsSelect, PaymentAttemptInsert, PaymentAttemptSelect, PaymentCollectionInsert, PaymentCollectionSelect, PaymentIntentInsert, PaymentIntentSelect, PaymentMethodInsert, PaymentMethodSelect, PaymentProviderInsert, PaymentProviderSelect, Percentage, PriceInsert, PriceSelect, PriceSetInsert, PriceSetSelect, ProductCategoryInsert, ProductCategoryProductInsert, ProductCategoryProductSelect, ProductCategorySelect, ProductGroupInsert, ProductGroupProductInsert, ProductGroupProductSelect, ProductGroupSelect, ProductInsert, ProductSalesChannelInsert, ProductSalesChannelSelect, ProductSelect, ProductTagInsert, ProductTagSelect, ProductTypeInsert, ProductTypeSelect, ProductVariantInsert, ProductVariantPriceSetInsert, ProductVariantPriceSetSelect, ProductVariantSelect, ProductVariantTaxRateInsert, ProductVariantTaxRateSelect, RefundInsert, RefundReasonInsert, RefundReasonSelect, RefundSelect, RegionCountryInsert, RegionCountrySelect, RegionInsert, RegionPaymentProviderInsert, RegionPaymentProviderSelect, RegionSelect, SalesChannelInsert, SalesChannelSelect, SalesChannelStockLocationInsert, SalesChannelStockLocationSelect, StockLocationInsert, StockLocationSelect, SubscriptionInsert, SubscriptionSchedulePhaseInsert, SubscriptionSchedulePhaseSelect, SubscriptionSelect, TaxRateInsert, TaxRateSelect, UsersInsert, UsersSelect };